#!/usr/bin/env bash

set -euo pipefail
VERSION="1.0"

# ---------------------------- defaults ----------------------------
spread=3.0 freq=0.1 seed=0
animation_style=none # none | classic | line
duration=1 speed=5.0
invert=false want_truecolor=false force=false
build_box=false box_style="default" # default|parchment|simple|html|shell
orientation="h"                     # h|v|d
palette_file="" theme="rainbow"
ascii_image="" blink=false
THEMES=()
no_color=false
mode="char" # char|line

match_regex="" only_match=false strip_ansi=false
log_mode=false stream_mode=false
box_title="" box_center=false
header_text=""
list_themes=false sample_theme="" random_theme=false
do_self_update=false

# --------------------------- helpers ------------------------------
require() { command -v "$1" >/dev/null 2>&1 || {
  printf 'Error: %s required\n' "$1" >&2
  exit 1
}; }

detect_term_size() {
  TERM_WIDTH=$(tput cols 2>/dev/null || echo 80)
  TERM_HEIGHT=$(tput lines 2>/dev/null || echo 24)
  ((TERM_HEIGHT -= 4))
  ((TERM_WIDTH > 160)) && TERM_WIDTH=160
  ((TERM_HEIGHT > 60)) && TERM_HEIGHT=60
}

usage() {
  cat <<EOF
chromacat $VERSION – colourful text printer

USAGE
  $(basename "$0") [OPTIONS] [FILE]...

COLOUR / ANIMATION
  -p, --spread <f>         Rainbow spread (default $spread)
  -F, --freq   <f>         Rainbow frequency (default $freq)
  -S, --seed   <n>         Seed (0=random)
  -a, --animate            Classic scrolling animation
  -aa,--line               Line-by-line reveal animation
      --style <name>       Animation style (classic|line|none)
      --per-line           Use one colour per line (faster, log-friendly)
  -d, --duration <sec>     Animation seconds (default $duration)
  -s, --speed <fps>        Frames / second (default $speed)
  -m, --match <regex>      Colour only text matching regex
      --only-match         Hide non-matching characters
      --strip-ansi         Strip existing ANSI codes before colouring
      --log                Log preset (no animation, per-line gradient)
      --stream             Disable animations for streaming input

APPEARANCE
  -i, --invert             Invert foreground / background
  -t, --truecolor          Force 24-bit colour
  -f, --force              Colour even if stdout not a TTY
  -b, --box                Draw ASCII box
  -B, --box-style <name>   Box style: default|dashed|dash2|round|double|heavy|parchment|simple|shell|html|plus|comment|php|chain
      --title <text>       Box title line
      --center             Center-align box content
  -O, --orientation <o>    Gradient orientation: h|v|d
  -P, --palette <file>     Palette file (HEX per line)
  -T, --theme <name>       fire|ice|sunset|ocean|rainbow
      --list-themes        Show available themes and exit
      --sample-theme <n>   Preview theme and exit
      --random-theme       Pick a random theme
  -I, --image <file>       ASCII-art mode via img2txt/jp2a/chafa
      --blink              Blinking text

MISC
  -H, --header <text>      Render header/banner (figlet if available)
  -U, --self-update        Fetch latest chromacat and replace current script
  -v, --version            Print version and exit
  -h, --help               Show this help

ENV
  CHROMACAT_PATH           Override update target path for --self-update

EXAMPLES
  echo "hello" | chromacat -a -d 2
  figlet "Docker" | chromacat -b -B parchment -aa -d 6 -O d
  chromacat -I screenshot.png
EOF
}

self_update() {
  require curl

  local script_url="https://raw.githubusercontent.com/infocyph/Toolset/main/ChromaCat/chromacat"
  local temp_file
  if ! temp_file=$(mktemp /tmp/chromacat.XXXXXX 2>/dev/null); then
    temp_file="/tmp/chromacat.$$"
  fi

  local target="${CHROMACAT_PATH:-}"
  if [[ -z $target ]]; then
    if command -v chromacat >/dev/null 2>&1; then
      target=$(command -v chromacat)
    else
      target="$0"
    fi
  fi

  echo "Checking for updates to chromacat..."
  echo "Source: $script_url"
  echo "Target: $target"

  if ! curl -fsSL "$script_url" -o "$temp_file"; then
    echo "Failed to download the latest chromacat script from GitHub." >&2
    rm -f "$temp_file" || true
    return 1
  fi

  if command -v sha256sum >/dev/null 2>&1 && [[ -f "$target" ]]; then
    local remote_hash local_hash
    remote_hash="$(sha256sum "$temp_file" | awk '{print $1}')"
    local_hash="$(sha256sum "$target" 2>/dev/null | awk '{print $1}')"
    if [[ -n $remote_hash && "$remote_hash" == "$local_hash" ]]; then
      echo "chromacat is already up-to-date."
      rm -f "$temp_file" || true
      return 0
    fi
  fi

  if [[ -f "$target" ]]; then
    local backup="${target}.bak-$(date +'%Y%m%d%H%M%S')"
    cp "$target" "$backup" 2>/dev/null || true
  fi

  if ! mv "$temp_file" "$target" 2>/dev/null; then
    echo "Failed to overwrite $target. You may need to run with sudo or set CHROMACAT_PATH." >&2
    rm -f "$temp_file" || true
    return 1
  fi

  chmod +x "$target" || true
  echo "chromacat has been updated to the latest version."
  return 0
}

# ------------------------ env defaults ---------------------------
# Environment-configurable defaults (CLI still wins)
if [[ -n ${CHROMACAT_THEME:-} ]]; then
  IFS=',' read -ra THEMES <<<"$CHROMACAT_THEME"
fi
box_style=${CHROMACAT_BOX_STYLE:-$box_style}
animation_style=${CHROMACAT_STYLE:-$animation_style}

# ------------------------- option parsing -------------------------
require getopt
OPTS=$(getopt -o p:F:S:ad:s:itfbB:O:P:T:I:vhm:H:U \
  --long spread:,freq:,seed:,animate,style:,line,duration:,speed:,invert,truecolor,force,box,box-style:,orientation:,palette:,theme:,image:,blink,per-line,match:,only-match,strip-ansi,log,stream,list-themes,sample-theme:,random-theme,header:,title:,center,self-update,version,help -- "$@") ||
  {
    usage
    exit 1
  }

eval set -- "$OPTS"
while true; do
  case $1 in
  -p | --spread)
    spread=$2
    shift 2
    ;;
  -F | --freq)
    freq=$2
    shift 2
    ;;
  -S | --seed)
    seed=$2
    shift 2
    ;;
  -a | --animate)
    animation_style=classic
    shift
    ;;
  --style)
    animation_style=$2
    shift 2
    ;;
  -aa | --line)
    animation_style=line
    shift
    ;;
  --per-line)
    mode="line"
    shift
    ;;
  -d | --duration)
    duration=$2
    shift 2
    ;;
  -s | --speed)
    speed=$2
    shift 2
    ;;
  -m | --match)
    match_regex=$2
    shift 2
    ;;
  --only-match)
    only_match=true
    shift
    ;;
  --strip-ansi)
    strip_ansi=true
    shift
    ;;
  --log)
    log_mode=true
    shift
    ;;
  --stream)
    stream_mode=true
    shift
    ;;
  -i | --invert)
    invert=true
    shift
    ;;
  -t | --truecolor)
    want_truecolor=true
    shift
    ;;
  -f | --force)
    force=true
    shift
    ;;
  -b | --box)
    build_box=true
    shift
    ;;
  -B | --box-style)
    build_box=true
    box_style=$2
    shift 2
    ;;
  --title)
    box_title=$2
    build_box=true
    shift 2
    ;;
  --center)
    box_center=true
    shift
    ;;
  -O | --orientation)
    orientation=$2
    shift 2
    ;;
  -P | --palette)
    palette_file=$2
    shift 2
    ;;
  --blink)
    blink=true
    shift
    ;;
  -T | --theme)
    IFS=',' read -ra THEMES <<<"$2"
    shift 2
    ;;
  --list-themes)
    list_themes=true
    shift
    ;;
  --sample-theme)
    sample_theme=$2
    shift 2
    ;;
  --random-theme)
    random_theme=true
    shift
    ;;
  -I | --image)
    ascii_image=$2
    shift 2
    ;;
  -H | --header)
    header_text=$2
    shift 2
    ;;
  -U | --self-update)
    do_self_update=true
    shift
    ;;
  -v | --version)
    printf '%s %s\n' "$(basename "$0")" "$VERSION"
    exit 0
    ;;
  -h | --help)
    usage
    exit 0
    ;;
  --)
    shift
    break
    ;;
  esac
done
files=("$@")

# ------------------ self-update early exit -----------------------
if [[ $do_self_update == true ]]; then
  self_update
  exit $?
fi

# ------------------ terminal dimensions --------------------------
detect_term_size

# ----------------------- AWK selection ---------------------------
if command -v gawk >/dev/null 2>&1; then
  AWK=gawk
elif command -v mawk >/dev/null 2>&1; then
  AWK=mawk
elif command -v awk >/dev/null 2>&1; then
  AWK=awk
else
  printf 'Error: no awk found\n' >&2
  exit 1
fi

# -------------- environment / sanity checks -----------------------
truecolor=false
[[ $want_truecolor == true && ${COLORTERM:-} == *truecolor* ]] && truecolor=true

if [[ ! -t 1 && $force == false ]]; then
  animation_style=none
  build_box=false
  truecolor=false
fi

for v in spread freq duration speed; do
  [[ ${!v} =~ ^[0-9]+(\.[0-9]+)?$ ]] || {
    echo "Invalid $v" >&2
    exit 1
  }
done

# honour NO_COLOR: hard-disable colour/animations
if [[ -n ${NO_COLOR:-} ]]; then
  no_color=true
  animation_style=none
  blink=false
  invert=false
  truecolor=false
fi

# log / stream presets
if [[ $log_mode == true ]]; then
  animation_style=none
  mode="line"
fi

if [[ $stream_mode == true ]]; then
  animation_style=none
fi

# list themes early
if [[ $list_themes == true ]]; then
  cat <<EOF
Available themes:
  fire
  ice
  sunset
  ocean
  rainbow
EOF
  exit 0
fi

# ---------------------------- seed -------------------------------
if ((seed > 0)); then
  SEED="$seed"
else
  SEED="$RANDOM"
fi

# -------------------- theme selection tweaks ---------------------
# sample-theme overrides env/CLI themes
if [[ -n $sample_theme ]]; then
  THEMES=("$sample_theme")
fi

# random-theme chooses if no explicit theme or palette
if [[ $random_theme == true && ${#THEMES[@]} -eq 0 && -z $palette_file ]]; then
  themes_rand=(fire ice sunset ocean rainbow)
  idx=$((RANDOM % ${#themes_rand[@]}))
  THEMES=("${themes_rand[$idx]}")
fi

# --------------------------- palette ------------------------------
PALETTE=""
if [[ -n $palette_file ]]; then
  mapfile -t _pal <"$palette_file" || {
    echo "Bad palette file" >&2
    exit 1
  }
  PALETTE=$(
    IFS=,
    echo "${_pal[*]}"
  )
elif [[ ${#THEMES[@]} -gt 0 ]]; then
  for theme in "${THEMES[@]}"; do
    case $theme in
    fire) PALETTE+=",FF6B00,FF8C00,FFA500,FFD700" ;;
    ice) PALETTE+=",00FFFF,00CED1,1E90FF,4169E1" ;;
    sunset) PALETTE+=",FF4500,FF6347,FF7F50,FF8C00,FFD700" ;;
    ocean) PALETTE+=",006994,008CBA,00AEEF,33CCFF" ;;
    rainbow) PALETTE+=",FF0000,FF7F00,FFFF00,00FF00,0000FF,4B0082,8B00FF" ;;
    *) echo "Unknown theme: $theme" >&2 ;;
    esac
  done
  PALETTE="${PALETTE#,}"
fi

# map full words → one-char orientation
case $orientation in
horizontal) orientation="h" ;;
vertical) orientation="v" ;;
diagonal) orientation="d" ;;
esac

# ---------------------- colouriser (portable AWK) -----------------
colour_block() {
  $AWK -v spread="$spread" -v blink="$blink" -v freq="$freq" -v seed="$SEED" \
    -v tc="$truecolor" -v palette="$PALETTE" -v orient="$orientation" \
    -v invert="$invert" -v mode="$mode" -v match_regex="$match_regex" \
    -v only_match="$only_match" -v strip_ansi="$strip_ansi" '
  BEGIN {
    pi=3.1415926536;
    if (palette!="") pc=split(palette,p,",");
    has_match = (match_regex != "") ? 1 : 0;
  }
  function rgb(r,g,b){
    return (tc=="true") ?
      sprintf("38;2;%d;%d;%d",r,g,b) :
      sprintf("38;5;%d",16+int(r*6/256)*36+int(g*6/256)*6+int(b*6/256));
  }
  function blink_on()  { return "\033[5m" }
  function blink_off() { return "\033[25m" }
  function pal(i){ return p[(i%pc)+1] }
  function hex2dec(h,   n,v,i,d) {
    n = length(h);
    v = 0;
    for (i=1; i<=n; i++) {
      d = substr(h,i,1);
      v = v * 16 + index("0123456789abcdef", tolower(d)) - 1;
    }
    return v;
  }
  function rainbow(i,r,g,b,col){
    if (pc) {
      col = pal(i);
    } else {
      r = sin(freq*i)           *127 + 128;
      g = sin(freq*i+2*pi/3)    *127 + 128;
      b = sin(freq*i+4*pi/3)    *127 + 128;
      col = sprintf("%02X%02X%02X",r,g,b);
    }
    return col;
  }
  {
    line = $0;
    if (strip_ansi=="true") {
      gsub(/\033\[[0-9;]*m/, "", line);
    }

    delete in_match;
    if (has_match) {
      start = 1;
      while (start <= length(line)) {
        m = match(substr(line, start), match_regex);
        if (m == 0) break;
        m = m + start - 1;
        e = m + RLENGTH - 1;
        for (k = m; k <= e; k++) in_match[k] = 1;
        start = e + 1;
      }
    }

    have_line_code = 0;
    for (j=1; j<=length(line); j++) {
      c = substr(line,j,1);

      if (mode=="line") {
        if (!have_line_code) {
          if (orient=="v")       idx = NR;
          else if (orient=="d")  idx = NR;
          else                   idx = NR;
          idx += seed;
          col = rainbow(int(idx));
          r = hex2dec(substr(col,1,2));
          g = hex2dec(substr(col,3,2));
          b = hex2dec(substr(col,5,2));
          line_code = rgb(r,g,b);
          have_line_code = 1;
        }
        code = line_code;
      } else {
        if (orient=="v")       idx = NR;
        else if (orient=="d")  idx = NR + j/spread;
        else                   idx = j + NR/spread;
        idx += seed;
        col = rainbow(int(idx));
        r = hex2dec(substr(col,1,2));
        g = hex2dec(substr(col,3,2));
        b = hex2dec(substr(col,5,2));
        code = rgb(r,g,b);
      }

      if (has_match) {
        in_m = (j in in_match);
        if (!in_m) {
          if (only_match=="true") {
            continue;
          } else {
            printf "%s", c;
            continue;
          }
        }
      }

      if (invert=="true") printf "\033[7m";
      if (blink=="true")  printf "%s", blink_on();
      printf "\033[%sm%s", code, c;
      if (blink=="true")  printf "%s", blink_off();
      if (invert=="true") printf "\033[27m";
    }
    printf "\033[0m\n";
  }'
}

# --------------------------- box drawer ---------------------------
box_draw() {
  local style=$box_style
  mapfile -t LINES
  local max=0 line
  for line in "${LINES[@]}"; do ((${#line} > max)) && max=${#line}; done

  hr() { printf '%*s' "$1" | tr ' ' "$2"; }

  print_box_line() {
    local left=$1 text=$2 right=$3
    if [[ $box_center == true ]]; then
      local len=${#text}
      if ((len < max)); then
        local pad_left=$(((max - len) / 2))
        local pad_right=$((max - len - pad_left))
        printf '%s ' "$left"
        printf '%*s%s%*s' "$pad_left" "" "$text" "$pad_right" ""
        printf ' %s\n' "$right"
      else
        printf '%s %-*s %s\n' "$left" "$max" "$text" "$right"
      fi
    else
      printf '%s %-*s %s\n' "$left" "$max" "$text" "$right"
    fi
  }

  case $style in
  # ---------------------------------------------------------------- default  (+---)
  default)
    local tl='+' tr='+' bl='+' br='+' h='-' v='|'
    printf '%s' "$tl"
    hr $((max + 2)) "$h"
    printf '%s\n' "$tr"
    if [[ -n $box_title ]]; then print_box_line "$v" "$box_title" "$v"; fi
    for line in "${LINES[@]}"; do print_box_line "$v" "$line" "$v"; done
    printf '%s' "$bl"
    hr $((max + 2)) "$h"
    printf '%s\n' "$br"
    ;;

  # ---------------------------------------------------------------- dashed  (- - -)
  dashed)
    local tl='+' tr='+' bl='+' br='+' v='|'
    local dash_line=""
    for ((i = 0; i < max + 2; i++)); do
      if ((i % 2 == 0)); then dash_line+='-'; else dash_line+=' '; fi
    done
    printf '%s%s%s\n' "$tl" "$dash_line" "$tr"
    if [[ -n $box_title ]]; then print_box_line "$v" "$box_title" "$v"; fi
    for line in "${LINES[@]}"; do print_box_line "$v" "$line" "$v"; done
    printf '%s%s%s\n' "$bl" "$dash_line" "$br"
    ;;

  # ---------------------------------------------------------------- dash2
  dash2)
    local border
    border=$(hr $((max + 6)) '-')
    printf '%s\n' "$border"
    if [[ -n $box_title ]]; then printf '-- %-*s --\n' "$max" "$box_title"; fi
    for line in "${LINES[@]}"; do
      printf -- "-- %-*s --\n" "$max" "$line"
    done
    printf '%s\n' "$border"
    ;;

  # ---------------------------------------------------------------- double  (+===)
  double)
    local tl='+' tr='+' bl='+' br='+' h='=' v='|'
    printf '%s' "$tl"
    hr $((max + 2)) "$h"
    printf '%s\n' "$tr"
    if [[ -n $box_title ]]; then print_box_line "$v" "$box_title" "$v"; fi
    for line in "${LINES[@]}"; do print_box_line "$v" "$line" "$v"; done
    printf '%s' "$bl"
    hr $((max + 2)) "$h"
    printf '%s\n' "$br"
    ;;

  # ---------------------------------------------------------------- heavy  (#)
  heavy)
    local tl='#' tr='#' bl='#' br='#' h='#' v='#'
    printf '%s' "$tl"
    hr $((max + 2)) "$h"
    printf '%s\n' "$tr"
    if [[ -n $box_title ]]; then print_box_line "$v" "$box_title" "$v"; fi
    for line in "${LINES[@]}"; do print_box_line "$v" "$line" "$v"; done
    printf '%s' "$bl"
    hr $((max + 2)) "$h"
    printf '%s\n' "$br"
    ;;

  # ---------------------------------------------------------------- round  (() )
  round)
    local tl='(' tr=')' bl='(' br=')' v='|'
    printf '%s' "$tl"
    hr $((max + 2)) "-"
    printf '%s\n' "$tr"
    if [[ -n $box_title ]]; then print_box_line "$v" "$box_title" "$v"; fi
    for line in "${LINES[@]}"; do print_box_line "$v" "$line" "$v"; done
    printf '%s' "$bl"
    hr $((max + 2)) "-"
    printf '%s\n' "$br"
    ;;

  # ---------------------------------------------------------------- parchment (unchanged ASCII)
  parchment)
    local head_len=$((max + 4))
    printf ' %s\n' "$(hr "$head_len" '_')"
    if [[ -n $box_title ]]; then
      printf '/\\ %-*s\\\n' "$max" "$box_title"
    else
      printf '/\\ %*s\\\n' $((max + 2)) ""
    fi
    printf '\\_| %-*s |\n' "$max" "${LINES[0]:-}"
    for ((i = 1; i < ${#LINES[@]}; i++)); do
      printf '  | %-*s |\n' "$max" "${LINES[i]}"
    done
    local u1=$((max - 2))
    ((u1 < 1)) && u1=1
    printf '  |   %s_|_.\n' "$(hr "$u1" '_')"
    printf '   \\_/%s/\n' "$(hr "$max" '_')"
    ;;

  # ---------------------------------------------------------------- simple  (*)
  simple)
    hr $((max + 4)) '*'
    printf '\n'
    if [[ -n $box_title ]]; then print_box_line '*' "$box_title" '*'; fi
    for line in "${LINES[@]}"; do print_box_line '*' "$line" '*'; done
    hr $((max + 4)) '*'
    printf '\n'
    ;;

  # ---------------------------------------------------------------- shell (#)
  shell)
    hr $((max + 4)) '#'
    printf '\n'
    if [[ -n $box_title ]]; then print_box_line '#' "$box_title" '#'; fi
    for line in "${LINES[@]}"; do print_box_line '#' "$line" '#'; done
    hr $((max + 4)) '#'
    printf '\n'
    ;;

  # ---------------------------------------------------------------- html
  html)
    local border="<!-- $(hr "$max" '-') -->"
    printf '%s\n' "$border"
    if [[ -n $box_title ]]; then printf '<!-- %-*s -->\n' "$max" "$box_title"; fi
    for line in "${LINES[@]}"; do printf '<!-- %-*s -->\n' "$max" "$line"; done
    printf '%s\n' "$border"
    ;;

  # ---------------------------------------------------------------- comment /* */
  comment)
    printf '/* %s */\n' "$(hr "$max" '*')"
    if [[ -n $box_title ]]; then printf ' * %-*s *\n' "$max" "$box_title"; fi
    for line in "${LINES[@]}"; do printf ' * %-*s *\n' "$max" "$line"; done
    printf '/* %s */\n' "$(hr "$max" '*')"
    ;;

  # ---------------------------------------------------------------- php  <? ---- ?>
  php)
    printf '<?%s?>\n' "$(hr "$max" '-')"
    if [[ -n $box_title ]]; then printf '| %-*s |\n' "$max" "$box_title"; fi
    for line in "${LINES[@]}"; do printf '| %-*s |\n' "$max" "$line"; done
    printf '<?%s?>\n' "$(hr "$max" '-')"
    ;;

  # ---------------------------------------------------------------- plus (legacy ASCII single-line)
  plus)
    local tl='+' tr='+' bl='+' br='+' h='-' v='|'
    printf '%s' "$tl"
    hr $((max + 2)) "$h"
    printf '%s\n' "$tr"
    if [[ -n $box_title ]]; then print_box_line "$v" "$box_title" "$v"; fi
    for line in "${LINES[@]}"; do print_box_line "$v" "$line" "$v"; done
    printf '%s' "$bl"
    hr $((max + 2)) "$h"
    printf '%s\n' "$br"
    ;;

  # ---------------------------------------------------------------- chain  (<><><> …)
  chain)
    local border=""
    local target_len=$((max + 6))
    while ((${#border} < target_len)); do
      border+='<>'
    done
    border=${border:0:target_len}
    printf '%s\n' "${border}"
    if [[ -n $box_title ]]; then print_box_line '<>' "$box_title" '<>'; fi
    for line in "${LINES[@]}"; do
      print_box_line '<>' "$line" '<>'
    done
    printf '%s\n' "${border}"
    ;;

  # ---------------------------------------------------------------- unknown
  *)
    echo "Unknown box style: $style" >&2
    exit 1
    ;;
  esac
}

# ----------------------- animation helpers ------------------------
frames() { $AWK -v d="$duration" -v s="$speed" 'BEGIN{printf "%d", d*s}'; }
sleeper() { $AWK -v s="$speed" 'BEGIN{printf "%.5f", 1/s}'; }

animate_classic() {
  tput civis || true
  trap 'tput cnorm 2>/dev/null || true; exit' INT TERM
  mapfile -t L
  local n=${#L[@]} tot sl
  tot=$(frames)
  sl=$(sleeper)
  for ((f = 0; f < tot; f++)); do
    printf '%s\n' "${L[@]}" | colour_block
    printf '\033[%dA' "$n"
    sleep "$sl"
  done
  printf '\033[%dB' "$n"
  tput cnorm || true
}

animate_line() {
  tput civis || true
  trap 'tput cnorm 2>/dev/null || true; exit' INT TERM
  mapfile -t L
  local n=${#L[@]} sl
  if ((duration > 0)); then
    sl=$($AWK -v d="$duration" -v n="$n" 'BEGIN{printf "%.5f", d/n}')
  else
    sl=$(sleeper)
  fi
  for ((i = 0; i < n; i++)); do
    printf '%s\n' "${L[i]}" | colour_block
    sleep "$sl"
  done
  tput cnorm || true
}

# ---------------- sample-theme preview ---------------------------
if [[ -n $sample_theme ]]; then
  printf 'Sample for theme "%s"\n' "$sample_theme" | colour_block
  exit 0
fi

# --------------------- ASCII-image import (ANSI as-is) ------------
if [[ -n $ascii_image ]]; then
  if command -v chafa >/dev/null 2>&1; then
    chafa \
      --size="${TERM_WIDTH}x${TERM_HEIGHT}" \
      --format=ansi \
      --symbols=block \
      "$ascii_image"
  elif command -v jp2a >/dev/null 2>&1; then
    jp2a \
      --width="$TERM_WIDTH" \
      --height="$TERM_HEIGHT" \
      --colors \
      --output=- \
      "$ascii_image"
  elif command -v img2txt >/dev/null 2>&1; then
    img2txt \
      -W "$TERM_WIDTH" \
      -H "$TERM_HEIGHT" \
      -f ansi \
      "$ascii_image"
  else
    echo "Error: No image renderer found (img2txt, jp2a or chafa)." >&2
    exit 1
  fi
  exit 0
fi

# ----------------------- header helper ----------------------------
if [[ -n $header_text ]]; then
  if command -v figlet >/dev/null 2>&1; then
    header_payload=$(figlet "$header_text" 2>/dev/null || printf '%s\n' "$header_text")
  else
    header_payload=$header_text
  fi

  if [[ $build_box == true ]]; then
    content=$(printf '%s\n' "$header_payload" | box_draw)
  else
    content=$header_payload
  fi

  if [[ $no_color == true ]]; then
    printf '%s\n' "$content"
  else
    case $animation_style in
    classic) printf '%s\n' "$content" | animate_classic ;;
    line) printf '%s\n' "$content" | animate_line ;;
    *) printf '%s\n' "$content" | colour_block ;;
    esac
  fi
  exit 0
fi

# ---------------------------- main loop ---------------------------
[[ ${#files[@]} -eq 0 ]] && files=("-")

for f in "${files[@]}"; do
  if [[ $f == "-" ]]; then
    src="/dev/stdin"
  else
    src="$f"
  fi

  if [[ $build_box == true ]]; then
    producer_cmd=box_draw
  else
    producer_cmd=cat
  fi

  if [[ $no_color == true ]]; then
    "$producer_cmd" <"$src"
  else
    case $animation_style in
    classic) "$producer_cmd" <"$src" | animate_classic ;;
    line) "$producer_cmd" <"$src" | animate_line ;;
    *) "$producer_cmd" <"$src" | colour_block ;;
    esac
  fi
done
