#!/usr/bin/env bash
set -euo pipefail
VERSION="1.2"

# ---------------------------- defaults ----------------------------
spread=3.0  freq=0.1  seed=0
animation_style=none        # none | classic | line
duration=1  speed=5.0
invert=false want_truecolor=false force=false
build_box=false   box_style="default"
orientation="h"                           # h|v|d
palette_file=""
ascii_image="" blink=false image_opacity=100

# New features
mode="char"                               # char|line  (--per-line)
match_regex="" only_match=false strip_ansi=false
log_mode=false stream_mode=false
box_title="" box_center=false box_pad=0
header_text=""
list_themes=false sample_theme="" random_theme=false
do_self_update=false
no_color=false

THEMES=()
files=()

# ---------------------------- terminal dimensions ----------------------------
TERM_WIDTH=$(tput cols 2>/dev/null || echo 80)
TERM_HEIGHT=$(tput lines 2>/dev/null || echo 24)
(( TERM_HEIGHT -= 4 )) || true
(( TERM_WIDTH  > 160 )) && TERM_WIDTH=160
(( TERM_HEIGHT >  60 )) && TERM_HEIGHT=60

# --------------------------- helpers ------------------------------
require() { command -v "$1" >/dev/null 2>&1 || { printf 'Error: %s required\n' "$1" >&2; exit 1; }; }

usage() {
  cat <<EOF
chromacat $VERSION – colourful text printer

USAGE
  $(basename "$0") [OPTIONS] [FILE]...

COLOUR / ANIMATION
  -p, --spread <f>         Rainbow spread (default $spread)
  -F, --freq   <f>         Rainbow frequency (default $freq)
  -S, --seed   <n>         Seed (0=random)
  -a, --animate            Classic scrolling animation
  -aa, --line              Line-by-line reveal animation
      --style <name>       Animation style (classic|line|none)
      --per-line           One colour per line (faster/log-friendly)
  -d, --duration <sec>     Animation seconds (default $duration)
  -s, --speed <fps>        Frames / second (default $speed)
  -m, --match <regex>      Colour only matching text
      --only-match         Hide non-matching characters
      --strip-ansi         Strip ANSI before colouring
      --log                Preset (no animation + per-line)
      --stream             Disable animations for streaming input

APPEARANCE
  -i, --invert             Invert foreground / background
  -t, --truecolor          Prefer 24-bit colour if supported
  -f, --force              Colour even if stdout not a TTY
      --no-color           Disable colouring (also respects NO_COLOR)
  -b, --box                Draw ASCII box
  -B, --box-style <name>   default|dashed|dash2|round|double|heavy|parchment|simple|shell|html|plus|comment|php|chain
      --title <text>       Box title line
      --center             Center-align box content
      --pad <n>            Padding inside box (default 0)
  -O, --orientation <o>    Gradient orientation: h|v|d (or horizontal|vertical|diagonal)
  -P, --palette <file>     Palette file (HEX per line)
  -T, --theme <name(s)>    Themes (comma list)
      --list-themes        List themes and exit
      --sample-theme <n>   Print theme sample and exit
      --random-theme       Pick random theme
  -I, --image <file>       ASCII-art mode via img2txt/jp2a/chafa
      --blink              Blinking text
      --image-opacity <n>  Image brightness (0–100, default $image_opacity)

MISC
  -H, --header <text>      Render banner (figlet if available)
  -U, --self-update        Fetch latest chromacat and replace current script
  -v, --version            Print version and exit
  -h, --help               Show this help

EXAMPLES
  echo "TEST" | chromacat
  echo "TEST" | chromacat -T neon --per-line -b -B round --title "ChromaCat" --center --pad 1
EOF
}

die() { echo "Error: $*" >&2; exit 1; }

take_val() {
  # usage: take_val "$1" "$2"  -> prints value, shifts handled by caller
  # supports: --opt=value
  case "$1" in
  *=*) printf '%s' "${1#*=}" ;;
  *)   [[ -n "${2:-}" ]] || die "Missing value for $1"; printf '%s' "$2" ;;
  esac
}

self_update() {
  require curl
  local script_url="https://raw.githubusercontent.com/infocyph/Toolset/main/ChromaCat/chromacat"
  local tmp
  if ! tmp=$(mktemp /tmp/chromacat.XXXXXX 2>/dev/null); then tmp="/tmp/chromacat.$$"; fi

  local target="${CHROMACAT_PATH:-}"
  if [[ -z $target ]]; then
    if command -v chromacat >/dev/null 2>&1; then target=$(command -v chromacat); else target="$0"; fi
  fi

  echo "Checking for updates..."
  if ! curl -fsSL "$script_url" -o "$tmp"; then
    echo "Failed to download latest script." >&2
    rm -f "$tmp" || true
    return 1
  fi

  if command -v sha256sum >/dev/null 2>&1 && [[ -f "$target" ]]; then
    local rh lh
    rh="$(sha256sum "$tmp" | awk '{print $1}')"
    lh="$(sha256sum "$target" 2>/dev/null | awk '{print $1}')"
    if [[ -n $rh && "$rh" == "$lh" ]]; then
      echo "Already up-to-date."
      rm -f "$tmp" || true
      return 0
    fi
  fi

  if ! mv "$tmp" "$target" 2>/dev/null; then
    echo "Failed to overwrite $target (try sudo or CHROMACAT_PATH)." >&2
    rm -f "$tmp" || true
    return 1
  fi

  chmod +x "$target" || true
  echo "Updated."
  return 0
}

# ------------------------- option parsing (portable) -------------------------
# NOTE: no getopt dependency.
while [[ $# -gt 0 ]]; do
  case "$1" in
  --) shift; break ;;

  -v|--version) printf '%s %s\n' "$(basename "$0")" "$VERSION"; exit 0 ;;
  -h|--help) usage; exit 0 ;;

  -U|--self-update) do_self_update=true; shift ;;
  -H|--header) header_text="$(take_val "$1" "${2:-}")"; shift; [[ "$1" == *=* ]] || shift ;;
  --header=*) header_text="$(take_val "$1" "")"; shift ;;

  -p|--spread) spread="$(take_val "$1" "${2:-}")"; shift; [[ "$1" == *=* ]] || shift ;;
  --spread=*)  spread="$(take_val "$1" "")"; shift ;;
  -F|--freq)   freq="$(take_val "$1" "${2:-}")"; shift; [[ "$1" == *=* ]] || shift ;;
  --freq=*)    freq="$(take_val "$1" "")"; shift ;;
  -S|--seed)   seed="$(take_val "$1" "${2:-}")"; shift; [[ "$1" == *=* ]] || shift ;;
  --seed=*)    seed="$(take_val "$1" "")"; shift ;;

  -a|--animate) animation_style=classic; shift ;;
  -aa|--line)   animation_style=line; shift ;;
  --style)      animation_style="$(take_val "$1" "${2:-}")"; shift; [[ "$1" == *=* ]] || shift ;;
  --style=*)    animation_style="$(take_val "$1" "")"; shift ;;
  -d|--duration) duration="$(take_val "$1" "${2:-}")"; shift; [[ "$1" == *=* ]] || shift ;;
  --duration=*)  duration="$(take_val "$1" "")"; shift ;;
  -s|--speed)    speed="$(take_val "$1" "${2:-}")"; shift; [[ "$1" == *=* ]] || shift ;;
  --speed=*)     speed="$(take_val "$1" "")"; shift ;;

  --per-line) mode="line"; shift ;;
  -m|--match) match_regex="$(take_val "$1" "${2:-}")"; shift; [[ "$1" == *=* ]] || shift ;;
  --match=*)  match_regex="$(take_val "$1" "")"; shift ;;
  --only-match) only_match=true; shift ;;
  --strip-ansi) strip_ansi=true; shift ;;
  --log) log_mode=true; shift ;;
  --stream) stream_mode=true; shift ;;

  -i|--invert) invert=true; shift ;;
  -t|--truecolor) want_truecolor=true; shift ;;
  -f|--force) force=true; shift ;;
  --no-color) no_color=true; shift ;;

  -b|--box) build_box=true; shift ;;
  -B|--box-style) box_style="$(take_val "$1" "${2:-}")"; build_box=true; shift; [[ "$1" == *=* ]] || shift ;;
  --box-style=*)  box_style="$(take_val "$1" "")"; build_box=true; shift ;;
  --title) box_title="$(take_val "$1" "${2:-}")"; build_box=true; shift; [[ "$1" == *=* ]] || shift ;;
  --title=*) box_title="$(take_val "$1" "")"; build_box=true; shift ;;
  --center) box_center=true; shift ;;
  --pad) box_pad="$(take_val "$1" "${2:-}")"; build_box=true; shift; [[ "$1" == *=* ]] || shift ;;
  --pad=*) box_pad="$(take_val "$1" "")"; build_box=true; shift ;;

  -O|--orientation) orientation="$(take_val "$1" "${2:-}")"; shift; [[ "$1" == *=* ]] || shift ;;
  --orientation=*)  orientation="$(take_val "$1" "")"; shift ;;
  -P|--palette) palette_file="$(take_val "$1" "${2:-}")"; shift; [[ "$1" == *=* ]] || shift ;;
  --palette=*)  palette_file="$(take_val "$1" "")"; shift ;;
  -T|--theme)    _t="$(take_val "$1" "${2:-}")"; IFS=',' read -ra THEMES <<<"$_t"; shift; [[ "$1" == *=* ]] || shift ;;
  --theme=*)     _t="$(take_val "$1" "")"; IFS=',' read -ra THEMES <<<"$_t"; shift ;;

  --list-themes) list_themes=true; shift ;;
  --sample-theme) sample_theme="$(take_val "$1" "${2:-}")"; shift; [[ "$1" == *=* ]] || shift ;;
  --sample-theme=*) sample_theme="$(take_val "$1" "")"; shift ;;
  --random-theme) random_theme=true; shift ;;

  -I|--image) ascii_image="$(take_val "$1" "${2:-}")"; shift; [[ "$1" == *=* ]] || shift ;;
  --image=*)  ascii_image="$(take_val "$1" "")"; shift ;;
  --blink) blink=true; shift ;;
  --image-opacity) image_opacity="$(take_val "$1" "${2:-}")"; shift; [[ "$1" == *=* ]] || shift ;;
  --image-opacity=*) image_opacity="$(take_val "$1" "")"; shift ;;

  -*)
    die "Unknown option: $1"
    ;;
  *)
    files+=("$1")
    shift
    ;;
  esac
done

# remaining args after --
while [[ $# -gt 0 ]]; do files+=("$1"); shift; done

# ------------------ self-update early exit -----------------------
if [[ $do_self_update == true ]]; then
  self_update
  exit $?
fi

# ----------------------- AWK selection ---------------------------
if   command -v gawk >/dev/null 2>&1; then AWK=gawk
elif command -v mawk >/dev/null 2>&1; then AWK=mawk
elif command -v awk  >/dev/null 2>&1; then AWK=awk
else die "no awk found"
fi

# -------------- environment / sanity checks -----------------------
if [[ -n ${NO_COLOR:-} ]]; then no_color=true; fi

truecolor=false
if [[ $want_truecolor == true && ( ${COLORTERM:-} == *truecolor* || ${COLORTERM:-} == *24bit* ) ]]; then
  truecolor=true
fi

# if stdout is not tty and not forced -> disable fancy output
if [[ ! -t 1 && $force == false ]]; then
  animation_style=none
  build_box=false
  truecolor=false
fi

for v in spread freq duration speed; do
  [[ ${!v} =~ ^[0-9]+(\.[0-9]+)?$ ]] || die "Invalid $v"
done
[[ $box_pad =~ ^[0-9]+$ ]] || die "Invalid --pad"
[[ $image_opacity =~ ^[0-9]+$ ]] || die "Invalid --image-opacity"

# presets
if [[ $log_mode == true ]]; then animation_style=none; mode="line"; fi
if [[ $stream_mode == true ]]; then animation_style=none; fi
if [[ $no_color == true ]]; then animation_style=none; blink=false; invert=false; truecolor=false; fi

# list themes early
if [[ $list_themes == true ]]; then
  cat <<EOF
Available themes:
  fire
  ice
  sunset
  ocean
  rainbow
  neon
  forest
  pastel
  mono
EOF
  exit 0
fi

# sample theme / random theme tweaks
if [[ -n $sample_theme ]]; then THEMES=("$sample_theme"); fi
if [[ $random_theme == true && ${#THEMES[@]} -eq 0 && -z $palette_file ]]; then
  themes_rand=(fire ice sunset ocean rainbow neon forest pastel mono)
  THEMES=("${themes_rand[RANDOM % ${#themes_rand[@]}]}")
fi

# --------------------------- palette ------------------------------
PALETTE=""
if [[ -n $palette_file ]]; then
  mapfile -t _pal < "$palette_file" || die "Bad palette file"
  PALETTE=$(IFS=,; echo "${_pal[*]}")
elif [[ ${#THEMES[@]} -gt 0 ]]; then
  for theme in "${THEMES[@]}"; do
    case $theme in
    fire)    PALETTE+=",FF6B00,FF8C00,FFA500,FFD700";;
    ice)     PALETTE+=",00FFFF,00CED1,1E90FF,4169E1";;
    sunset)  PALETTE+=",FF4500,FF6347,FF7F50,FF8C00,FFD700";;
    ocean)   PALETTE+=",006994,008CBA,00AEEF,33CCFF";;
    rainbow) PALETTE+=",FF0000,FF7F00,FFFF00,00FF00,0000FF,4B0082,8B00FF";;
    neon)    PALETTE+=",FF00FF,00FFFF,39FF14,FFFF00,FF073A";;
    forest)  PALETTE+=",0B3D0B,1B5E20,2E7D32,66BB6A,A5D6A7";;
    pastel)  PALETTE+=",FFB3BA,FFDFBA,FFFFBA,BAFFC9,BAE1FF,CCBAFF";;
    mono)    PALETTE+=",E0E0E0,B0B0B0,808080,505050,202020";;
    *) echo "Unknown theme: $theme" >&2 ;;
    esac
  done
  PALETTE="${PALETTE#,}"
fi

get_seed() { (( seed > 0 )) && echo "$seed" || echo "$RANDOM"; }

case $orientation in
horizontal) orientation="h";;
vertical)   orientation="v";;
diagonal)   orientation="d";;
esac

# ---------------------- colouriser (portable AWK) -----------------
colour_block() {
  $AWK -v spread="$spread" -v blink="$blink" -v freq="$freq" -v seed="$(get_seed)" \
    -v tc="$truecolor" -v palette="$PALETTE" -v orient="$orientation" \
    -v invert="$invert" -v mode="$mode" -v match_regex="$match_regex" \
    -v only_match="$only_match" -v strip_ansi="$strip_ansi" '
  BEGIN {
    pi=3.1415926536;
    if (palette!="") pc=split(palette,p,","); else pc=0;
    has_match = (match_regex != "") ? 1 : 0;
  }
  function rgb(r,g,b){
    return (tc=="true")?
      sprintf("38;2;%d;%d;%d",r,g,b):
      sprintf("38;5;%d",16+int(r*6/256)*36+int(g*6/256)*6+int(b*6/256))
  }
  function blink_on()  { return "\033[5m" }
  function blink_off() { return "\033[25m" }
  function pal(i){ return p[(i%pc)+1] }
  function hex2dec(h,   n,v,i,d) {
    n = length(h);
    v = 0;
    for(i=1;i<=n;i++) {
      d = substr(h,i,1);
      v = v * 16 + index("0123456789abcdef", tolower(d)) - 1;
    }
    return v;
  }
  function rainbow(i,r,g,b,col){
    if(pc){
      col=pal(i)
    } else {
      r=sin(freq*i)*127+128;
      g=sin(freq*i+2*pi/3)*127+128;
      b=sin(freq*i+4*pi/3)*127+128;
      col=sprintf("%02X%02X%02X",r,g,b)
    }
    return col
  }
  {
    line=$0;
    if (strip_ansi=="true") gsub(/\033\[[0-9;]*m/, "", line);

    split("", in_match);
    if (has_match) {
      start = 1;
      while (start <= length(line)) {
        m = match(substr(line, start), match_regex);
        if (m == 0) break;
        m = m + start - 1;
        e = m + RLENGTH - 1;
        for (k = m; k <= e; k++) in_match[k] = 1;
        start = e + 1;
      }
    }

    have_line_code=0;
    for(j=1;j<=length(line);j++){
      c=substr(line,j,1);

      if (mode=="line") {
        if (!have_line_code) {
          idx = NR + seed;
          col=rainbow(int(idx));
          r=hex2dec(substr(col,1,2)); g=hex2dec(substr(col,3,2)); b=hex2dec(substr(col,5,2));
          line_code=rgb(r,g,b);
          have_line_code=1;
        }
        code=line_code;
      } else {
        if(orient=="v") idx=NR
        else if(orient=="d") idx=NR+j/spread
        else idx=j+NR/spread
        idx+=seed
        col=rainbow(int(idx))
        r=hex2dec(substr(col,1,2)); g=hex2dec(substr(col,3,2)); b=hex2dec(substr(col,5,2));
        code=rgb(r,g,b)
      }

      if (has_match && !(j in in_match)) {
        if (only_match=="true") continue;
        printf "%s", c;
        continue;
      }

      if(invert=="true") printf "\033[7m"
      if(blink=="true") printf "%s", blink_on()
      printf "\033[%sm%s", code, c
      if(blink=="true") printf "%s", blink_off()
      if(invert=="true") printf "\033[27m"
    }
    printf "\033[0m\n"
  }'
}

safe_colour() {
  if [[ $no_color == true ]]; then cat; return 0; fi
  set +e
  colour_block
  rc=$?
  set -e
  if (( rc != 0 )); then cat; fi
  return 0
}

# --------------------------- box drawer ---------------------------
box_draw() {
  local style=$box_style
  mapfile -t LINES

  # horizontal padding (applies to both content and title)
  local ps=""
  if (( box_pad > 0 )); then
    ps=$(printf '%*s' "$box_pad" "")
    for i in "${!LINES[@]}"; do
      LINES[$i]="${ps}${LINES[$i]}${ps}"
    done
    if [[ -n ${box_title:-} ]]; then
      box_title="${ps}${box_title}${ps}"
    fi
  fi

  # compute max width INCLUDING title
  local max=0 line
  for line in "${LINES[@]}"; do
    (( ${#line} > max )) && max=${#line}
  done
  if [[ -n ${box_title:-} && ${#box_title} -gt max ]]; then
    max=${#box_title}
  fi

  # helpers
  hr() { printf '%*s' "$1" | tr ' ' "$2"; }

  # vertical padding: add blank lines that match max
  if (( box_pad > 0 )); then
    local blank
    blank=$(printf '%*s' "$max" "")
    for ((i=0; i<box_pad; i++)); do
      LINES=("$blank" "${LINES[@]}" "$blank")
    done
  fi

  print_box_line() {
    local left=$1 text=$2 right=$3
    if [[ $box_center == true ]]; then
      local len=${#text}
      if (( len < max )); then
        local pl=$(((max - len) / 2))
        local pr=$((max - len - pl))
        printf '%s ' "$left"
        printf '%*s%s%*s' "$pl" "" "$text" "$pr" ""
        printf ' %s\n' "$right"
      else
        printf '%s %-*s %s\n' "$left" "$max" "$text" "$right"
      fi
    else
      printf '%s %-*s %s\n' "$left" "$max" "$text" "$right"
    fi
  }

  case $style in
  default)
    local tl='+' tr='+' bl='+' br='+' h='-' v='|'
    printf '%s' "$tl"; hr $((max+2)) "$h"; printf '%s\n' "$tr"
    [[ -n ${box_title:-} ]] && print_box_line "$v" "$box_title" "$v"
    for line in "${LINES[@]}"; do print_box_line "$v" "$line" "$v"; done
    printf '%s' "$bl"; hr $((max+2)) "$h"; printf '%s\n' "$br"
    ;;
  dashed)
    local tl='+' tr='+' bl='+' br='+' v='|'
    local dash_line=""
    for ((i=0;i<max+2;i++)); do dash_line+=$([[ $((i%2)) == 0 ]] && echo '-' || echo ' '); done
    printf '%s%s%s\n' "$tl" "$dash_line" "$tr"
    [[ -n ${box_title:-} ]] && print_box_line "$v" "$box_title" "$v"
    for line in "${LINES[@]}"; do print_box_line "$v" "$line" "$v"; done
    printf '%s%s%s\n' "$bl" "$dash_line" "$br"
    ;;
  dash2)
    local border; border=$(hr $((max+6)) '-')
    printf '%s\n' "$border"
    [[ -n ${box_title:-} ]] && printf -- "-- %-*s --\n" "$max" "$box_title"
    for line in "${LINES[@]}"; do printf -- "-- %-*s --\n" "$max" "$line"; done
    printf '%s\n' "$border"
    ;;
  double)
    local tl='+' tr='+' bl='+' br='+' h='=' v='|'
    printf '%s' "$tl"; hr $((max+2)) "$h"; printf '%s\n' "$tr"
    [[ -n ${box_title:-} ]] && print_box_line "$v" "$box_title" "$v"
    for line in "${LINES[@]}"; do print_box_line "$v" "$line" "$v"; done
    printf '%s' "$bl"; hr $((max+2)) "$h"; printf '%s\n' "$br"
    ;;
  heavy)
    local tl='#' tr='#' bl='#' br='#' h='#' v='#'
    printf '%s' "$tl"; hr $((max+2)) "$h"; printf '%s\n' "$tr"
    [[ -n ${box_title:-} ]] && print_box_line "$v" "$box_title" "$v"
    for line in "${LINES[@]}"; do print_box_line "$v" "$line" "$v"; done
    printf '%s' "$bl"; hr $((max+2)) "$h"; printf '%s\n' "$br"
    ;;
  round)
    local tl='(' tr=')' bl='(' br=')' h='-' v='|'
    printf '%s' "$tl"; hr $((max+2)) "$h"; printf '%s\n' "$tr"
    [[ -n ${box_title:-} ]] && print_box_line "$v" "$box_title" "$v"
    for line in "${LINES[@]}"; do print_box_line "$v" "$line" "$v"; done
    printf '%s' "$bl"; hr $((max+2)) "$h"; printf '%s\n' "$br"
    ;;
  parchment)
    local head_len=$((max + 4))
    printf ' %s\n' "$(hr "$head_len" '_')"
    if [[ -n ${box_title:-} ]]; then
      printf '/\\ %-*s\\\n' "$max" "$box_title"
    else
      printf '/\\ %*s\\\n' $((max + 2)) ""
    fi
    printf '\\_| %-*s |\n' "$max" "${LINES[0]:-}"
    for ((i = 1; i < ${#LINES[@]}; i++)); do
      printf '  | %-*s |\n' "$max" "${LINES[i]}"
    done
    local u1=$((max - 2)); ((u1<1)) && u1=1
    printf '  |   %s_|_.\n' "$(hr "$u1" '_')"
    printf '   \\_/%s/\n' "$(hr "$max" '_')"
    ;;
  simple)
    hr $((max+4)) '*'; printf '\n'
    [[ -n ${box_title:-} ]] && print_box_line '*' "$box_title" '*'
    for line in "${LINES[@]}"; do print_box_line '*' "$line" '*'; done
    hr $((max+4)) '*'; printf '\n'
    ;;
  shell)
    hr $((max+4)) '#'; printf '\n'
    [[ -n ${box_title:-} ]] && print_box_line '#' "$box_title" '#'
    for line in "${LINES[@]}"; do print_box_line '#' "$line" '#'; done
    hr $((max+4)) '#'; printf '\n'
    ;;
  html)
    local border="<!-- $(hr "$max" '-') -->"
    printf '%s\n' "$border"
    [[ -n ${box_title:-} ]] && printf '<!-- %-*s -->\n' "$max" "$box_title"
    for line in "${LINES[@]}"; do printf '<!-- %-*s -->\n' "$max" "$line"; done
    printf '%s\n' "$border"
    ;;
  comment)
    printf '/* %s */\n' "$(hr "$max" '*')"
    [[ -n ${box_title:-} ]] && printf ' * %-*s *\n' "$max" "$box_title"
    for line in "${LINES[@]}"; do printf ' * %-*s *\n' "$max" "$line"; done
    printf '/* %s */\n' "$(hr "$max" '*')"
    ;;
  php)
    printf '<?%s?>\n' "$(hr "$max" '-')"
    [[ -n ${box_title:-} ]] && printf '| %-*s |\n' "$max" "$box_title"
    for line in "${LINES[@]}"; do printf '| %-*s |\n' "$max" "$line"; done
    printf '<?%s?>\n' "$(hr "$max" '-')"
    ;;
  plus)
    local tl='+' tr='+' bl='+' br='+' h='-' v='|'
    printf '%s' "$tl"; hr $((max+2)) "$h"; printf '%s\n' "$tr"
    [[ -n ${box_title:-} ]] && print_box_line "$v" "$box_title" "$v"
    for line in "${LINES[@]}"; do print_box_line "$v" "$line" "$v"; done
    printf '%s' "$bl"; hr $((max+2)) "$h"; printf '%s\n' "$br"
    ;;
  chain)
    local border="" target_len=$((max + 6))
    while (( ${#border} < target_len )); do border+='<>'; done
    border=${border:0:target_len}
    printf '%s\n' "${border}"
    [[ -n ${box_title:-} ]] && print_box_line '<>' "$box_title" '<>'
    for line in "${LINES[@]}"; do print_box_line '<>' "$line" '<>'; done
    printf '%s\n' "${border}"
    ;;
  *) echo "Unknown box style: $style" >&2; exit 1 ;;
  esac
}

# ----------------------- animation helpers ------------------------
frames()  { $AWK -v d="$duration" -v s="$speed" 'BEGIN{printf "%d", d*s}'; }
sleeper() { $AWK -v s="$speed"            'BEGIN{printf "%.5f", 1/s}'; }

animate_classic() {
  tput civis 2>/dev/null || true
  trap 'tput cnorm 2>/dev/null || true; exit' INT TERM
  mapfile -t L; local n=${#L[@]}; local tot; tot=$(frames); local sl; sl=$(sleeper)
  for ((f=0; f<tot; f++)); do
    printf '%s\n' "${L[@]}" | safe_colour
    (( n > 0 )) && printf '\033[%dA' "$n"
    sleep "$sl"
  done
  (( n > 0 )) && printf '\033[%dB' "$n"
  tput cnorm 2>/dev/null || true
}

animate_line() {
  tput civis 2>/dev/null || true
  trap 'tput cnorm 2>/dev/null || true; exit' INT TERM
  mapfile -t L; local n=${#L[@]}; local sl
  if (( duration > 0 && n > 0 )); then sl=$(awk -v d="$duration" -v n="$n" 'BEGIN{printf "%.5f", d/n}')
  else sl=$(sleeper); fi
  for ((i=0; i<n; i++)); do printf '%s\n' "${L[i]}" | safe_colour; sleep "$sl"; done
  tput cnorm 2>/dev/null || true
}

# ---------------- sample-theme preview ---------------------------
if [[ -n $sample_theme ]]; then
  printf 'Sample for theme "%s"\n' "$sample_theme" | safe_colour
  exit 0
fi

# ----------------------- header helper ----------------------------
if [[ -n $header_text ]]; then
  if command -v figlet >/dev/null 2>&1; then
    header_payload=$(figlet "$header_text" 2>/dev/null || printf '%s\n' "$header_text")
  else
    header_payload=$header_text
  fi
  $build_box && header_payload=$(printf '%s\n' "$header_payload" | box_draw)

  if [[ $no_color == true ]]; then
    printf '%s\n' "$header_payload"
  else
    case $animation_style in
    classic) printf '%s\n' "$header_payload" | animate_classic ;;
    line)    printf '%s\n' "$header_payload" | animate_line ;;
    *)       printf '%s\n' "$header_payload" | safe_colour ;;
    esac
  fi
  exit 0
fi

# --------------------- ASCII-image import (ANSI as-is) -------------------------
TERM_WIDTH=$(tput cols 2>/dev/null || echo "$TERM_WIDTH")
TERM_HEIGHT=$(tput lines 2>/dev/null || echo "$TERM_HEIGHT")

if [[ -n $ascii_image ]]; then
  if command -v chafa >/dev/null 2>&1; then
    ascii_payload=$(chafa --size="${TERM_WIDTH}x${TERM_HEIGHT}" --format=ansi --symbols=block "$ascii_image")
  elif command -v jp2a >/dev/null 2>&1; then
    ascii_payload=$(jp2a --width="$TERM_WIDTH" --height="$TERM_HEIGHT" --colors --output=- "$ascii_image")
  elif command -v img2txt >/dev/null 2>&1; then
    ascii_payload=$(img2txt -W "$TERM_WIDTH" -H "$TERM_HEIGHT" -f ansi "$ascii_image")
  else
    die "No image renderer found (img2txt, jp2a or chafa)."
  fi
  files=("-")
fi

# defaults: read stdin
[[ ${#files[@]} -eq 0 ]] && files=("-")

# ---------------------------- main loop ---------------------------
for f in "${files[@]}"; do
  if [[ $f == "-" ]]; then
    input=${ascii_payload:-$(cat)}
  else
    input=$(cat "$f")
  fi

  if [[ -n $ascii_image ]]; then
    printf '%s\n' "$ascii_payload"
    continue
  fi

  $build_box && input=$(printf '%s\n' "$input" | box_draw)

  if [[ $no_color == true ]]; then
    printf '%s\n' "$input"
    continue
  fi

  case $animation_style in
  classic) printf '%s\n' "$input" | animate_classic ;;
  line)    printf '%s\n' "$input" | animate_line   ;;
  *)       printf '%s\n' "$input" | safe_colour    ;;
  esac
done
