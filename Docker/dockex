#!/usr/bin/env bash
set -euo pipefail

# --------------------- dependencies --------------------- #
require_cmd() {
  command -v "$1" >/dev/null 2>&1 || {
    echo "Error: Required command '$1' not found in PATH." >&2
    exit 1
  }
}

require_cmd docker
require_cmd jq
require_cmd awk

# ---------------------- usage --------------------------- #
show_usage() {
  echo "Usage: dockex <command> [container_name] [options]"
  echo
  echo "Available commands:"
  echo "  info|inspect <container>          - Detailed container info:"
  echo "      * IP/hostname/OS/command"
  echo "      * Networks (name/driver/subnet/gateway/IP)"
  echo "      * CPU shares, memory limit"
  echo "      * Volumes, env vars, ports, DNS (if running)"
  echo
  echo "  ps [name_pattern]                 - Summarize all containers (CPU/MEM/health/restart)."
  echo
  echo "  logs <container> [lines]          - Show container logs (default: 10 lines)."
  echo "  logs-errors <container> [lines]   - Show only error-like log lines (default: 500)."
  echo "  stream_logs <container>           - Stream container logs in real-time."
  echo
  echo "  start <container>                 - Start a stopped container."
  echo "  stop <container>                  - Stop a running container."
  echo "  restart <container>               - Restart a container."
  echo
  echo "  shell <container>                 - Exec into a container (bash, fallback sh)."
  echo "  exec-run <container> <cmd...>     - Run a one-off command inside a container."
  echo "  top <container>                   - Show processes running inside container."
  echo
  echo "  update_resources <container>      - Update container's CPU and memory limits."
  echo
  echo "  backup <container>                - Backup a selected volume to a zip file."
  echo "  restore <container> <zip>         - Restore container data from a backup zip."
  echo
  echo "  ports <container>                 - Show published ports for a container."
  echo "  dns <container> [hostname]        - Show DNS config / resolve a name inside container."
  echo
  echo "  benchmark <container> [instances] [requests] [concurrency]"
  echo "      * instances:   default 3"
  echo "      * requests:    default 100"
  echo "      * concurrency: default 10"
  echo
  echo "  stats <container> [duration] [interval]"
  echo "      * duration:    seconds to profile (default: 30)"
  echo "      * interval:    seconds between samples (default: 2)"
  echo
  echo "  trace <container> <host-or-url> [port]"
  echo "      * Run reachability / HTTP probe from inside container."
  echo "      * If URL: infer host/port/protocol."
  echo "      * If host + port: build http/https URL (443 => https)."
  echo
  echo "  doctor [container]                - Doctor check for Docker host or a container."
  echo "      * No container: host + fleet health summary"
  echo "      * With container: deep health/logs/limits snapshot"
  echo
  echo "  list                              - Show images, containers, networks, volumes."
  echo "  nets                              - Show Docker network topology (subnet / containers)."
  echo "  create <image> [name]             - Interactively create a new container."
  echo
  echo "  cleanup [unused|aggressive|all]   - Clean up Docker resources (default: unused)."
  echo "      unused:       Safe cleanup of unused resources."
  echo "      aggressive:   Remove all unused resources, including unreferenced images."
  echo "      all:          Remove ALL containers/images/volumes/networks (destructive)."
  echo
  echo "Examples:"
  echo "  dockex info my_container"
  echo "  dockex ps"
  echo "  dockex logs my_container 50"
  echo "  dockex logs-errors my_container 1000"
  echo "  dockex benchmark my_container 5 500 50"
  echo "  dockex stats my_container 60 5"
  echo "  dockex trace my_container api.example.com 443"
  echo "  dockex dns my_container example.com"
  echo "  dockex ports my_container"
  echo "  dockex nets"
  echo "  dockex doctor my_container"
  echo "  dockex backup my_container"
  echo "  dockex create nginx my_nginx"
  echo "  dockex shell my_container"
}

# ------------------ container helpers ------------------- #

# Check if the container exists and (optionally) is running
validate_container() {
  local container_name=$1
  local requirement=${2:-any} # any|running

  if ! docker ps -a --format '{{.Names}}' | grep -wq "$container_name"; then
    echo "Error: Container '$container_name' doesn't exist."
    exit 1
  fi

  if [ "$requirement" = "running" ] &&
    ! docker ps --format '{{.Names}}' | grep -wq "$container_name"; then
    echo "Error: Container '$container_name' is not running."
    exit 1
  fi
}

is_container_running() {
  local container_name=$1
  docker ps --format '{{.Names}}' | grep -wq "$container_name"
}

# Display container information
view_container_info() {
  local container_name=$1

  validate_container "$container_name" "any"

  local inspect
  inspect=$(docker inspect "$container_name")

  # -------- basic fields -------- #
  local container_id container_image container_created container_state
  local container_health container_hostname container_command container_os

  container_id=$(echo "$inspect" | jq -r '.[0].Id')
  container_image=$(echo "$inspect" | jq -r '.[0].Config.Image')
  container_created=$(echo "$inspect" | jq -r '.[0].Created')
  container_state=$(echo "$inspect" | jq -r '.[0].State.Status')
  container_health=$(echo "$inspect" | jq -r '.[0].State.Health.Status // "No Healthcheck"')
  container_hostname=$(echo "$inspect" | jq -r '.[0].Config.Hostname')
  container_command=$(echo "$inspect" | jq -r '.[0].Config.Cmd[]?' | paste -sd' ' -)
  container_os=$(echo "$inspect" | jq -r '.[0].Os')

  # IPs across all networks
  local container_ips
  container_ips=$(echo "$inspect" | jq -r '.[0].NetworkSettings.Networks[]?.IPAddress' 2>/dev/null | paste -sd',' -)

  # Networks summary
  local networks_list primary_net
  networks_list=$(echo "$inspect" | jq -r '.[0].NetworkSettings.Networks | keys[]?' 2>/dev/null | paste -sd',' -)
  primary_net=$(echo "$inspect" | jq -r '.[0].NetworkSettings.Networks | keys[0] // empty' 2>/dev/null)

  # Primary subnet/gateway via docker network inspect (if possible)
  local primary_subnet="N/A" primary_gateway="N/A"
  if [ -n "$primary_net" ]; then
    local net_info
    net_info=$(docker network inspect "$primary_net" 2>/dev/null || echo "")
    if [ -n "$net_info" ]; then
      primary_subnet=$(echo "$net_info" | jq -r '.[0].IPAM.Config[0].Subnet // "N/A"' 2>/dev/null || echo "N/A")
      primary_gateway=$(echo "$net_info" | jq -r '.[0].IPAM.Config[0].Gateway // "N/A"' 2>/dev/null || echo "N/A")
    fi
  fi

  # CPU / memory limits
  local cpu_shares raw_mem memory_limit
  cpu_shares=$(echo "$inspect" | jq -r '.[0].HostConfig.CpuShares')
  raw_mem=$(echo "$inspect" | jq -r '.[0].HostConfig.Memory')
  if [ "$raw_mem" -eq 0 ] 2>/dev/null; then
    memory_limit="Unlimited"
  else
    memory_limit="$(awk "BEGIN {print $raw_mem/1024/1024}") MB"
  fi

  # Env + mounts
  local container_env container_mounts
  container_env=$(echo "$inspect" | jq -r '.[0].Config.Env[]?' 2>/dev/null || true)
  container_mounts=$(echo "$inspect" | jq -r '.[0].Mounts[]? | "\(.Source) -> \(.Destination)"' 2>/dev/null || true)

  echo "=== Detailed Information for Container '$container_name' ==="
  echo "Container ID:        $container_id"
  echo "Image:               $container_image"
  echo "Created:             $container_created"
  echo "State:               $container_state"
  echo "Health:              $container_health"
  echo "OS:                  $container_os"
  echo "Hostname:            $container_hostname"
  echo "Command:             ${container_command:-N/A}"
  echo "IP Address(es):      ${container_ips:-N/A}"
  echo "Networks:            ${networks_list:-N/A}"
  echo "Primary Subnet:      $primary_subnet"
  echo "Primary Gateway:     $primary_gateway"
  echo
  echo "=== CPU and Memory ==="
  echo "CPU Shares:          ${cpu_shares:-Not Set}"
  echo "Memory Limit:        $memory_limit"
  echo

  # -------- network table (per network) -------- #
  echo "=== Network Details ==="
  local nets
  nets=$(echo "$inspect" | jq -r '.[0].NetworkSettings.Networks | keys[]?' 2>/dev/null || true)

  if [ -z "${nets:-}" ]; then
    echo "No networks attached."
  else
    printf '%-18s %-10s %-18s %-18s %-15s\n' \
      "NAME" "DRIVER" "SUBNET" "GATEWAY" "CONTAINER_IP"

    local net
    for net in $nets; do
      [ -z "$net" ] && continue

      local net_info driver subnet gw ip
      net_info=$(docker network inspect "$net" 2>/dev/null || echo "")
      if [ -n "$net_info" ]; then
        driver=$(echo "$net_info" | jq -r '.[0].Driver // "unknown"' 2>/dev/null || echo "unknown")
        subnet=$(echo "$net_info" | jq -r '.[0].IPAM.Config[0].Subnet // "N/A"' 2>/dev/null || echo "N/A")
        gw=$(echo "$net_info" | jq -r '.[0].IPAM.Config[0].Gateway // "N/A"' 2>/dev/null || echo "N/A")
      else
        driver="unknown"
        subnet="N/A"
        gw="N/A"
      fi

      ip=$(echo "$inspect" | jq -r --arg NET "$net" '.[0].NetworkSettings.Networks[$NET].IPAddress // "N/A"' 2>/dev/null || echo "N/A")

      printf '%-18s %-10s %-18s %-18s %-15s\n' \
        "$net" "$driver" "$subnet" "$gw" "$ip"
    done
  fi
  echo

  # -------- ports (published) -------- #
  echo "=== Ports (published) ==="
  local ports
  ports=$(echo "$inspect" | jq -r '.[0].NetworkSettings.Ports // {} | to_entries[]? |
    "\(.key)\t\((.value // []) | if length>0 then map(.HostIp + \":\" + .HostPort) | join(",") else "-" end)"' 2>/dev/null || true)

  if [ -z "${ports:-}" ]; then
    echo "No published ports."
  else
    printf '%-18s %-30s\n' "CONTAINER_PORT" "HOST_BINDINGS"
    while IFS=$'\t' read -r cport hbind; do
      [ -z "${cport:-}" ] && continue
      printf '%-18s %-30s\n' "$cport" "$hbind"
    done <<<"$ports"
  fi
  echo

  # -------- DNS -------- #
  echo "=== DNS (HostConfig) ==="
  local dns_servers dns_search dns_opts
  dns_servers=$(echo "$inspect" | jq -r '.[0].HostConfig.Dns[]?' 2>/dev/null | paste -sd',' -)
  dns_search=$(echo "$inspect" | jq -r '.[0].HostConfig.DnsSearch[]?' 2>/dev/null | paste -sd',' -)
  dns_opts=$(echo "$inspect" | jq -r '.[0].HostConfig.DnsOptions[]?' 2>/dev/null | paste -sd',' -)

  echo "DNS Servers:         ${dns_servers:-default}"
  echo "DNS Search:          ${dns_search:--}"
  echo "DNS Options:         ${dns_opts:--}"
  echo

  # -------- connected containers -------- #
  echo "=== Connected Containers (Links) ==="
  local links
  links=$(echo "$inspect" | jq -r '.[0].NetworkSettings.Networks | to_entries[]? | .value.Links[]?' 2>/dev/null | sort -u | paste -sd',' -)
  if [ -z "${links:-}" ]; then
    echo "No explicit links."
  else
    echo "$links"
  fi
  echo

  # -------- env + mounts -------- #
  echo "=== Environment Variables ==="
  if [ -n "${container_env:-}" ]; then
    echo "$container_env"
  else
    echo "No environment variables."
  fi
  echo

  echo "=== Mounted Volumes ==="
  if [ -n "${container_mounts:-}" ]; then
    echo "$container_mounts"
  else
    echo "No volumes mounted."
  fi
}

# Show logs
view_logs() {
  local container_name=$1
  local lines=${2:-10} # Default to showing last 10 lines

  validate_container "$container_name" "any"
  docker logs --tail "$lines" "$container_name"
}

# Error-focused logs
logs_errors() {
  local container_name=$1
  local lines=${2:-500}

  validate_container "$container_name" "any"

  local tmp
  tmp=$(mktemp)
  docker logs --tail "$lines" "$container_name" >"$tmp" 2>&1 || true

  echo "=== Error-like log lines for '$container_name' (last $lines lines) ==="
  local pattern='error|exception|panic|critical|failed|oom-kill'
  local matches
  matches=$(grep -Ei "$pattern" "$tmp" || true)

  if [ -z "$matches" ]; then
    echo "No error-like lines found in last $lines lines."
  else
    local count
    count=$(printf '%s\n' "$matches" | wc -l | tr -d ' ')
    echo "Found $count error-like lines:"
    echo "$matches"
  fi

  rm -f "$tmp"
}

# Start container
start_container() {
  local container_name=$1
  validate_container "$container_name" "any"
  docker start "$container_name"
  echo "Container '$container_name' started."
}

# Stop container
stop_container() {
  local container_name=$1
  validate_container "$container_name" "running"
  docker stop "$container_name"
  echo "Container '$container_name' stopped."
}

# Restart container
restart_container() {
  local container_name=$1
  validate_container "$container_name" "any"
  docker restart "$container_name"
  echo "Container '$container_name' restarted."
}

# Stream logs in real-time
stream_logs() {
  local container_name=$1
  validate_container "$container_name" "any"
  docker logs -f "$container_name"
}

# Exec into container
shell_into_container() {
  local container_name=$1
  validate_container "$container_name" "running"

  if docker exec "$container_name" bash -c 'exit 0' >/dev/null 2>&1; then
    docker exec -it "$container_name" bash
  else
    docker exec -it "$container_name" sh
  fi
}

# Exec-run convenience
exec_run() {
  local container_name=$1
  shift
  validate_container "$container_name" "running"

  if [ "$#" -eq 0 ]; then
    echo "Error: exec-run requires a command to execute."
    exit 1
  fi

  docker exec -it "$container_name" "$@"
}

# Show top inside container
top_container() {
  local container_name=$1
  validate_container "$container_name" "running"
  docker top "$container_name"
}

# Update container resources (CPU and memory limits)
update_container_resources() {
  local container_name=$1
  validate_container "$container_name" "any"

  local current_cpu_shares
  current_cpu_shares=$(docker inspect -f '{{.HostConfig.CpuShares}}' "$container_name")
  local current_mem_raw
  current_mem_raw=$(docker inspect -f '{{.HostConfig.Memory}}' "$container_name")

  local current_memory_limit
  if [ "$current_mem_raw" -eq 0 ] 2>/dev/null; then
    current_memory_limit="Unlimited"
  else
    current_memory_limit="$(awk "BEGIN {print $current_mem_raw/1024/1024}") MB"
  fi

  echo "Current CPU shares: $current_cpu_shares"
  echo "Current memory limit: $current_memory_limit"
  echo
  echo "CPU shares input:"
  echo "  - empty: keep current"
  echo "  - N:     raw shares (integer)"
  echo "  - N%:    percentage of default 1024 (e.g. 50% -> 512)"
  echo "  - Nc:    N CPU cores equivalent (e.g. 2c -> 2048)"
  echo
  echo "Enter new CPU shares:"
  read -r cpu_input
  echo "Enter new memory limit (e.g., 500m for 500MB, 1g for 1GB; empty to keep current):"
  read -r memory_limit

  local cpu_flag=()
  if [ -n "$cpu_input" ]; then
    local shares=""
    if [[ "$cpu_input" =~ %$ ]]; then
      local pct=${cpu_input%%%}
      if [[ "$pct" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
        shares=$(awk "BEGIN {printf \"%d\", 1024*$pct/100.0}")
      else
        echo "Invalid CPU percentage: $cpu_input"
        exit 1
      fi
    elif [[ "$cpu_input" =~ c$ ]]; then
      local cores=${cpu_input%c}
      if [[ "$cores" =~ ^[0-9]+$ ]]; then
        shares=$((cores * 1024))
      else
        echo "Invalid CPU core value: $cpu_input"
        exit 1
      fi
    else
      if ! [[ "$cpu_input" =~ ^[0-9]+$ ]]; then
        echo "Invalid CPU shares value: $cpu_input"
        exit 1
      fi
      shares=$cpu_input
    fi
    cpu_flag=(--cpu-shares "$shares")
  fi

  local mem_flag=()
  if [ -n "$memory_limit" ]; then
    mem_flag=(--memory "$memory_limit")
  fi

  if [ "${#cpu_flag[@]}" -eq 0 ] && [ "${#mem_flag[@]}" -eq 0 ]; then
    echo "Nothing to update."
    return
  fi

  docker update "${cpu_flag[@]}" "${mem_flag[@]}" "$container_name"
  echo "Updated resources for container '$container_name'."
}

# Backup container volume data and zip it
backup_container_data() {
  local container_name=$1

  validate_container "$container_name" "any"

  local volumes=()
  while IFS= read -r line; do
    [ -n "$line" ] && volumes+=("$line")
  done < <(docker inspect -f '{{range .Mounts}}{{.Source}} -> {{.Destination}}{{"\n"}}{{end}}' "$container_name")

  if [ ${#volumes[@]} -eq 0 ]; then
    echo "No mounted volumes found for container '$container_name'."
    exit 1
  fi

  echo "Mounted Volumes:"
  local i
  for i in "${!volumes[@]}"; do
    printf '%d) %s\n' "$((i + 1))" "${volumes[$i]}"
  done

  echo "Select a volume to backup (enter the number):"
  read -r volume_choice

  if ! [[ "$volume_choice" =~ ^[0-9]+$ ]] ||
    [ "$volume_choice" -lt 1 ] ||
    [ "$volume_choice" -gt "${#volumes[@]}" ]; then
    echo "Invalid choice."
    exit 1
  fi

  local selected_volume=${volumes[$((volume_choice - 1))]}
  local destination_volume
  destination_volume=$(echo "$selected_volume" | awk -F ' -> ' '{print $2}')

  local backup_file="${container_name}-backup-$(date +%F).zip"

  docker run --rm --volumes-from "$container_name" \
    -v "$(pwd)":/backup alpine sh -c "
      apk add --no-cache zip >/dev/null 2>&1 || true
      cd / && zip -r \"/backup/$backup_file\" \"$destination_volume\"
    "

  echo "Backup completed. Data saved to $(pwd)/$backup_file"
}

# Restore container data from backup
restore_container_data() {
  local container_name=$1
  local backup_zip_file=$2

  validate_container "$container_name" "any"

  if [ -z "${backup_zip_file:-}" ]; then
    echo "Error: Backup zip file is required."
    exit 1
  fi

  if [ ! -f "$backup_zip_file" ]; then
    echo "Error: Backup file '$backup_zip_file' not found."
    exit 1
  fi

  docker run --rm --volumes-from "$container_name" \
    -v "$(pwd)":/backup alpine sh -c "
      apk add --no-cache unzip >/dev/null 2>&1 || true
      unzip -o \"/backup/$(basename "$backup_zip_file")\" -d /
    "

  echo "Restore completed. Data restored from $backup_zip_file"
}

# ---------------- docker listings ----------------- #
show_docker_listings() {
  echo "=== Locally Available Images ==="
  docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.Size}}"

  echo
  echo "=== Running Containers ==="
  docker ps --format "table {{.Names}}\t{{.Image}}\t{{.ID}}\t{{.Status}}"

  echo
  echo "=== All Containers (including stopped) ==="
  docker ps -a --format "table {{.Names}}\t{{.Image}}\t{{.ID}}\t{{.Status}}"

  echo
  echo "=== Docker Networks ==="
  docker network ls --format "table {{.Name}}\t{{.Driver}}\t{{.ID}}"

  echo
  echo "=== Docker Volumes ==="
  docker volume ls --format "table {{.Name}}\t{{.Driver}}"
}

# --------------- docker nets topo ---------------- #
nets_topology() {
  echo "=== Docker networks topology ==="
  docker network ls --format '{{.Name}}||{{.Driver}}||{{.ID}}' | while IFS='||' read -r name driver id; do
    [ -z "${name:-}" ] && continue

    local inspect
    inspect=$(docker network inspect "$name" 2>/dev/null || echo "")

    local subnet gateway
    subnet=$(echo "$inspect" | jq -r '.[0].IPAM.Config[0].Subnet // "N/A"' 2>/dev/null || echo "N/A")
    gateway=$(echo "$inspect" | jq -r '.[0].IPAM.Config[0].Gateway // "N/A"' 2>/dev/null || echo "N/A")

    echo
    echo "Network:  $name"
    echo "Driver:   $driver"
    echo "Subnet:   $subnet"
    echo "Gateway:  $gateway"
    echo "Containers:"
    local containers
    containers=$(echo "$inspect" | jq -r '.[0].Containers | to_entries[]? | "  \(.value.Name) (\(.value.IPv4Address // ""))"' 2>/dev/null || true)
    if [ -z "$containers" ]; then
      echo "  (none)"
    else
      echo "$containers"
    fi
  done
}

# --------------- create container ----------------- #
create_new_container() {
  local image_name=$1
  local container_name=${2:-""}

  echo "=== Starting Docker Container Creation ==="

  if [ -z "$container_name" ]; then
    echo "Enter the name for the new container:"
    read -r container_name
  fi

  echo "Do you want to map any ports? (y/n)"
  read -r map_ports
  local port_mappings=""
  if [[ "$map_ports" == "y" || "$map_ports" == "Y" ]]; then
    echo "Enter port mappings in the format host_port:container_port (comma-separated for multiple ports):"
    read -r port_mappings
  fi

  echo "Do you want to add any environment variables? (y/n)"
  read -r add_env
  local env_vars=""
  if [[ "$add_env" == "y" || "$add_env" == "Y" ]]; then
    echo "Enter environment variables in the format key=value (comma-separated for multiple variables):"
    read -r env_vars
  fi

  echo "Do you want to mount any volumes? (y/n)"
  read -r map_volumes
  local volume_mappings=""
  if [[ "$map_volumes" == "y" || "$map_volumes" == "Y" ]]; then
    echo "Enter volume mappings in the format host_path:container_path (comma-separated for multiple volumes):"
    read -r volume_mappings
  fi

  echo "Do you want to connect the container to a specific Docker network? (y/n)"
  read -r connect_network
  local network_name=""
  if [[ "$connect_network" == "y" || "$connect_network" == "Y" ]]; then
    echo "Enter the Docker network name (or leave empty for default bridge network):"
    read -r network_name
  fi

  local run_command="docker run -d --name $container_name"

  if [ -n "$port_mappings" ]; then
    IFS=',' read -r -a ports <<<"$port_mappings"
    for port in "${ports[@]}"; do
      run_command="$run_command -p $port"
    done
  fi

  if [ -n "$env_vars" ]; then
    IFS=',' read -r -a envs <<<"$env_vars"
    for env in "${envs[@]}"; do
      run_command="$run_command -e $env"
    done
  fi

  if [ -n "$volume_mappings" ]; then
    IFS=',' read -r -a volumes <<<"$volume_mappings"
    for volume in "${volumes[@]}"; do
      run_command="$run_command -v $volume"
    done
  fi

  if [ -n "$network_name" ]; then
    run_command="$run_command --network $network_name"
  fi

  run_command="$run_command $image_name"

  echo "Running the following Docker command:"
  echo "$run_command"
  if $run_command; then
    echo "Container '$container_name' created successfully."
  else
    echo "Error: Failed to create the container."
  fi
}

# ---------------- benchmark ------------------------ #
benchmark() {
  local container_name=$1
  shift || true

  validate_container "$container_name" "running"

  # Defaults
  local url_override=""
  local instances=3
  local requests=100
  local concurrency=10

  # Optional: direct URL as second argument
  if [ "$#" -gt 0 ] && { [[ "$1" == http://* ]] || [[ "$1" == https://* ]]; }; then
    url_override="$1"
    shift || true
  fi

  # Optional numeric overrides: instances, requests, concurrency
  if [ "$#" -ge 1 ]; then instances=$1; fi
  if [ "$#" -ge 2 ]; then requests=$2; fi
  if [ "$#" -ge 3 ]; then concurrency=$3; fi

  # Check for host 'ab'
  local have_host_ab=0
  if command -v ab >/dev/null 2>&1; then
    have_host_ab=1
  fi

  # Base URL resolution
  local url=""
  if [ -n "$url_override" ]; then
    url="$url_override"
  else
    # Prefer 80/tcp mapping, fall back to any published port
    local host_port
    host_port=$(docker inspect -f '{{range $p, $arr := .NetworkSettings.Ports}}{{if and $arr (eq $p "80/tcp")}}{{(index $arr 0).HostPort}}{{"\n"}}{{end}}{{end}}' "$container_name" 2>/dev/null | head -n1 || true)

    if [ -z "$host_port" ]; then
      host_port=$(docker inspect -f '{{range $p, $arr := .NetworkSettings.Ports}}{{if $arr}}{{(index $arr 0).HostPort}}{{"\n"}}{{end}}{{end}}' "$container_name" 2>/dev/null | head -n1 || true)
    fi

    if [ -n "$host_port" ]; then
      # Host-side benchmark via mapped port
      url="http://127.0.0.1:${host_port}/"
    fi
  fi

  if [ -z "$url" ]; then
    if [ -z "$url_override" ]; then
      echo "Error: Could not determine benchmark URL."
      echo "Either publish a port (e.g. -p 8080:80) or pass a URL explicitly:"
      echo "  dockex benchmark $container_name http://host:port/path/ [instances] [requests] [concurrency]"
    else
      echo "Error: Invalid or empty URL '$url_override'"
    fi
    exit 1
  fi

  # Ensure trailing slash (ab requirement)
  case "$url" in
  */) ;;
  *) url="${url}/" ;;
  esac

  echo "Benchmark target: $url"
  echo "Instances: $instances, Requests: $requests, Concurrency: $concurrency"
  echo

  if [ "$have_host_ab" -eq 1 ]; then
    # ---------------- host 'ab' path ---------------- #
    echo "Using host 'ab' binary."
    echo
    echo "Running single-node benchmark..."
    ab -n "$requests" -c "$concurrency" "$url" 2>&1

    echo
    echo "Running multi-node benchmark with $instances instances..."
    local tmp_dir
    tmp_dir=$(mktemp -d)
    local i
    for i in $(seq 1 "$instances"); do
      ab -n "$requests" -c "$concurrency" "$url" >"$tmp_dir/node_$i.out" 2>&1 &
    done
    wait

    for i in $(seq 1 "$instances"); do
      echo
      echo "=== Result from benchmark_node_$i ==="
      cat "$tmp_dir/node_$i.out"
    done
    rm -rf "$tmp_dir"

  else
    # --------------- dockerized 'jordi/ab' path --------------- #
    echo "Host 'ab' not found; using Docker image 'jordi/ab'."
    echo

    local docker_url="$url"

    # If user did NOT override URL, use container's own network namespace & port
    if [ -z "$url_override" ]; then
      # Get first container port (e.g. '80/tcp')
      local cport_key cport
      cport_key=$(docker inspect -f '{{range $p, $arr := .NetworkSettings.Ports}}{{printf "%s\n" $p}}{{end}}' "$container_name" 2>/dev/null | head -n1 || true)
      if [ -z "$cport_key" ]; then
        cport=80
      else
        cport=${cport_key%%/*}
      fi
      docker_url="http://127.0.0.1:${cport}/"
      # Ensure trailing slash
      case "$docker_url" in
      */) ;;
      *) docker_url="${docker_url}/" ;;
      esac
      echo "Using container network namespace; internal URL: $docker_url"
      echo
    else
      # Respect user-provided URL; just ensure slash
      case "$docker_url" in
      */) ;;
      *) docker_url="${docker_url}/" ;;
      esac
    fi

    echo "Running single-node benchmark (dockerized ab)..."
    docker run --rm --network "container:${container_name}" \
      jordi/ab -n "$requests" -c "$concurrency" "$docker_url" 2>&1

    echo
    echo "Running multi-node benchmark with $instances instances (dockerized ab)..."
    local tmp_dir
    tmp_dir=$(mktemp -d)
    local i
    for i in $(seq 1 "$instances"); do
      docker run --rm --network "container:${container_name}" \
        jordi/ab -n "$requests" -c "$concurrency" "$docker_url" >"$tmp_dir/node_$i.out" 2>&1 &
    done
    wait

    for i in $(seq 1 "$instances"); do
      echo
      echo "=== Result from benchmark_node_$i ==="
      cat "$tmp_dir/node_$i.out"
    done
    rm -rf "$tmp_dir"
  fi

  echo
  echo "Benchmark summary:"
  echo "  Single-node: $requests requests, concurrency $concurrency."
  echo "  Multi-node:  $instances instances Ã— $requests requests, concurrency $concurrency each."
}

# ---------------- ports helper --------------------- #
ports_container() {
  local container_name=$1
  validate_container "$container_name" "any"

  local inspect
  inspect=$(docker inspect "$container_name")

  echo "=== Ports for '$container_name' ==="
  local lines
  lines=$(echo "$inspect" | jq -r '.[0].NetworkSettings.Ports | to_entries[]? | select(.value != null) | "\(.key)\t\(.value[0].HostIp)\t\(.value[0].HostPort)"' 2>/dev/null || echo "")

  if [ -z "$lines" ]; then
    echo "No published ports."
    return
  fi

  printf '%-18s %-18s %-18s\n' "CONTAINER PORT" "HOST IP" "HOST PORT"
  printf '%-18s %-18s %-18s\n' "-------------" "-------" "---------"
  while IFS=$'\t' read -r cport hip hport; do
    printf '%-18s %-18s %-18s\n' "$cport" "${hip:-0.0.0.0}" "${hport:-"-"}"
  done <<<"$lines"
}

# ---------------- dns helper ----------------------- #
dns_info() {
  local container_name=$1
  local hostname=${2:-}

  validate_container "$container_name" "running"

  echo "=== DNS inside '$container_name' ==="
  local resolv
  resolv=$(docker exec "$container_name" cat /etc/resolv.conf 2>/dev/null || true)
  if [ -z "$resolv" ]; then
    echo "Could not read /etc/resolv.conf"
  else
    local servers search
    servers=$(printf '%s\n' "$resolv" | awk '/^nameserver /{print $2}' | paste -sd',' - || true)
    search=$(printf '%s\n' "$resolv" | awk '/^search /{$1=""; sub(/^ /,""); print}' || true)
    echo "Servers: ${servers:-N/A}"
    echo "Search : ${search:-N/A}"
  fi

  if [ -n "$hostname" ]; then
    echo
    echo "Resolving '$hostname' from inside container..."
    if docker exec "$container_name" getent hosts "$hostname" >/dev/null 2>&1; then
      docker exec "$container_name" getent hosts "$hostname"
    elif docker exec "$container_name" ping -c1 -W3 "$hostname" >/dev/null 2>&1; then
      docker exec "$container_name" ping -c1 -W3 "$hostname"
    else
      echo "Failed to resolve or reach '$hostname' (no getent/ping or resolution failed)."
    fi
  fi
}

# ---------------- trace helper --------------------- #
trace_from_container() {
  local container_name=$1
  local target=$2
  local port_arg=${3:-}

  validate_container "$container_name" "running"

  local url="" host="" port="" scheme="http"

  if [[ "$target" =~ ^https?:// ]]; then
    url="$target"
    scheme=$(printf '%s\n' "$target" | sed -E 's#^([a-zA-Z]+)://.*#\1#')
    host=$(printf '%s\n' "$target" | sed -E 's#^[a-zA-Z]+://([^/:]+).*#\1#')
    if [[ "$target" =~ :([0-9]+) ]]; then
      port="${BASH_REMATCH[1]}"
    else
      if [ "$scheme" = "https" ]; then
        port=443
      else
        port=80
      fi
    fi
  else
    host="$target"
    if [ -n "$port_arg" ]; then
      port="$port_arg"
    else
      port=80
    fi
    if [ "$port" = "443" ]; then
      scheme="https"
    else
      scheme="http"
    fi
    url="${scheme}://${host}:${port}/"
  fi

  echo "=== dockex trace ==="
  echo "Container: $container_name"
  echo "Target:    $target"
  [ -n "$port" ] && echo "Port:      $port"
  echo "URL:       $url"
  echo

  echo "-- DNS resolution (inside container) --"
  if docker exec "$container_name" getent hosts "$host" >/dev/null 2>&1; then
    docker exec "$container_name" getent hosts "$host"
  elif docker exec "$container_name" ping -c1 -W3 "$host" >/dev/null 2>&1; then
    docker exec "$container_name" ping -c1 -W3 "$host"
  else
    echo "DNS/ICMP resolution failed or tools missing."
  fi

  echo
  echo "-- TCP connectivity --"
  if docker exec "$container_name" command -v nc >/dev/null 2>&1; then
    if docker exec "$container_name" nc -vz "$host" "$port" -w 5 >/dev/null 2>&1; then
      echo "nc: TCP connect to $host:$port succeeded."
    else
      echo "nc: TCP connect to $host:$port FAILED."
    fi
  elif docker exec "$container_name" command -v telnet >/dev/null 2>&1; then
    if docker exec "$container_name" sh -c "echo quit | telnet '$host' '$port'" >/dev/null 2>&1; then
      echo "telnet: TCP connect to $host:$port succeeded."
    else
      echo "telnet: TCP connect to $host:$port FAILED."
    fi
  else
    echo "No nc/telnet inside container; skipping TCP check."
  fi

  echo
  echo "-- HTTP probe --"
  if docker exec "$container_name" command -v curl >/dev/null 2>&1; then
    if ! docker exec "$container_name" curl -sS -o /dev/null -w 'curl: HTTP %{http_code} in %{time_total}s\n' "$url"; then
      echo "curl request failed."
    fi
  elif docker exec "$container_name" command -v wget >/dev/null 2>&1; then
    if ! docker exec "$container_name" wget -q --server-response "$url" -O /dev/null 2>&1 | tail -n 5; then
      echo "wget request failed."
    fi
  else
    echo "No curl/wget inside container; skipping HTTP probe."
  fi
}

# ---------------- ps summary ------------------------ #
ps_summary() {
  local pattern=${1:-}

  echo "=== Container summary ==="

  local stats_out
  stats_out=$(docker stats --no-stream --format '{{.Name}}\t{{.CPUPerc}}\t{{.MemPerc}}\t{{.MemUsage}}' 2>/dev/null || true)

  declare -A CPU_MAP MEM_PCT_MAP MEM_USAGE_MAP

  local line name cpu mem_pct mem_usage
  while IFS=$'\t' read -r name cpu mem_pct mem_usage; do
    [ -z "${name:-}" ] && continue
    CPU_MAP["$name"]=$cpu
    MEM_PCT_MAP["$name"]=$mem_pct
    MEM_USAGE_MAP["$name"]=$mem_usage
  done <<<"$stats_out"

  printf '%-22s %-22s %-20s %-10s %-30s %-14s %-s\n' \
    "NAME" "IMAGE" "STATUS" "CPU" "MEM" "RESTART" "HEALTH"

  local cname image status ports id health restart mem mem_pct_val cpu_val
  while IFS='||' read -r cname image status ports id; do
    [ -z "${cname:-}" ] && continue

    if [ -n "$pattern" ] && ! [[ "$cname" == *"$pattern"* ]]; then
      continue
    fi

    local insp
    insp=$(docker inspect "$cname" 2>/dev/null || echo "")
    if [ -n "$insp" ]; then
      health=$(echo "$insp" | jq -r '.[0].State.Health.Status // "n/a"' 2>/dev/null || echo "n/a")
      restart=$(echo "$insp" | jq -r '.[0].HostConfig.RestartPolicy.Name // "none"' 2>/dev/null || echo "none")
    else
      health="n/a"
      restart="none"
    fi

    cpu_val="${CPU_MAP["$cname"]:-"-"}"
    mem="${MEM_USAGE_MAP["$cname"]:-"-"}"
    mem_pct_val="${MEM_PCT_MAP["$cname"]:-""}"
    if [ "$mem" != "-" ] && [ -n "$mem_pct_val" ]; then
      mem="$mem ($mem_pct_val)"
    fi

    printf '%-22s %-22s %-20s %-10s %-30s %-14s %-s\n' \
      "$cname" "${image:0:21}" "$status" "$cpu_val" "$mem" "$restart" "$health"
  done < <(docker ps -a --format '{{.Names}}||{{.Image}}||{{.Status}}||{{.Ports}}||{{.ID}}')
}

# ---------------- stats profile --------------------- #
stats_profile() {
  local container_name=$1
  local duration=${2:-30}
  local interval=${3:-2}

  validate_container "$container_name" "running"

  if [ "$duration" -le 0 ] 2>/dev/null; then
    duration=30
  fi
  if [ "$interval" -le 0 ] 2>/dev/null; then
    interval=2
  fi

  local samples=$((duration / interval))
  if [ "$samples" -lt 1 ]; then
    samples=1
  fi

  echo "Profiling '$container_name' for ${duration}s (interval ${interval}s, ${samples} samples)..."

  local cpu_sum=0 cpu_max=0 mem_sum=0 mem_max=0 count=0
  local mem_last=""

  local i
  for ((i = 1; i <= samples; i++)); do
    local line
    line=$(docker stats --no-stream --format '{{.CPUPerc}}\t{{.MemUsage}}\t{{.MemPerc}}' "$container_name" 2>/dev/null || true)
    if [ -z "$line" ]; then
      echo "docker stats returned no data; container may have stopped."
      break
    fi

    local cpu mem_usage mem_perc
    IFS=$'\t' read -r cpu mem_usage mem_perc <<<"$line"

    cpu=${cpu%%%}
    mem_perc=${mem_perc%%%}
    cpu=${cpu//,/}
    mem_perc=${mem_perc//,/}

    local cpu_i mem_i
    cpu_i=$(awk "BEGIN {printf \"%d\", $cpu*100}")
    mem_i=$(awk "BEGIN {printf \"%d\", $mem_perc*100}")

    cpu_sum=$((cpu_sum + cpu_i))
    mem_sum=$((mem_sum + mem_i))
    [ "$cpu_i" -gt "$cpu_max" ] && cpu_max=$cpu_i
    [ "$mem_i" -gt "$mem_max" ] && mem_max=$mem_i
    mem_last="$mem_usage"
    count=$((count + 1))

    printf 'Sample %d/%d: CPU=%s%%, MEM=%s (%s%%)\n' "$i" "$samples" "$cpu" "$mem_usage" "$mem_perc"
    sleep "$interval"
  done

  if [ "$count" -eq 0 ]; then
    echo "No samples collected."
    return
  fi

  local cpu_avg mem_avg cpu_max_f mem_max_f
  cpu_avg=$(awk "BEGIN {printf \"%.2f\", $cpu_sum/($count*100.0)}")
  mem_avg=$(awk "BEGIN {printf \"%.2f\", $mem_sum/($count*100.0)}")
  cpu_max_f=$(awk "BEGIN {printf \"%.2f\", $cpu_max/100.0}")
  mem_max_f=$(awk "BEGIN {printf \"%.2f\", $mem_max/100.0}")

  echo
  echo "=== Stats summary for '$container_name' ==="
  echo "Samples:          $count"
  echo "CPU avg/max:      ${cpu_avg}% / ${cpu_max_f}%"
  echo "MEM avg/max:      ${mem_avg}% / ${mem_max_f}%"
  echo "Last MEM usage:   $mem_last"
}

# ---------------- doctor ----------------------------- #
doctor() {
  local target=${1:-}

  echo "=== dockex doctor ==="

  if [ -z "$target" ]; then
    echo "-- Docker info summary --"
    docker info --format 'Server Version: {{.ServerVersion}}
Storage Driver: {{.Driver}}
Cgroup Driver: {{.CgroupDriver}}
Docker Root Dir: {{.DockerRootDir}}
Logging Driver: {{.LoggingDriver}}' || true

    local root
    root=$(docker info -f '{{.DockerRootDir}}' 2>/dev/null || echo "")
    if [ -n "$root" ] && command -v df >/dev/null 2>&1; then
      echo
      echo "-- Disk usage for Docker root ($root) --"
      df -h "$root" || true
    fi

    echo
    echo "-- Docker system df --"
    docker system df || true

    echo
    echo "-- Containers health summary --"
    docker ps -a --format '  {{.Names}}  {{.Status}}' || true
    echo
    echo "Tip: run 'dockex doctor <container>' for a detailed container health check."
    return
  fi

  local container_name=$target
  validate_container "$container_name" "any"

  echo "-- Basic status --"
  docker ps -a --filter "name=^${container_name}$" --format 'Name: {{.Names}}
Image: {{.Image}}
Status: {{.Status}}
Ports: {{.Ports}}'

  echo
  echo "-- Inspect (health, restart policy, limits) --"
  local inspect
  inspect=$(docker inspect "$container_name")

  local restart_policy
  restart_policy=$(echo "$inspect" | jq -r '.[0].HostConfig.RestartPolicy.Name // "none"')
  local health_status
  health_status=$(echo "$inspect" | jq -r '.[0].State.Health.Status // "none"')
  local health_log
  health_log=$(echo "$inspect" | jq -r '.[0].State.Health.Log[-1].Output // ""')

  local mem_raw cpu_shares
  mem_raw=$(echo "$inspect" | jq -r '.[0].HostConfig.Memory')
  cpu_shares=$(echo "$inspect" | jq -r '.[0].HostConfig.CpuShares')
  local mem_text
  if [ "$mem_raw" -eq 0 ] 2>/dev/null; then
    mem_text="Unlimited (no memory limit set)"
  else
    mem_text="$(awk "BEGIN {print $mem_raw/1024/1024}") MB"
  fi

  echo "Restart policy:      ${restart_policy:-none}"
  echo "Health status:       $health_status"
  if [ "$health_status" != "none" ] && [ -n "$health_log" ]; then
    echo "Last health output:  $health_log"
  fi
  echo "CPU shares:          ${cpu_shares:-0}"
  echo "Memory limit:        $mem_text"

  echo
  echo "-- Runtime usage snapshot --"
  docker stats --no-stream --format 'Name: {{.Name}}
CPU: {{.CPUPerc}}
Mem: {{.MemUsage}} ({{.MemPerc}})' "$container_name" 2>/dev/null || echo "docker stats not available."

  echo
  echo "-- Recent error-like logs (last 500 lines) --"
  logs_errors "$container_name" 500

  echo
  echo "-- Suggestions --"
  if [ "$restart_policy" = "no" ] || [ "$restart_policy" = "none" ]; then
    echo "- Consider setting a restart policy, e.g.: docker update --restart=unless-stopped $container_name"
  fi
  if [ "$mem_raw" -eq 0 ] 2>/dev/null; then
    echo "- Consider setting a memory limit to avoid host OOM: dockex update_resources $container_name"
  fi
  if [ "$health_status" = "none" ]; then
    echo "- No healthcheck defined; consider adding one to your Dockerfile or compose."
  elif [ "$health_status" != "healthy" ]; then
    echo "- Container health is '$health_status'; check logs and the health command."
  fi
}

# ---------------- cleanup -------------------------- #
cleanup() {
  echo "Starting cleanup..."
  local cleanup_type=${1:-"unused"} # Default to "unused" cleanup

  case $cleanup_type in
  unused)
    echo "Warning: This will perform a safe cleanup of unused resources."
    echo "The following resources will be removed if unused:"

    echo "Containers:"
    docker container ls -f "status=exited" --format "  - {{.ID}}: {{.Names}}"

    echo "Dangling Images:"
    docker images -f "dangling=true" --format "  - {{.ID}}: {{.Repository}}:{{.Tag}}"

    echo "Volumes:"
    docker volume ls -f "dangling=true" --format "  - {{.Name}}"

    echo "Networks:"
    docker network ls -f "type=custom" -f "dangling=true" --format "  - {{.Name}}"

    read -r -p "Proceed with safe cleanup? (y/N): " confirm
    if [[ "$confirm" != [yY] ]]; then
      echo "Cleanup aborted."
      return
    fi

    docker container prune -f
    docker image prune -f
    docker volume prune -f
    docker network prune -f
    docker system prune -f
    ;;

  aggressive)
    echo "Warning: This will perform an aggressive cleanup, removing all unused resources."
    echo "The following resources will be removed if unused:"

    echo "Containers:"
    docker container ls -a --format "  - {{.ID}}: {{.Names}}"

    echo "Images:"
    docker images --format "  - {{.ID}}: {{.Repository}}:{{.Tag}}"

    echo "Volumes:"
    docker volume ls --format "  - {{.Name}}"

    echo "Networks:"
    docker network ls -f "type=custom" --format "  - {{.Name}}"

    read -r -p "Proceed with aggressive cleanup? (y/N): " confirm
    if [[ "$confirm" != [yY] ]]; then
      echo "Cleanup aborted."
      return
    fi

    docker container prune -f
    docker image prune -a -f
    docker volume prune -f
    docker network prune -f
    docker system prune -f
    ;;

  all)
    echo "Warning: This will remove all Docker resources, including the following:"

    echo "Running Containers:"
    docker ps --format "  - {{.ID}}: {{.Names}}"

    echo "All Containers:"
    docker container ls -a --format "  - {{.ID}}: {{.Names}}"

    echo "All Images:"
    docker images --format "  - {{.ID}}: {{.Repository}}:{{.Tag}}"

    echo "All Volumes:"
    docker volume ls --format "  - {{.Name}}"

    echo "User-Defined Networks:"
    docker network ls -f "type=custom" --format "  - {{.Name}}"

    read -r -p "Proceed with complete removal of all Docker resources? (y/N): " confirm
    if [[ "$confirm" != [yY] ]]; then
      echo "Cleanup aborted."
      return
    fi

    echo "Stopping all running containers..."
    docker stop "$(docker ps -q)" 2>/dev/null || true

    echo "Removing all containers, images, volumes, and user-defined networks..."
    docker container rm -f "$(docker ps -aq)" 2>/dev/null || true
    docker rmi -f "$(docker images -q)" 2>/dev/null || true
    docker volume rm -f "$(docker volume ls -q)" 2>/dev/null || true
    docker network rm "$(docker network ls -q | grep -vE 'bridge|host|none')" 2>/dev/null || true
    ;;

  *)
    echo "Invalid option. Usage: cleanup [unused|aggressive|all]"
    return 1
    ;;
  esac

  echo "Cleanup complete."
}

# ---------------- main dispatch -------------------- #

if [ "$#" -lt 1 ]; then
  echo "Error: Missing arguments."
  show_usage
  exit 1
fi

command=$1
container_name=${2:-}

case "$command" in
list)
  show_docker_listings
  ;;
nets)
  nets_topology
  ;;
create)
  if [ -z "$container_name" ]; then
    echo "Error: Image name is required."
    show_usage
    exit 1
  fi
  create_new_container "$container_name" "${3:-}"
  ;;
info | inspect)
  if [ -z "$container_name" ]; then
    echo "Error: Container name is required."
    show_usage
    exit 1
  fi
  view_container_info "$container_name"
  ;;
ps)
  ps_summary "${2:-}"
  ;;
logs)
  if [ -z "$container_name" ]; then
    echo "Error: Container name is required."
    show_usage
    exit 1
  fi
  view_logs "$container_name" "${3:-10}"
  ;;
logs-errors)
  if [ -z "$container_name" ]; then
    echo "Error: Container name is required."
    show_usage
    exit 1
  fi
  logs_errors "$container_name" "${3:-500}"
  ;;
start)
  if [ -z "$container_name" ]; then
    echo "Error: Container name is required."
    show_usage
    exit 1
  fi
  start_container "$container_name"
  ;;
stop)
  if [ -z "$container_name" ]; then
    echo "Error: Container name is required."
    show_usage
    exit 1
  fi
  stop_container "$container_name"
  ;;
restart)
  if [ -z "$container_name" ]; then
    echo "Error: Container name is required."
    show_usage
    exit 1
  fi
  restart_container "$container_name"
  ;;
stream_logs)
  if [ -z "$container_name" ]; then
    echo "Error: Container name is required."
    show_usage
    exit 1
  fi
  stream_logs "$container_name"
  ;;
shell)
  if [ -z "$container_name" ]; then
    echo "Error: Container name is required."
    show_usage
    exit 1
  fi
  shell_into_container "$container_name"
  ;;
exec-run)
  if [ -z "$container_name" ]; then
    echo "Error: Container name is required."
    show_usage
    exit 1
  fi
  shift 2
  exec_run "$container_name" "$@"
  ;;
top)
  if [ -z "$container_name" ]; then
    echo "Error: Container name is required."
    show_usage
    exit 1
  fi
  top_container "$container_name"
  ;;
update_resources)
  if [ -z "$container_name" ]; then
    echo "Error: Container name is required."
    show_usage
    exit 1
  fi
  update_container_resources "$container_name"
  ;;
backup)
  if [ -z "$container_name" ]; then
    echo "Error: Container name is required."
    show_usage
    exit 1
  fi
  backup_container_data "$container_name"
  ;;
restore)
  if [ -z "$container_name" ]; then
    echo "Error: Container name is required."
    show_usage
    exit 1
  fi
  restore_container_data "$container_name" "${3:-}"
  ;;
benchmark)
  if [ -z "$container_name" ]; then
    echo "Error: Container name is required."
    show_usage
    exit 1
  fi
  benchmark "$container_name" "${3:-3}" "${4:-100}" "${5:-10}"
  ;;
stats)
  if [ -z "$container_name" ]; then
    echo "Error: Container name is required."
    show_usage
    exit 1
  fi
  stats_profile "$container_name" "${3:-30}" "${4:-2}"
  ;;
trace)
  if [ -z "$container_name" ] || [ -z "${3:-}" ]; then
    echo "Error: trace requires <container> and <host-or-url>."
    show_usage
    exit 1
  fi
  trace_from_container "$container_name" "$3" "${4:-}"
  ;;
ports)
  if [ -z "$container_name" ]; then
    echo "Error: Container name is required."
    show_usage
    exit 1
  fi
  ports_container "$container_name"
  ;;
dns)
  if [ -z "$container_name" ]; then
    echo "Error: Container name is required."
    show_usage
    exit 1
  fi
  dns_info "$container_name" "${3:-}"
  ;;
doctor)
  doctor "${2:-}"
  ;;
cleanup)
  cleanup "${2:-unused}"
  ;;
*)
  echo "Error: Unknown command '$command'."
  show_usage
  exit 1
  ;;
esac
