#!/usr/bin/env bash
# netx - Network toolbox for diagnostics, security and benchmarks
set -euo pipefail

VERSION="0.4.0"

# Global flags (set in main)
NETX_JSON=0
NETX_QUIET=0
NETX_JSON_NATIVE=0


# -------------------- Capability & Color Setup --------------------

have() { command -v "$1" >/dev/null 2>&1; }

# Time helpers (no python dependency, safe on busybox too)
now_ns() {
  local ns
  if ns=$(date +%s%N 2>/dev/null); then
    printf '%s\n' "$ns"
  else
    # fallback: seconds -> ns
    printf '%s000000000\n' "$(date +%s)"
  fi
}

now_ms() {
  local ns
  ns=$(now_ns)
  printf '%s\n' "$((ns / 1000000))"
}

# Color detection (NETX_COLOR=never|auto|always)
NETX_COLOR="${NETX_COLOR:-auto}"

_supports_color() {
  [[ ! -t 1 ]] && [[ "$NETX_COLOR" != "always" ]] && return 1
  [[ "$NETX_COLOR" == "never" ]] && return 1
  return 0
}

if _supports_color; then
  if tput setaf 1 >/dev/null 2>&1; then
    c_bold=$(tput bold)
    c_dim=$(tput dim)
    c_red=$(tput setaf 1)
    c_green=$(tput setaf 2)
    c_yellow=$(tput setaf 3)
    c_blue=$(tput setaf 4)
    c_magenta=$(tput setaf 5)
    c_cyan=$(tput setaf 6)
    c_reset=$(tput sgr0)
  else
    c_bold=$'\033[1m'
    c_dim=$'\033[2m'
    c_red=$'\033[31m'
    c_green=$'\033[32m'
    c_yellow=$'\033[33m'
    c_blue=$'\033[34m'
    c_magenta=$'\033[35m'
    c_cyan=$'\033[36m'
    c_reset=$'\033[0m'
  fi
else
  c_bold= c_dim= c_red= c_green= c_yellow= c_blue= c_magenta= c_cyan= c_reset=
fi

c_header="${c_bold}${c_cyan}"
c_ok="${c_green}"
c_warn="${c_yellow}"
c_err="${c_red}"
c_muted="${c_dim}"

err() { printf '%snetx:%s %s\n' "${c_err}" "${c_reset}" "$*" >&2; }
die() {
  err "$@"
  exit 1
}

section() {
  ((NETX_QUIET)) && return 0
  ((NETX_JSON)) && return 0
  printf '
%s== %s ==%s
' "${c_header}" "$*" "${c_reset}"
}

kv() {
  ((NETX_QUIET)) && return 0
  ((NETX_JSON)) && return 0
  printf '  %s%-14s%s %s
' "${c_muted}" "$1:" "${c_reset}" "$2"
}

usage() {
  cat <<'EOF'
Usage: netx [--json] [--quiet] <command> [subcommand] [options]

Global flags:
  --json    Machine-readable output where supported
  --quiet   Print only the primary value where supported

Core:
  netx doctor <host> [--port P] [--http] [--tls] [--raw]

DNS:
  netx dns resolve <name> [--type T] [--resolver IP]
  netx dns dump <name> [--full]
  netx dns compare <name> [--type T] [--resolver ip1,ip2,...]
  netx dns trace <name> [--type T]
  netx dns reverse <ip>
  netx dns whoami [--resolver IP]
  netx dns flush
  netx dns system
  netx dns hosts <host>

HTTP / Proxy:
  netx http get <url> [--headers] [--body] [--json] [--timeout N]
  netx http head <url> [--timeout N]
  netx http trace <url> [--timeout N]
  netx proxy env
  netx proxy test <url>

Sniff:
  netx sniff http <url> [curl-args...]
  netx sniff pkt <iface> [--count N] [--seconds N] [--write file.pcap] [--no-resolve] [--verbose] [--snaplen N] [--rotate MB] [--files N] [--promisc off] [-- <bpf-filter...>]

Benchmark (curl-only):
  netx bench http <url> [--requests N] [--concurrency N] [--timeout N]
  netx bench ping <host> [--count N]

TLS:
  netx tls info <host> [--port P]
  netx tls verify <host> [--port P] [--strict]
  netx tls chain <host> [--port P]

Ports / Connections:
  netx port ls [--listening] [--tcp] [--udp] [--process]
  netx port find <port> [--process]
  netx port check <host> <port> [--timeout N] [--udp]
  netx port scan <host> [--ports 80,443,3306]

  netx conn ls [--all] [--outbound] [--listening] [--suspicious-only]
  netx conn record [--interval N] [--duration N] [--out file]
  netx conn summary [--file file]

Outbound Guard:
  netx guard snapshot [--file path]
  netx guard diff [--file path]
  netx guard watch [--interval N] [--file path]
                    [--exclude-user list] [--exclude-port list]
                    [--exclude-cidr list] [--exec cmd]

Security / Suspicious Listeners:
  netx sec listeners [--exclude-user list] [--exclude-port list]

IP / Interfaces / Routes:
  netx ip info
  netx ip public [--ipv4] [--ipv6]
  netx if ls
  netx if stats <iface>
  netx route show
  netx route explain <host>

Watchers / Waiters:
  netx watch ping <host> [--interval N]
  netx watch http <url> [--interval N] [--expect-status CODE]
  netx wait port <host> <port> [--timeout N]

Stacks:
  netx stack check <name> [--config /custom/path]

Namespaces:
  netx ns ls
  netx ns inspect <ns>
  netx ns exec <ns> <cmd...>

Path / Firewall / Report:
  netx path trace <host> [--max-hops N]
  netx trace <host> [--max-hops N]
  netx fw summary
  netx fw list [--raw]
  netx report [--out file]

EOF
}

NETX_DIR="${HOME}/.netx"
mkdir -p "$NETX_DIR"

split_csv() { tr ',' '\n' <<<"$1"; }

is_private_ip() {
  local ip="$1"
  case "$ip" in
  10.* | 192.168.* | 172.1[6-9].* | 172.2[0-9].* | 172.3[0-1].* | 127.*) return 0 ;;
  ::1 | fc* | fd* | fe80:*) return 0 ;;
  esac
  return 1
}

# Heuristics config
SAFE_REMOTE_PORTS="22 53 80 123 443 587 993 995"
SUSPICIOUS_COMM_REGEX='(bash|sh|zsh|fish|python[0-9]*|perl|php|ruby|node|nodejs|nc|ncat|socat|telnet|nmap|ssh|scp|sftp|curl|wget)'

# Normalizer for ss/netstat lines used by guard/conn security features
normalize_conn_ss_line() {
  awk '
    NR==1 {next}
    {
      proto=$1
      local=$5
      remote=$6
      pid="?"
      comm="?"
      user="?"
      if (match($0,/users:\(\("([^"]+)",pid=([0-9]+)/,m)) {
        comm=m[1]; pid=m[2]
      }
      print proto"|"local"|"remote"|"pid"|"comm"|"user
    }
  '
}

# Suspicious outbound scoring
suspicious_score() {
  local proto="$1" state="$2" local_addr="$3" remote_addr="$4" pid="$5" comm="$6"
  local score=0

  # Only care about established connections
  [[ "$state" != "ESTAB" && "$state" != "ESTABLISHED" ]] && { echo 0; return; }

  local remote_ip remote_port
  remote_ip=${remote_addr%:*}
  remote_port=${remote_addr##*:}

  # Public destination
  if ! is_private_ip "$remote_ip"; then
    score=$((score + 1))
  fi

  # High remote ports not in "common safe" set
  local safe=0 p
  for p in $SAFE_REMOTE_PORTS; do
    if [[ "$remote_port" == "$p" ]]; then
      safe=1
      break
    fi
  done
  if [[ "$remote_port" -ge 1024 && "$safe" -eq 0 ]]; then
    score=$((score + 1))
  fi

  # Suspicious process names
  if [[ "$comm" =~ $SUSPICIOUS_COMM_REGEX ]]; then
    score=$((score + 1))
  fi

  # Binary in temp-ish dirs
  local exe_path=""
  if [[ -n "${pid:-}" && -e "/proc/$pid/exe" ]]; then
    exe_path=$(readlink "/proc/$pid/exe" 2>/dev/null || true)
    case "$exe_path" in
    /tmp/*|/dev/shm/*|/var/tmp/*)
      score=$((score + 2))
      ;;
    esac
  fi

  # Non-root user + public dest + odd port
  if [[ -n "${pid:-}" && -r "/proc/$pid/status" ]]; then
    local uid uid_name
    uid=$(awk '/^Uid:/{print $2}' "/proc/$pid/status" 2>/dev/null || echo "")
    if [[ -n "$uid" ]]; then
      uid_name=$(getent passwd "$uid" 2>/dev/null | cut -d: -f1 || echo "")
      if [[ -n "$uid_name" && "$uid_name" != "root" ]] && ! is_private_ip "$remote_ip" && [[ "$safe" -eq 0 ]]; then
        score=$((score + 1))
      fi
    fi
  fi

  echo "$score"
}

# -------------------- 1. Doctor --------------------

doctor_cmd() {
  local host="" port=443 do_http=0 do_tls=0 raw=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --port)
      port="$2"
      shift
      ;;
    --http) do_http=1 ;;
    --tls) do_tls=1 ;;
    --raw) raw=1 ;;
    *) [[ -z "$host" ]] && host="$1" || die "Unexpected arg: $1" ;;
    esac
    shift || true
  done
  [[ -z "$host" ]] && die "doctor: host required"

  section "netx doctor: $host:$port"

  # DNS
  local dns_start dns_end dns_ms
  dns_start=$(now_ms)
  local dns_out="" dns_tool=""
  if have dig; then
    dns_tool="dig"
    dns_out=$(dig +short "$host" A 2>/dev/null | head -n 5)
    # fallback to NSS (/etc/hosts, etc.) if pure DNS returns nothing (e.g. localhost)
    if [[ -z "$dns_out" ]] && have getent; then
      dns_tool="getent"
      dns_out=$(getent ahostsv4 "$host" 2>/dev/null | awk '{print $1}' | head -n 5)
      [[ -z "$dns_out" ]] && dns_out=$(getent hosts "$host" 2>/dev/null | awk '{print $1}' | head -n 5)
    fi
  elif have getent; then
    dns_tool="getent"
    dns_out=$(getent ahostsv4 "$host" 2>/dev/null | awk '{print $1}' | head -n 5)
    [[ -z "$dns_out" ]] && dns_out=$(getent hosts "$host" 2>/dev/null | awk '{print $1}' | head -n 5)
  else
    dns_tool="n/a"
    dns_out=""
  fi
  dns_end=$(now_ms)
  dns_ms=$((dns_end - dns_start))

  section "DNS"
  kv "Resolver" "$dns_tool"
  kv "Lookup ms" "$dns_ms"
  if [[ -n "$dns_out" ]]; then
    echo "  Answers:"
    echo "$dns_out" | sed 's/^/    - /'
  else
    echo "  ${c_err}FAILED (no DNS/NSS answer)${c_reset}"
  fi


# Quick network summary (best-effort)
section "Network"
if have ip; then
  local def_line def_dev def_gw
  def_line=$(ip route show default 2>/dev/null | head -n1 || true)
  def_dev=$(awk '{for(i=1;i<=NF;i++) if($i=="dev"){print $(i+1); exit}}' <<<"$def_line" || true)
  def_gw=$(awk '{for(i=1;i<=NF;i++) if($i=="via"){print $(i+1); exit}}' <<<"$def_line" || true)
  [[ -n "$def_line" ]] && kv "Default route" "$def_line" || kv "Default route" "(none)"
  [[ -n "$def_dev" ]] && kv "Default dev" "$def_dev"
  [[ -n "$def_gw" ]] && kv "Default gw" "$def_gw"
fi

local dns_srv=""
if [[ -r /etc/resolv.conf ]]; then
  dns_srv=$(awk '/^nameserver/{print $2}' /etc/resolv.conf | paste -sd, - 2>/dev/null || true)
  [[ -n "$dns_srv" ]] && kv "DNS" "$dns_srv"
fi

if have ip; then
  local vpn_if
  vpn_if=$(ip -o link show 2>/dev/null | awk -F': ' '{print $2}' | grep -E '^(tun|tap|wg|ppp|utun)[0-9]*$' || true)
  [[ -n "$vpn_if" ]] && kv "VPN ifaces" "$(tr '\n' ' ' <<<"$vpn_if" | xargs)" || kv "VPN ifaces" "(none)"
fi

if have docker; then
  local subnets=""
  subnets=$(docker network ls --format '{{.Name}}' 2>/dev/null | while read -r n; do docker network inspect "$n" --format '{{range .IPAM.Config}}{{.Subnet}}{{end}}' 2>/dev/null; done | tr ' ' '\n' | grep -E '^[0-9]' || true)
  if [[ -n "$subnets" ]]; then
    kv "Docker subnets" "$(tr '\n' ' ' <<<"$subnets" | xargs)"
  fi
fi

if have ip; then
  local mtu_line
  mtu_line=$(ip -o link show 2>/dev/null | awk '{for(i=1;i<=NF;i++) if($i=="mtu"){print $(i+1); break}}' | head -n5 | paste -sd, - 2>/dev/null || true)
  [[ -n "$mtu_line" ]] && kv "MTU sample" "$mtu_line"
fi
  # Ping (summary only)
  section "Ping"
  if have ping; then
    local rtt
    rtt=$(ping -c 3 -W 2 "$host" 2>/dev/null | tail -n 1)
    # Match both:
    #   rtt min/avg/max/mdev = 1.24/1.37/1.73/0.13 ms
    #   round-trip min/avg/max/stddev = ...
    if [[ "$rtt" =~ =[[:space:]]*([0-9.]+)/([0-9.]+)/([0-9.]+)/([0-9.]+)[[:space:]]ms ]]; then
      local min avg max mdev
      min="${BASH_REMATCH[1]}"
      avg="${BASH_REMATCH[2]}"
      max="${BASH_REMATCH[3]}"
      mdev="${BASH_REMATCH[4]}"
      kv "Min" "${min} ms"
      kv "Avg" "${avg} ms"
      kv "Max" "${max} ms"
      kv "Jitter" "${mdev} ms"
    else
      echo "  (no RTT summary)"
    fi
  else
    echo "  ping not available"
  fi

  # Route
  section "Route (first 5 hops)"
  if have traceroute; then
    traceroute -n -m 20 "$host" 2>/dev/null | head -n 6
  elif have mtr; then
    mtr -n -c 2 -r -m 10 "$host" 2>/dev/null
  else
    echo "  traceroute/mtr not available"
  fi

  # Port check
  section "Port check"
  if have nc; then
    if nc -z -w 3 "$host" "$port" 2>/dev/null; then
      echo "  ${c_ok}$host:$port reachable${c_reset}"
    else
      echo "  ${c_err}$host:$port NOT reachable${c_reset}"
    fi
  else
    echo "  nc not available"
  fi

  # HTTP
  if ((do_http)); then
    section "HTTP"
    if ! have curl; then
      echo "  curl not available"
    else
      local status time_total size redirect
      read -r status time_total size redirect < <(
        curl -sS -o /dev/null --max-time 10 \
          -w '%{http_code} %{time_total} %{size_download} %{num_redirects}' \
          "http://$host:$port" || echo "000 0 0 0"
      )
      kv "Status" "$status"
      kv "Total time" "${time_total}s"
      kv "Size" "${size}B"
      kv "Redirects" "$redirect"
    fi
  fi

  # TLS
  if ((do_tls)) || [[ "$port" -eq 443 ]]; then
    section "TLS"
    if have openssl; then
      local tmp
      tmp=$(mktemp)
      local cmd="openssl s_client -servername $host -connect $host:$port"
      if have timeout; then
        cmd="timeout 5 $cmd"
      fi
      if echo | eval "$cmd" 2>/dev/null | openssl x509 -noout -subject -issuer -dates >"$tmp"; then
        sed 's/^/  /' "$tmp"
      else
        echo "  failed to fetch certificate"
      fi
      rm -f "$tmp"
    else
      echo "  openssl not available"
    fi
  fi

  ((raw)) && echo -e "\n[RAW] doctor completed"
}

# -------------------- 2. DNS --------------------

dns_cmd() {
  local sub="$1"
  shift || true
  case "$sub" in
  resolve) dns_resolve "$@" ;;
  dump) dns_dump "$@" ;;
  compare) dns_compare "$@" ;;
  trace) dns_trace "$@" ;;
  reverse) dns_reverse "$@" ;;
  system) dns_system ;;
  whoami) dns_whoami "$@" ;;
  flush) dns_flush ;;
  hosts) dns_hosts "$@" ;;
  *) die "dns: unknown subcommand '$sub'" ;;
  esac
}

dns_resolve() {
  local name="" type="A" resolver=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --type)
      type="$2"
      shift
      ;;
    --resolver)
      resolver="$2"
      shift
      ;;
    *) name="$1" ;;
    esac
    shift || true
  done
  [[ -z "$name" ]] && die "dns resolve: name required"
  if have dig; then
    if [[ -n "$resolver" ]]; then
      dig @"$resolver" "$name" "$type" +short
    else
      dig "$name" "$type" +short
    fi
  elif have host; then
    host "$name"
  else
    die "dns: need dig or host"
  fi
}

dns_dump() {
  local name="" full=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --full) full=1 ;;
    *) name="$1" ;;
    esac
    shift || true
  done
  [[ -z "$name" ]] && die "dns dump: name required"
  local types="A AAAA CNAME MX NS TXT"
  ((full)) && types="A AAAA CNAME MX NS TXT SRV"
  for t in $types; do
    section "[$t]"
    dns_resolve "$name" --type "$t" || true
  done
}

dns_compare() {
  local name="" type="A" resolvers=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --type)
      type="$2"
      shift
      ;;
    --resolver)
      resolvers="$2"
      shift
      ;;
    *) name="$1" ;;
    esac
    shift || true
  done
  [[ -z "$name" ]] && die "dns compare: name required"
  [[ -z "$resolvers" ]] && resolvers="1.1.1.1,8.8.8.8,9.9.9.9"
  for r in $(split_csv "$resolvers"); do
    section "Resolver $r"
    dns_resolve "$name" --type "$type" --resolver "$r" || echo "  (failed)"
  done
}

dns_trace() {
  local name="" type="A"
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --type)
      type="$2"
      shift
      ;;
    *) name="$1" ;;
    esac
    shift || true
  done
  [[ -z "$name" ]] && die "dns trace: name required"
  have dig || die "dns trace: dig required"
  dig "$name" "$type" +trace
}

dns_reverse() {
  local ip="${1:-}"
  [[ -z "$ip" ]] && die "dns reverse: ip required"
  if have dig; then
    dig -x "$ip" +short
  elif have host; then
    host "$ip"
  else
    die "dns reverse: dig or host required"
  fi
}

dns_whoami() {
  # Shows resolver behavior and your public egress IP as seen by resolver target (best-effort)
  local resolver=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --resolver) resolver="$2"; shift ;;
    *) resolver="$1" ;;
    esac
    shift || true
  done
  have dig || die "dns whoami: dig required"

  [[ -z "$resolver" ]] && resolver="1.1.1.1"

  section "DNS whoami (via $resolver)"
  local who ip
  who=$(dig @"$resolver" +short TXT CH whoami.cloudflare 2>/dev/null | tr -d '"\r' || true)
  ip=$(dig @"$resolver" +short A whoami.cloudflare 2>/dev/null | head -n1 | tr -d "\r" || true)

  [[ -n "$who" ]] && kv "Resolver sees" "$who" || kv "Resolver sees" "(n/a)"
  [[ -n "$ip" ]] && kv "Egress IP" "$ip" || kv "Egress IP" "(n/a)"
}

dns_flush() {
  section "DNS cache flush (best-effort)"
  local did=0

  if have resolvectl; then
    if resolvectl flush-caches >/dev/null 2>&1; then
      echo "  resolvectl flush-caches: ${c_ok}ok${c_reset}"
      did=1
    fi
  fi

  if have systemd-resolve; then
    if systemd-resolve --flush-caches >/dev/null 2>&1; then
      echo "  systemd-resolve --flush-caches: ${c_ok}ok${c_reset}"
      did=1
    fi
  fi

  if have dscacheutil; then
    if dscacheutil -flushcache >/dev/null 2>&1; then
      echo "  dscacheutil -flushcache: ${c_ok}ok${c_reset}"
      did=1
    fi
  fi

  if have killall && [[ "$(uname -s 2>/dev/null || true)" == "Darwin" ]]; then
    if killall -HUP mDNSResponder >/dev/null 2>&1; then
      echo "  mDNSResponder HUP: ${c_ok}ok${c_reset}"
      did=1
    fi
  fi

  if have nscd; then
    if nscd -i hosts >/dev/null 2>&1; then
      echo "  nscd -i hosts: ${c_ok}ok${c_reset}"
      did=1
    fi
  fi

  if ((did==0)); then
    echo "  ${c_warn}No known DNS cache service detected (or insufficient permissions).${c_reset}"
  fi
}

dns_system() {
  section "/etc/resolv.conf"
  if [[ -f /etc/resolv.conf ]]; then
    sed 's/^/  /' /etc/resolv.conf
  else
    echo "  not found"
  fi
  if have systemd-resolve; then
    section "systemd-resolve --status"
    systemd-resolve --status 2>/dev/null | sed 's/^/  /'
  fi
}

dns_hosts() {
  local host="${1:-}"
  [[ -z "$host" ]] && die "dns hosts: host required"
  section "/etc/hosts"
  if [[ -f /etc/hosts ]]; then
    if ! grep -iE "[[:space:]]$host([[:space:]]|\$)" /etc/hosts; then
      echo "  No entry for $host"
    fi
  else
    echo "  /etc/hosts not found"
  fi
}

# -------------------- 3. HTTP / Proxy --------------------

require_curl() { have curl || die "curl required"; }

http_cmd() {
  local sub="$1"
  shift || true
  case "$sub" in
  get) http_get "$@" ;;
  head) http_head "$@" ;;
  trace) http_trace "$@" ;;
  *) die "http: unknown subcommand '$sub'" ;;
  esac
}

http_get() {
  require_curl
  local url="" headers=0 body=0 json=0 timeout=5
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --headers) headers=1 ;;
    --body) body=1 ;;
    --json) json=1 ;;
    --timeout)
      timeout="$2"
      shift
      ;;
    *) url="$1" ;;
    esac
    shift || true
  done
  [[ -z "$url" ]] && die "http get: url required"

  section "HTTP GET"
  kv "URL" "$url"
  kv "Timeout" "${timeout}s"

  local curl_args=(-sS --max-time "$timeout")
  ((json)) && curl_args+=(-H 'Accept: application/json')

  if ((body || headers)); then
    ((headers)) && curl "${curl_args[@]}" -D - "$url" || true
    ((body)) && curl "${curl_args[@]}" "$url"
  else
    local status time_total size redirects
    read -r status time_total size redirects < <(
      curl "${curl_args[@]}" -o /dev/null \
        -w '%{http_code} %{time_total} %{size_download} %{num_redirects}' \
        "$url" || echo "000 0 0 0"
    )
    kv "Status" "$status"
    kv "Total time" "${time_total}s"
    kv "Size" "${size}B"
    kv "Redirects" "$redirects"
  fi
}

http_head() {
  require_curl
  local url="" timeout=5
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --timeout)
      timeout="$2"
      shift
      ;;
    *) url="$1" ;;
    esac
    shift || true
  done
  [[ -z "$url" ]] && die "http head: url required"
  section "HTTP HEAD $url"
  curl -sS -I --max-time "$timeout" "$url"
}

http_trace() {
  require_curl
  local url="" timeout=5
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --timeout)
      timeout="$2"
      shift
      ;;
    *) url="$1" ;;
    esac
    shift || true
  done
  [[ -z "$url" ]] && die "http trace: url required"

  section "HTTP TRACE"
  kv "URL" "$url"
  kv "Timeout" "${timeout}s"

  local out
  read -r out < <(
    curl -sS -o /dev/null --max-time "$timeout" \
      -w 'dns=%{time_namelookup}s connect=%{time_connect}s tls=%{time_appconnect}s ttfb=%{time_starttransfer}s total=%{time_total}s status=%{http_code} size=%{size_download}B redirects=%{num_redirects}' \
      "$url" || echo "dns=0 connect=0 tls=0 ttfb=0 total=0 status=000 size=0 redirects=0"
  )
  for tok in $out; do
    k=${tok%%=*}
    v=${tok#*=}
    case "$k" in
    dns) kv "DNS" "$v" ;;
    connect) kv "Connect" "$v" ;;
    tls) kv "TLS" "$v" ;;
    ttfb) kv "TTFB" "$v" ;;
    total) kv "Total" "$v" ;;
    status) kv "Status" "$v" ;;
    size) kv "Size" "$v" ;;
    redirects) kv "Redirects" "$v" ;;
    esac
  done
}

proxy_cmd() {
  local sub="$1"
  shift || true
  case "$sub" in
  env) proxy_env ;;
  test) proxy_test "$@" ;;
  *) die "proxy: unknown subcommand '$sub'" ;;
  esac
}

proxy_env() {
  section "Proxy env"
  kv "HTTP_PROXY" "${HTTP_PROXY:-}"
  kv "HTTPS_PROXY" "${HTTPS_PROXY:-}"
  kv "NO_PROXY" "${NO_PROXY:-${no_proxy:-}}"
}

proxy_test() {
  require_curl
  local url="${1:-}"
  [[ -z "$url" ]] && die "proxy test: url required"
  section "Proxy test (direct)"
  NO_PROXY="*" no_proxy="*" curl -sS -o /dev/null -w 'status=%{http_code} time=%{time_total}s\n' "$url" || echo "  failed"
  section "Proxy test (env)"
  curl -sS -o /dev/null -w 'status=%{http_code} time=%{time_total}s\n' "$url" || echo "  failed"
}

# -------------------- 4. Benchmarks (curl-only) --------------------

bench_cmd() {
  local sub="$1"
  shift || true
  case "$sub" in
  http) bench_http "$@" ;;
  ping) bench_ping "$@" ;;
  *) die "bench: unknown subcommand '$sub'" ;;
  esac
}

bench_http() {
  require_curl
  local url="" requests=50 concurrency=5 timeout=5
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --requests)
      requests="$2"
      shift
      ;;
    --concurrency)
      concurrency="$2"
      shift
      ;;
    --timeout)
      timeout="$2"
      shift
      ;;
    *) url="$1" ;;
    esac
    shift || true
  done
  [[ -z "$url" ]] && die "bench http: url required"

  section "HTTP Benchmark"
  kv "URL" "$url"
  kv "Requests" "$requests"
  kv "Concurrency" "$concurrency"
  kv "Timeout" "${timeout}s"

  local tmp_times
  tmp_times=$(mktemp)

  # Multi-curl using xargs -P
  seq 1 "$requests" | xargs -I{} -P "$concurrency" bash -c '
    url="$0"; timeout="$1"
    start=$(date +%s%N 2>/dev/null || echo "$(date +%s)000000000")
    code=$(curl -sS -o /dev/null --max-time "$timeout" -w "%{http_code}" "$url" 2>/dev/null || echo 0)
    end=$(date +%s%N 2>/dev/null || echo "$(date +%s)000000000")
    dur_ns=$((end-start))
    printf "%s %s\n" "$code" "$dur_ns"
  ' "$url" "$timeout" >"$tmp_times" || true

  local total=0 ok=0
  while read -r code _; do
    ((total++))
    ((code >= 200 && code < 400)) && ((ok++))
  done <"$tmp_times"

  if ((total == 0)); then
    echo "  No measurements"
    rm -f "$tmp_times"
    return 1
  fi

  awk -v total="$total" -v ok="$ok" '
    {
      ns=$2
      ms=ns/1000000.0
      times[count++]=ms
    }
    END {
      n=count
      if (n==0) { print "  No data"; exit }
      for (i=0;i<n;i++) {
        for (j=i+1;j<n;j++) {
          if (times[j]<times[i]) {
            tmp=times[i]; times[i]=times[j]; times[j]=tmp
          }
        }
      }
      min=times[0]; max=times[n-1]
      sum=0
      for (i=0;i<n;i++) sum+=times[i]
      avg=sum/n
      p95=times[int(0.95*(n-1)+0.5)]
      p99=times[int(0.99*(n-1)+0.5)]
      rps = total>0 ? (total / (sum/1000.0)) : 0
      printf "  Requests : %d\n", total
      printf "  Success  : %d\n", ok
      printf "  Min(ms)  : %.2f\n", min
      printf "  Avg(ms)  : %.2f\n", avg
      printf "  P95(ms)  : %.2f\n", p95
      printf "  P99(ms)  : %.2f\n", p99
      printf "  Max(ms)  : %.2f\n", max
      printf "  Req/s    : %.2f\n", rps
    }
  ' "$tmp_times"

  rm -f "$tmp_times"
}

bench_ping() {
  local host="" count=50
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --count)
      count="$2"
      shift
      ;;
    *) host="$1" ;;
    esac
    shift || true
  done
  [[ -z "$host" ]] && die "bench ping: host required"
  have ping || die "ping required"

  section "Ping Benchmark"
  kv "Host" "$host"
  kv "Count" "$count"

  ping -c "$count" "$host"
  local rtt
  rtt=$(ping -c "$count" -W 2 "$host" 2>/dev/null | tail -n 1)
  if [[ "$rtt" =~ =[[:space:]]*([0-9.]+)/([0-9.]+)/([0-9.]+)/([0-9.]+)[[:space:]]ms ]]; then
    local min avg max mdev
    min="${BASH_REMATCH[1]}"
    avg="${BASH_REMATCH[2]}"
    max="${BASH_REMATCH[3]}"
    mdev="${BASH_REMATCH[4]}"
    section "RTT Summary"
    kv "Min" "${min} ms"
    kv "Avg" "${avg} ms"
    kv "Max" "${max} ms"
    kv "Jitter" "${mdev} ms"
  fi
}

# -------------------- 5. TLS --------------------

tls_cmd() {
  local sub="$1"
  shift || true
  case "$sub" in
  info) tls_info "$@" ;;
  verify) tls_verify "$@" ;;
  chain) tls_chain "$@" ;;
  *) die "tls: unknown subcommand '$sub'" ;;
  esac
}

_tls_s_client() {
  local host="$1" port="$2"; shift 2
  local extra=("$@")
  local cmd="openssl s_client -servername $host -connect $host:$port"
  if ((${#extra[@]})); then
    cmd+=" ${extra[*]}"
  fi
  if have timeout; then
    cmd="timeout 5 $cmd"
  fi
  echo | eval "$cmd" 2>/dev/null
}

tls_info() {
  have openssl || die "openssl required"
  local host="" port=443
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --port)
      port="$2"
      shift
      ;;
    *) host="$1" ;;
    esac
    shift || true
  done
  [[ -z "$host" ]] && die "tls info: host required"

  section "TLS Info"
  kv "Host" "$host"
  kv "Port" "$port"

  local tmp
  tmp=$(mktemp)
  if _tls_s_client "$host" "$port" | openssl x509 -noout -subject -issuer -dates >"$tmp"; then
    local subject issuer notBefore notAfter
    subject=$(grep '^subject=' "$tmp" | sed 's/^subject= *//')
    issuer=$(grep '^issuer=' "$tmp" | sed 's/^issuer= *//')
    notBefore=$(grep '^notBefore=' "$tmp" | sed 's/^notBefore=//')
    notAfter=$(grep '^notAfter=' "$tmp" | sed 's/^notAfter=//')
    kv "Subject" "$subject"
    kv "Issuer" "$issuer"
    kv "Valid from" "$notBefore"
    kv "Valid to" "$notAfter"
  else
    echo "  Failed to retrieve certificate (no TLS or port closed)"
  fi
  rm -f "$tmp"
}

tls_verify() {
  have openssl || die "openssl required"
  local host="" port=443 strict=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --port)
      port="$2"
      shift
      ;;
    --strict) strict=1 ;; # reserved for future, currently unused
    *) host="$1" ;;
    esac
    shift || true
  done
  [[ -z "$host" ]] && die "tls verify: host required"

  section "TLS Verify"
  kv "Host" "$host"
  kv "Port" "$port"

  local tmp
  tmp=$(mktemp)
  if ! _tls_s_client "$host" "$port" | openssl x509 -noout -dates -issuer -subject >"$tmp"; then
    echo "  Failed to retrieve certificate"
    rm -f "$tmp"
    return 1
  fi

  local notafter
  notafter=$(grep notAfter "$tmp" | sed 's/^notAfter=//')
  local end_epoch now days_left
  end_epoch=$(date -d "$notafter" +%s 2>/dev/null || echo 0)
  now=$(date +%s)
  days_left=$(((end_epoch - now) / 86400))

  kv "Not after" "$notafter"
  kv "Days left" "$days_left"

  if ((days_left < 0)); then
    kv "Status" "${c_err}EXPIRED${c_reset}"
  elif ((days_left < 30)); then
    kv "Status" "${c_warn}WARN (expiring soon)${c_reset}"
  else
    kv "Status" "${c_ok}OK${c_reset}"
  fi
  rm -f "$tmp"
}

tls_chain() {
  have openssl || die "openssl required"
  local host="" port=443
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --port)
      port="$2"
      shift
      ;;
    *) host="$1" ;;
    esac
    shift || true
  done
  [[ -z "$host" ]] && die "tls chain: host required"

  section "TLS Chain"
  kv "Host" "$host"
  kv "Port" "$port"

  _tls_s_client "$host" "$port" -showcerts |
    awk '
      /^subject=/ {sub(/^subject= */,""); s=$0}
      /^issuer=/  {sub(/^issuer= */,""); i=$0; print "[CERT]"; print "  Subject: "s; print "  Issuer : "i; print ""}
    ' || echo "  failed or no chain"
}

# -------------------- 6. Ports / Connections --------------------

require_ss_or_netstat() { have ss || have netstat || die "need ss or netstat"; }

port_cmd() {
  local sub="$1"
  shift || true
  case "$sub" in
  ls) port_ls "$@" ;;
  find) port_find "$@" ;;
  check) port_check "$@" ;;
  scan) port_scan "$@" ;;
  *) die "port: unknown subcommand '$sub'" ;;
  esac
}

port_ls() {
  require_ss_or_netstat
  local listening=0 tcp=0 udp=0 process=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --listening) listening=1 ;;
    --tcp) tcp=1 ;;
    --udp) udp=1 ;;
    --process) process=1 ;;
    esac
    shift || true
  done
  section "Listening ports"
  printf '%-5s %-24s %-24s %-6s %-s\n' "Proto" "Local" "Peer" "PID" "Process"
  if have ss; then
    local ss_args=(-nH)
    ((listening)) && ss_args+=(-l)
    ((tcp)) && ss_args+=(-t)
    ((udp)) && ss_args+=(-u)
    ((process)) && ss_args+=(-p)
    ss "${ss_args[@]}" 2>/dev/null | while read -r netid state recvq sendq local_addr peer_addr rest; do
      local pid="" comm=""
      if [[ "$rest" =~ pid=([0-9]+) ]]; then pid="${BASH_REMATCH[1]}"; fi
      if [[ "$rest" =~ \"([^\"]+)\" ]]; then comm="${BASH_REMATCH[1]}"; fi
      printf '%-5s %-24s %-24s %-6s %-s\n' "$netid" "$local_addr" "$peer_addr" "${pid:-?}" "${comm:-}"
    done
  else
    netstat -lntup
  fi
}

port_find() {
  require_ss_or_netstat
  local port="${1:-}" process=0
  [[ -z "$port" ]] && die "port find: port required"
  [[ "${2:-}" == "--process" ]] && process=1
  section "Port find :$port"
  printf '%-5s %-24s %-24s %-6s %-s\n' "Proto" "Local" "Peer" "PID" "Process"
  if have ss; then
    ss -nH -lntup 2>/dev/null | grep -E ":$port[[:space:]]" | \
      while read -r netid state recvq sendq local_addr peer_addr rest; do
        local pid="" comm=""
        if [[ "$rest" =~ pid=([0-9]+) ]]; then pid="${BASH_REMATCH[1]}"; fi
        if [[ "$rest" =~ \"([^\"]+)\" ]]; then comm="${BASH_REMATCH[1]}"; fi
        printf '%-5s %-24s %-24s %-6s %-s\n' "$netid" "$local_addr" "$peer_addr" "${pid:-?}" "${comm:-}"
      done
  else
    netstat -lntup | grep ":$port " || true
  fi
}

port_check() {
  local host="" port="" timeout=3 udp=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --timeout)
      timeout="$2"
      shift
      ;;
    --udp) udp=1 ;;
    *)
      if [[ -z "$host" ]]; then
        host="$1"
      elif [[ -z "$port" ]]; then
        port="$1"
      else
        die "Unexpected arg: $1"
      fi
      ;;
    esac
    shift || true
  done
  [[ -z "$host" || -z "$port" ]] && die "port check: host and port required"
  have nc || die "nc required"
  if ((udp)); then
    nc -z -u -w "$timeout" "$host" "$port" >/dev/null 2>&1 && echo "${c_ok}OK${c_reset}" || {
      echo "${c_err}FAIL${c_reset}"
      return 1
    }
  else
    nc -z -w "$timeout" "$host" "$port" >/dev/null 2>&1 && echo "${c_ok}OK${c_reset}" || {
      echo "${c_err}FAIL${c_reset}"
      return 1
    }
  fi
}

port_scan() {
  local host="" ports="80,443,3306"
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --ports)
      ports="$2"
      shift
      ;;
    *) host="$1" ;;
    esac
    shift || true
  done
  [[ -z "$host" ]] && die "port scan: host required"
  section "Port scan $host"
  for p in $(split_csv "$ports"); do
    printf '%-22s ' "$host:$p"
    if port_check "$host" "$p" --timeout 2 >/dev/null 2>&1; then
      echo "${c_ok}OPEN${c_reset}"
    else
      echo "${c_err}CLOSED${c_reset}"
    fi
  done
}

# Connections (with security-centric view)

conn_cmd() {
  local sub="$1"
  shift || true
  case "$sub" in
  ls) conn_ls "$@" ;;
  record) conn_record "$@" ;;
  summary) conn_summary "$@" ;;
  *) die "conn: unknown subcommand '$sub'" ;;
  esac
}

conn_ls() {
  require_ss_or_netstat
  local all=0 outbound=0 listening=0 suspicious=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --all) all=1 ;;
    --outbound) outbound=1 ;;
    --listening) listening=1 ;;
    --suspicious-only) suspicious=1 ;;
    esac
    shift || true
  done
  section "Connections"
  printf '%-3s %-5s %-22s %-22s %-10s %-6s %-8s %-s\n' "!" "Proto" "Local" "Remote" "State" "PID" "Risk" "Process"
  if have ss; then
    local args=(-nH -tunp)
    ((listening)) && args=(-nH -lntup)
    ss "${args[@]}" 2>/dev/null | while read -r netid state recvq sendq local_addr peer_addr rest; do
      local pid="" comm=""
      if [[ "$rest" =~ pid=([0-9]+) ]]; then pid="${BASH_REMATCH[1]}"; fi
      if [[ "$rest" =~ \"([^\"]+)\" ]]; then comm="${BASH_REMATCH[1]}"; fi

      if ((outbound)) && [[ "$state" != "ESTAB" && "$state" != "ESTABLISHED" ]]; then
        continue
      fi

      local score suspicious_flag=0 risk_tag=""
      score=$(suspicious_score "$netid" "$state" "$local_addr" "$peer_addr" "${pid:-}" "${comm:-}" 2>/dev/null || echo 0)
      if [[ "$score" =~ ^[0-9]+$ ]] && (( score >= 2 )); then
        suspicious_flag=1
        if (( score >= 3 )); then
          risk_tag="${c_err}HIGH${c_reset}"
        else
          risk_tag="${c_warn}MED${c_reset}"
        fi
      fi

      if ((suspicious)) && ((!suspicious_flag)); then
        continue
      fi

      local marker=" "
      local color=""
      if ((suspicious_flag)); then
        marker="${c_warn}*${c_reset}"
        color="${c_warn}"
      fi

      printf '%s %-5s %s%-22s %-22s %-10s %-6s %-8s %-s%s\n' \
        "$marker" "$netid" "$color" "$local_addr" "$peer_addr" "$state" "${pid:-?}" "$risk_tag" "${comm:-}" "${c_reset}"
    done
  else
    netstat -tunp
  fi
}

conn_record() {
  require_ss_or_netstat
  local interval=5 duration=120 out="$NETX_DIR/connections.log"
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --interval)
      interval="$2"
      shift
      ;;
    --duration)
      duration="$2"
      shift
      ;;
    --out)
      out="$2"
      shift
      ;;
    esac
    shift || true
  done
  local end=$((SECONDS + duration))
  : >"$out"
  while ((SECONDS < end)); do
    echo "### $(date -Is)" >>"$out"
    if have ss; then
      ss -tunp >>"$out" 2>/dev/null || true
    else
      netstat -tunp >>"$out" 2>/dev/null || true
    fi
    sleep "$interval"
  done
  echo "Recorded to $out"
}

conn_summary() {
  local file=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --file)
      file="$2"
      shift
      ;;
    esac
    shift || true
  done
  [[ -z "$file" ]] && die "conn summary: --file path required"
  [[ -f "$file" ]] || die "File not found: $file"
  section "Connection summary ($file)"
  echo "Unique remote endpoints:"
  grep -E 'ESTAB|ESTABLISHED' "$file" | awk '{print $6}' | sort -u | sed 's/^/  - /'
}

# -------------------- 7. Outbound Guard (security-focused) --------------------

guard_cmd() {
  local sub="$1"
  shift || true
  case "$sub" in
  snapshot) guard_snapshot "$@" ;;
  diff) guard_diff "$@" ;;
  watch) guard_watch "$@" ;;
  *) die "guard: unknown subcommand '$sub'" ;;
  esac
}

guard_file_default="$NETX_DIR/outbound_baseline.txt"

guard_snapshot() {
  require_ss_or_netstat
  local file="$guard_file_default"
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --file)
      file="$2"
      shift
      ;;
    esac
    shift || true
  done
  if have ss; then
    ss -tunp | normalize_conn_ss_line | sort -u >"$file"
  else
    netstat -tunp | normalize_conn_ss_line | sort -u >"$file"
  fi
  echo "Baseline saved to $file"
}

_guard_pretty_line() {
  local line="$1"
  IFS='|' read -r proto local remote pid comm user <<<"$line"
  printf '  %-5s %-22s -> %-22s %-6s %-s\n' "$proto" "$local" "$remote" "$pid" "$comm"
}

guard_diff() {
  require_ss_or_netstat
  local file="$guard_file_default"
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --file)
      file="$2"
      shift
      ;;
    esac
    shift || true
  done
  [[ -f "$file" ]] || die "Baseline file not found: $file"
  local tmp
  tmp=$(mktemp)
  if have ss; then
    ss -tunp | normalize_conn_ss_line | sort -u >"$tmp"
  else
    netstat -tunp | normalize_conn_ss_line | sort -u >"$tmp"
  fi
  section "New outbound connections since baseline (at $(date -Is))"
  local any=0
  while read -r line; do
    any=1
    _guard_pretty_line "$line"
  done < <(comm -13 "$file" "$tmp" || true)
  ((any == 0)) && echo "  (none)"
  rm -f "$tmp"
}

guard_watch() {
  require_ss_or_netstat
  local file="$guard_file_default" interval=20 exec_cmd=""
  local exclude_user="" exclude_port="" exclude_cidr=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --file)
      file="$2"
      shift
      ;;
    --interval)
      interval="$2"
      shift
      ;;
    --exclude-user)
      exclude_user="$2"
      shift
      ;;
    --exclude-port)
      exclude_port="$2"
      shift
      ;;
    --exclude-cidr)
      exclude_cidr="$2"
      shift
      ;;
    --exec)
      exec_cmd="$2"
      shift
      ;;
    esac
    shift || true
  done
  [[ -f "$file" ]] || guard_snapshot --file "$file"
  echo "Watching outbound connections every ${interval}s (baseline: $file)"
  while :; do
    local tmp
    tmp=$(mktemp)
    if have ss; then
      ss -tunp | normalize_conn_ss_line | sort -u >"$tmp"
    else
      netstat -tunp | normalize_conn_ss_line | sort -u >"$tmp"
    fi

    new=$(comm -13 "$file" "$tmp" || true)
    if [[ -n "$new" ]]; then
      section "${c_err}ALERT${c_reset} at $(date -Is)"

      while read -r line; do
        [[ -z "$line" ]] && continue
        IFS='|' read -r proto local remote pid comm user <<<"$line"
        local_port=${local##*:}
        remote_ip=${remote%:*}
        remote_port=${remote##*:}

        # Exclude by pseudo-user (really process name)
        if [[ -n "$exclude_user" ]]; then
          for e in $(split_csv "$exclude_user"); do
            [[ "$comm" == "$e" ]] && continue 2
          done
        fi
        # Exclude by port (local or remote)
        if [[ -n "$exclude_port" ]]; then
          for p in $(split_csv "$exclude_port"); do
            [[ "$local_port" == "$p" || "$remote_port" == "$p" ]] && continue 2
          done
        fi
        # Simple prefix-based CIDR-ish exclude (e.g. 10.,192.168.,172.16.)
        if [[ -n "$exclude_cidr" ]]; then
          for c in $(split_csv "$exclude_cidr"); do
            case "$remote_ip" in
            "$c"*) continue 2 ;;
            esac
          done
        fi

        _guard_pretty_line "$line"
      done <<<"$new"

      if [[ -n "$exec_cmd" ]]; then
        echo "$new" | eval "$exec_cmd" || true
      fi
    fi

    mv "$tmp" "$file"
    sleep "$interval"
  done
}

# -------------------- 8. Security / Suspicious listeners --------------------

sec_cmd() {
  local sub="$1"
  shift || true
  case "$sub" in
  listeners) sec_listeners "$@" ;;
  *) die "sec: unknown subcommand '$sub'" ;;
  esac
}

sec_listeners() {
  require_ss_or_netstat
  local ex_users="" ex_ports=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --exclude-user)
      ex_users="$2"
      shift
      ;;
    --exclude-port)
      ex_ports="$2"
      shift
      ;;
    esac
    shift || true
  done
  section "Suspicious listeners"
  if have ss; then
    ss -nH -lntup 2>/dev/null | while read -r netid state recvq sendq local_addr peer_addr rest; do
      local port pid="" comm=""
      port="${local_addr##*:}"
      if [[ "$rest" =~ pid=([0-9]+) ]]; then pid="${BASH_REMATCH[1]}"; fi
      if [[ "$rest" =~ \"([^\"]+)\" ]]; then comm="${BASH_REMATCH[1]}"; fi

      # skip excluded ports
      if [[ -n "$ex_ports" ]]; then
        for p in $(split_csv "$ex_ports"); do
          [[ "$p" == "$port" ]] && continue 2
        done
      fi
      # skip excluded "users" (actually process names)
      if [[ -n "$ex_users" ]]; then
        for u in $(split_csv "$ex_users"); do
          [[ "$comm" == "$u" ]] && continue 2
        done
      fi

      local path=""
      if [[ -n "$pid" && -e "/proc/$pid/exe" ]]; then
        path=$(readlink "/proc/$pid/exe" 2>/dev/null || true)
      fi

      local warn=0
      [[ "$local_addr" == "0.0.0.0"* || "$local_addr" == "[::]"* || "$local_addr" == "*:"* ]] && warn=1
      [[ "$port" -gt 1024 ]] && warn=1
      [[ "$path" == /tmp/* || "$path" == /dev/shm/* ]] && warn=1

      ((warn)) || continue
      printf '%s[WARN]%s %-5s %-22s pid=%-6s proc=%-15s path=%s\n' \
        "$c_warn" "$c_reset" "$netid" "$local_addr" "${pid:-?}" "${comm:-?}" "${path:-?}"
    done
  else
    netstat -lntup
  fi
}

# -------------------- 9. Sniff --------------------

sniff_cmd() {
  local mode="${1:-}"
  shift || true
  case "$mode" in
  http) sniff_http "$@" ;;
  pkt|packet) sniff_pkt "$@" ;;
  ""|help|-h|--help)
    cat <<'EOF'
Usage:
  netx sniff http <url> [curl-args...]
  netx sniff pkt <iface> [--count N] [--seconds N] [--write file.pcap]
                         [--no-resolve] [--verbose] [--snaplen N]
                         [--rotate MB] [--files N] [--promisc off]
                         [-- <bpf-filter...>]
EOF
    ;;
  *) die "sniff: unknown mode '$mode' (use: http | pkt)" ;;
  esac
}

sniff_http() {
  require_curl
  local url="${1:-}"
  [[ -n "$url" ]] || die "sniff http: url required"
  shift || true

  local timeout="${NETX_SNIFF_TIMEOUT:-20}"

  _mktemp_netx() { mktemp 2>/dev/null || mktemp -t netx; }

  local hdr body
  hdr="$(_mktemp_netx)"
  body="$(_mktemp_netx)"
  trap 'rm -f "$hdr" "$body"' RETURN

  echo "URL: $url"
  echo

  curl -k -L --max-time "$timeout" -sS \
    -D "$hdr" -o "$body" \
    "$@" "$url" \
    -w $'\n\n---- timing ----\nurl_effective: %{url_effective}\nremote_ip: %{remote_ip}\nremote_port: %{remote_port}\nhttp_code: %{http_code}\nhttp_version: %{http_version}\nssl_verify_result: %{ssl_verify_result}\ntime_namelookup: %{time_namelookup}\ntime_connect: %{time_connect}\ntime_appconnect: %{time_appconnect}\ntime_starttransfer: %{time_starttransfer}\ntime_total: %{time_total}\n' \
    || true

  echo
  echo "---- headers ----"
  cat "$hdr"

  echo
  echo "---- body ----"

  local ctype=""
  ctype="$(grep -i '^content-type:' "$hdr" | tail -n1 | sed -E 's/^[^:]+:[[:space:]]*//; s/\r$//' | tr '[:upper:]' '[:lower:]' || true)"

  if have jq; then
    if [[ "$ctype" == *"application/json"* ]] || jq -e . <"$body" >/dev/null 2>&1; then
      jq -C . <"$body" 2>/dev/null || sed -n '1,400p' "$body"
    else
      sed -n '1,400p' "$body"
    fi
  else
    sed -n '1,400p' "$body"
  fi
}

sniff_pkt() {
  local iface="${1:-}"
  [[ -n "$iface" ]] || die "sniff pkt: iface required"
  shift || true

  have tcpdump || die "sniff pkt: tcpdump required"

  local count="" seconds="" out="" noresolve=0 verbose=0 snaplen="96" rotate="" files="" promisc_on=1
  local -a filter=()

  while [[ "${1:-}" ]]; do
    case "$1" in
    --count) count="${2:-}"; shift 2 ;;
    --seconds) seconds="${2:-}"; shift 2 ;;
    --write) out="${2:-}"; shift 2 ;;
    --no-resolve) noresolve=1; shift ;;
    --verbose) verbose=1; shift ;;
    --snaplen) snaplen="${2:-}"; shift 2 ;;
    --rotate) rotate="${2:-}"; shift 2 ;;
    --files) files="${2:-}"; shift 2 ;;
    --promisc)
      [[ "${2:-}" == "off" ]] && promisc_on=0 || promisc_on=1
      shift 2
      ;;
    --) shift; break ;;
    *) break ;;
    esac
  done

  while [[ "${1:-}" ]]; do filter+=("$1"); shift; done

  local SUDO=""
  if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    have sudo || die "sniff pkt: need root or sudo"
    SUDO="sudo"
  fi

  local -a args=(tcpdump -i "$iface" -s "$snaplen")
  ((noresolve)) && args+=(-n)
  ((verbose)) && args+=(-vv)
  ((promisc_on==0)) && args+=(-p)
  [[ -n "$count" ]] && args+=(-c "$count")
  [[ -n "$out" ]] && args+=(-w "$out")

  if [[ -n "$rotate" ]]; then
    args+=(-C "$rotate")
    [[ -n "$files" ]] && args+=(-W "$files")
  fi

  if [[ -n "$seconds" ]] && have timeout; then
    args=(timeout "$seconds" "${args[@]}")
  fi

  ((${#filter[@]})) && args+=("${filter[@]}")

  echo "Running: ${SUDO:+$SUDO }${args[*]}" >&2
  exec ${SUDO:+$SUDO } "${args[@]}"
}

# -------------------- 9. IP / Interface / Routes --------------------

ip_cmd() {
  local sub="$1"
  shift || true
  case "$sub" in
  info) ip_info ;;
  public) ip_public "$@" ;;
  *) die "ip: unknown subcommand '$sub'" ;;
  esac
}

ip_info() {
  have ip || die "ip command required"
  section "Interfaces"
  ip -o addr show | awk '
    {
      iface=$2; fam=$3; addr=$4;
      sub(/\/.*/,"",addr);
      if (fam=="inet")  ipv4[iface]=(ipv4[iface] ? ipv4[iface]", "addr : addr);
      if (fam=="inet6") ipv6[iface]=(ipv6[iface] ? ipv6[iface]", "addr : addr);
    }
    END {
      printf "%-15s %-30s %-40s\n", "Interface","IPv4","IPv6";
      for (i in ipv4) {
        printf "%-15s %-30s %-40s\n", i, ipv4[i], ipv6[i];
      }
      for (i in ipv6) if (!(i in ipv4)) {
        printf "%-15s %-30s %-40s\n", i, "", ipv6[i];
      }
    }
  '
  section "Default route"
  ip route show default | sed 's/^/  /'
  section "DNS"
  dns_system
}

ip_public() {
  require_curl
  local want4=0 want6=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --ipv4) want4=1 ;;
    --ipv6) want6=1 ;;
    esac
    shift || true
  done
  ((!want4 && !want6)) && {
    want4=1
    want6=1
  }
  section "Public IP"
  if ((want4)); then
    local ip4
    ip4=$(curl -s https://api.seeip.org/jsonip 2>/dev/null | sed -n 's/.*"ip":"\([^"]*\)".*/\1/p')
    [[ -z "$ip4" ]] && ip4=$(curl -s https://ipv4.icanhazip.com 2>/dev/null)
    kv "IPv4" "${ip4:-failed}"
  fi
  if ((want6)); then
    local ip6
    ip6=$(curl -s "https://api.seeip.org/jsonip?format=json" 2>/dev/null | sed -n 's/.*"ip":"\([^"]*\)".*/\1/p')
    [[ -z "$ip6" ]] && ip6=$(curl -s https://ipv6.icanhazip.com 2>/dev/null)
    kv "IPv6" "${ip6:-failed}"
  fi
}

if_cmd() {
  local sub="$1"
  shift || true
  case "$sub" in
  ls) if_ls ;;
  stats) if_stats "$@" ;;
  *) die "if: unknown subcommand '$sub'" ;;
  esac
}

if_ls() {
  have ip || die "ip required"
  section "Interfaces"
  printf '%-6s %-20s %-25s\n' "Index" "Name" "IPv4 (primary)"

  # Build IPv4 map: primary CIDR + extra count per interface
  declare -A primary_ipv4
  declare -A extra_ipv4

  while read -r _ ifname fam addr _; do
    [[ "$fam" != "inet" ]] && continue
    cidr="$addr"
    if [[ -z "${primary_ipv4[$ifname]:-}" ]]; then
      primary_ipv4[$ifname]="$cidr"
      extra_ipv4[$ifname]=0
    else
      extra_ipv4[$ifname]=$(( ${extra_ipv4[$ifname]} + 1 ))
    fi
  done < <(ip -o -4 addr show 2>/dev/null)

  # Print all interfaces with primary IPv4 (if any)
  while read -r idx name; do
    local p extra=""
    p="${primary_ipv4[$name]:-}"
    if [[ -n "${extra_ipv4[$name]:-}" && ${extra_ipv4[$name]} -gt 0 ]]; then
      extra=" (+${extra_ipv4[$name]})"
    fi
    printf '  %-6s %-20s %-25s\n' "$idx" "$name" "${p}${extra}"
  done < <(ip -o link show | awk -F': ' '{gsub(/@.*/,"",$2); print $1, $2}')
}

if_stats() {
  have ip || die "ip required"
  local iface="${1:-}"
  [[ -z "$iface" ]] && die "if stats: iface required"
  section "Interface stats: $iface"
  ip -s link show "$iface"
}

route_cmd() {
  local sub="$1"
  shift || true
  case "$sub" in
  show) route_show ;;
  explain) route_explain "$@" ;;
  *) die "route: unknown subcommand '$sub'" ;;
  esac
}

route_show() {
  have ip || die "ip required"
  section "Routes"
  printf '%-8s %-20s %-12s %-s\n' "Type" "Destination" "Dev" "Extra"
  ip route show | while read -r dst rest; do
    dev=$(grep -o 'dev [^ ]*' <<<"$rest" | awk '{print $2}')
    extra=$(sed "s/.*dev $dev//" <<<"$rest")
    typ="other"
    [[ "$dst" == "default" ]] && typ="default"
    printf '%-8s %-20s %-12s %-s\n' "$typ" "$dst" "$dev" "$extra"
  done
route_explain() {
  local target="${1:-}"
  [[ -n "$target" ]] || die "route explain: host required"

  have ip || die "route explain: ip required"

  local ip_addr=""
  if have dig; then
    ip_addr=$(dig +short "$target" A 2>/dev/null | head -n1 || true)
    [[ -z "$ip_addr" ]] && ip_addr=$(dig +short "$target" AAAA 2>/dev/null | head -n1 || true)
  fi
  if [[ -z "$ip_addr" ]] && have getent; then
    ip_addr=$(getent ahostsv4 "$target" 2>/dev/null | awk 'NR==1{print $1}' || true)
    [[ -z "$ip_addr" ]] && ip_addr=$(getent ahostsv6 "$target" 2>/dev/null | awk 'NR==1{print $1}' || true)
  fi
  [[ -z "$ip_addr" ]] && ip_addr="$target"

  local out
  out=$(ip route get "$ip_addr" 2>/dev/null || true)

  if ((NETX_QUIET)); then
    local dev
    dev=$(grep -oE ' dev [^ ]+' <<<"$out" | awk '{print $2}' || true)
    [[ -n "$dev" ]] && { echo "$dev"; return 0; }
    echo "$out"
    return 0
  fi

  if ((NETX_JSON)); then
    NETX_JSON_NATIVE=1
    local dev gw src
    dev=$(grep -oE ' dev [^ ]+' <<<"$out" | awk '{print $2}' || true)
    gw=$(grep -oE ' via [^ ]+' <<<"$out" | awk '{print $2}' || true)
    src=$(grep -oE ' src [^ ]+' <<<"$out" | awk '{print $2}' || true)
    printf '{"target":"%s","ip":"%s","dev":"%s","via":"%s","src":"%s","raw":"%s"}\n' \
      "$target" "$ip_addr" "${dev:-}" "${gw:-}" "${src:-}" "$(printf '%s' "$out" | sed 's/"/\\"/g')"
    return 0
  fi

  section "Route explain"
  kv "Target" "$target"
  kv "Resolved IP" "$ip_addr"
  if [[ -z "$out" ]]; then
    echo "  ${c_err}No route found${c_reset}"
    return 1
  fi
  echo "  $out"
  local dev gw src
  dev=$(grep -oE ' dev [^ ]+' <<<"$out" | awk '{print $2}' || true)
  gw=$(grep -oE ' via [^ ]+' <<<"$out" | awk '{print $2}' || true)
  src=$(grep -oE ' src [^ ]+' <<<"$out" | awk '{print $2}' || true)
  [[ -n "$dev" ]] && kv "Interface" "$dev"
  [[ -n "$gw" ]] && kv "Gateway" "$gw"
  [[ -n "$src" ]] && kv "Source IP" "$src"
}

}

# -------------------- 10. Watchers / Waiters --------------------

watch_cmd() {
  local sub="$1"
  shift || true
  case "$sub" in
  ping) watch_ping "$@" ;;
  http) watch_http "$@" ;;
  *) die "watch: unknown subcommand '$sub'" ;;
  esac
}

watch_ping() {
  have ping || die "ping required"
  local host="" interval=1
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --interval)
      interval="$2"
      shift
      ;;
    *) host="$1" ;;
    esac
    shift || true
  done
  [[ -z "$host" ]] && die "watch ping: host required"
  while :; do
    section "Ping $(date -Is) -> $host"
    ping -c 3 -W 2 "$host" || true
    sleep "$interval"
  done
}

watch_http() {
  require_curl
  local url="" interval=5 expect=200
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --interval)
      interval="$2"
      shift
      ;;
    --expect-status)
      expect="$2"
      shift
      ;;
    *) url="$1" ;;
    esac
    shift || true
  done
  [[ -z "$url" ]] && die "watch http: url required"
  while :; do
    local code
    code=$(curl -sS -o /dev/null -w '%{http_code}' "$url" || echo 0)
    printf '%s status=%s (expect %s)\n' "$(date -Is)" "$code" "$expect"
    sleep "$interval"
  done
}

wait_cmd() {
  local sub="$1"
  shift || true
  case "$sub" in
  port) wait_port "$@" ;;
  *) die "wait: unknown subcommand '$sub'" ;;
  esac
}

wait_port() {
  local host="" port="" timeout=60
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --timeout)
      timeout="$2"
      shift
      ;;
    *)
      if [[ -z "$host" ]]; then
        host="$1"
      elif [[ -z "$port" ]]; then
        port="$1"
      else
        die "Unexpected arg: $1"
      fi
      ;;
    esac
    shift || true
  done
  [[ -z "$host" || -z "$port" ]] && die "wait port: host and port required"
  have nc || die "nc required"
  local end=$((SECONDS + timeout))
  while ((SECONDS < end)); do
    if nc -z -w 2 "$host" "$port" >/dev/null 2>&1; then
      echo "Port $host:$port is ${c_ok}up${c_reset}"
      return 0
    fi
    sleep 1
  done
  echo "Timed out waiting for $host:$port"
  return 1
}

# -------------------- 11. Stack check --------------------

stack_cmd() {
  local sub="$1"
  shift || true
  case "$sub" in
  check) stack_check "$@" ;;
  *) die "stack: unknown subcommand '$sub'" ;;
  esac
}

stack_check() {
  local name="" cfg=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --config)
      cfg="$2"
      shift
      ;;
    *) name="$1" ;;
    esac
    shift || true
  done
  [[ -z "$name" ]] && die "stack check: name required"
  if [[ -z "$cfg" ]]; then
    local dir="${NETX_STACK_DIR:-$HOME/.config/netx/stacks}"
    cfg="$dir/${name}.conf"
  fi
  [[ -f "$cfg" ]] || die "stack config not found: $cfg"

  section "Stack: $name"
  kv "Config" "$cfg"
  awk -F'=' '
    /^\[services\]/ {in_s=1; next}
    /^\[/ {in_s=0; next}
    in_s && $1!="" {
      gsub(/[[:space:]]+/,"",$1);
      gsub(/^[[:space:]]+|[[:space:]]+$/,"",$2);
      print $1,$2
    }
  ' "$cfg" | while read -r svc target; do
    if [[ "$target" =~ ^https?:// ]]; then
      printf "[HTTP] %-12s %s -> " "$svc" "$target"
      http_trace "$target" 2>/dev/null || echo "failed"
    else
      host=${target%:*}
      port=${target##*:}
      printf "[TCP ] %-12s %s:%s -> " "$svc" "$host" "$port"
      if port_check "$host" "$port" --timeout 2 >/dev/null 2>&1; then
        echo "${c_ok}OK${c_reset}"
      else
        echo "${c_err}FAIL${c_reset}"
      fi
    fi
  done
}

# -------------------- 12. Namespaces --------------------

ns_cmd() {
  local sub="$1"
  shift || true
  case "$sub" in
  ls) ns_ls ;;
  inspect) ns_inspect "$@" ;;
  exec) ns_exec "$@" ;;
  *) die "ns: unknown subcommand '$sub'" ;;
  esac
}

ns_ls() {
  have ip || die "ip required"
  section "Network namespaces"
  local out
  out=$(ip netns list 2>/dev/null || true)
  if [[ -z "$out" ]]; then
    echo "  (none)"
  else
    echo "$out" | sed 's/^/  /'
  fi
}

ns_inspect() {
  have ip || die "ip required"
  local ns="${1:-}"
  [[ -z "$ns" ]] && die "ns inspect: ns required"
  section "Namespace $ns - interfaces"
  if ! ip netns exec "$ns" ip -o addr show 2>/dev/null; then
    echo "  Cannot open network namespace '$ns'"
    echo "  Hint: this expects a netns name (from 'ip netns ls'), not an interface like 'wlp0s20f3'."
    return 1
  fi
  section "Namespace $ns - routes"
  ip netns exec "$ns" ip route show | sed 's/^/  /'
}

ns_exec() {
  have ip || die "ip required"
  local ns="${1:-}"
  shift || true
  [[ -z "$ns" ]] && die "ns exec: ns required"
  [[ $# -eq 0 ]] && die "ns exec: command required"
  ip netns exec "$ns" "$@"
}

# -------------------- 13. Path trace --------------------

path_cmd() {
  local sub="$1"
  shift || true
  case "$sub" in
  trace) path_trace "$@" ;;
  *) die "path: unknown subcommand '$sub'" ;;
  esac
}

path_trace() {
  local host="" max_hops=15
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --max-hops)
      max_hops="$2"
      shift
      ;;
    *) host="$1" ;;
    esac
    shift || true
  done
  [[ -z "$host" ]] && die "path trace: host required"
  section "Path trace to $host (max $max_hops hops)"
  if have mtr; then
    mtr -n -c 3 -r -m "$max_hops" "$host"
  elif have traceroute; then
    traceroute -n -m "$max_hops" "$host"
  else
    die "path trace: need mtr or traceroute"
  fi
}

# -------------------- 14. Firewall --------------------

fw_cmd() {
  local sub="$1"
  shift || true
  case "$sub" in
  summary) fw_summary ;;
  list) fw_list "$@" ;;
  *) die "fw: unknown subcommand '$sub'" ;;
  esac
}

fw_summary() {
  section "Firewall summary"
  if have nft; then
    local out
    out=$(nft list ruleset 2>/dev/null || true)
    if [[ -z "$out" ]]; then
      echo "  nftables present but no rules (or insufficient permissions)"
    else
      echo "$out" | head -n 80 | sed 's/^/  /'
      local lines
      lines=$(printf '%s\n' "$out" | wc -l | awk '{print $1}')
      if ((lines > 80)); then
        echo "  ... (truncated, use 'netx fw list --raw' for full ruleset)"
      fi
    fi
  elif have iptables; then
    iptables -L -n --line-numbers | sed 's/^/  /'
  else
    echo "  No nftables/iptables found"
  fi
  if have ufw; then
    section "UFW status"
    ufw status 2>/dev/null | sed 's/^/  /'
  fi
}

fw_list() {
  local raw=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --raw) raw=1 ;;
    esac
    shift || true
  done
  section "Firewall rules"
  if have nft; then
    if ((raw)); then
      nft list ruleset
    else
      nft list ruleset | sed 's/^/  /'
    fi
  elif have iptables; then
    if ((raw)); then
      iptables-save
    else
      iptables -S | sed 's/^/  /'
    fi
  else
    echo "  No nftables/iptables found"
  fi
}

# -------------------- 15. Net report --------------------

report_cmd() {
  local out="$NETX_DIR/net-report.txt"
  while [[ $# -gt 0 ]]; do
    case "$1" in
    --out)
      out="$2"
      shift
      ;;
    esac
    shift || true
  done
  {
    echo "netx report $(date -Is)"
    ip_info || true
    route_show || true
    dns_system || true
    section "Listening ports (tcp)"
    port_ls --listening --tcp --process || true
    conn_ls --outbound || true
  } >"$out"
  echo "Report saved to $out"
}

# -------------------- Main dispatcher --------------------

dispatch_cmd() {
  local cmd="$1"; shift || true
  case "$cmd" in
  -h | --help | help) usage ;;
  --version | -V) echo "netx $VERSION" ;;

  doctor) doctor_cmd "$@" ;;

  dns)
    [[ $# -gt 0 ]] || die "dns subcommand required"
    dns_cmd "$@"
    ;;
  http)
    [[ $# -gt 0 ]] || die "http subcommand required"
    http_cmd "$@"
    ;;
  proxy)
    [[ $# -gt 0 ]] || die "proxy subcommand required"
    proxy_cmd "$@"
    ;;
  bench)
    [[ $# -gt 0 ]] || die "bench subcommand required"
    bench_cmd "$@"
    ;;

  tls)
    [[ $# -gt 0 ]] || die "tls subcommand required"
    tls_cmd "$@"
    ;;

  sniff)
    [[ $# -gt 0 ]] || die "sniff mode required"
    sniff_cmd "$@"
    ;;

  port)
    [[ $# -gt 0 ]] || die "port subcommand required"
    port_cmd "$@"
    ;;
  conn)
    [[ $# -gt 0 ]] || die "conn subcommand required"
    conn_cmd "$@"
    ;;
  guard)
    [[ $# -gt 0 ]] || die "guard subcommand required"
    guard_cmd "$@"
    ;;
  sec)
    [[ $# -gt 0 ]] || die "sec subcommand required"
    sec_cmd "$@"
    ;;

  ip)
    [[ $# -gt 0 ]] || die "ip subcommand required"
    ip_cmd "$@"
    ;;
  if)
    [[ $# -gt 0 ]] || die "if subcommand required"
    if_cmd "$@"
    ;;
  route)
    [[ $# -gt 0 ]] || die "route subcommand required"
    route_cmd "$@"
    ;;

  watch)
    [[ $# -gt 0 ]] || die "watch subcommand required"
    watch_cmd "$@"
    ;;
  wait)
    [[ $# -gt 0 ]] || die "wait subcommand required"
    wait_cmd "$@"
    ;;

  stack)
    [[ $# -gt 0 ]] || die "stack subcommand required"
    stack_cmd "$@"
    ;;

  ns)
    [[ $# -gt 0 ]] || die "ns subcommand required"
    ns_cmd "$@"
    ;;

  path)
    [[ $# -gt 0 ]] || die "path subcommand required"
    path_cmd "$@"
    ;;

  trace)
    path_trace "$@"
    ;;

  fw)
    [[ $# -gt 0 ]] || die "fw subcommand required"
    fw_cmd "$@"
    ;;

  report) report_cmd "$@" ;;

  *) die "Unknown command: $cmd" ;;
  esac
}


main() {
  # Global flags
  NETX_JSON=0
  NETX_QUIET=0
  NETX_JSON_NATIVE=0
  while [[ "${1:-}" == --* ]]; do
    case "$1" in
    --json) NETX_JSON=1; NETX_COLOR="never"; shift ;;
    --quiet) NETX_QUIET=1; shift ;;
    --) shift; break ;;
    *) break ;;
    esac
  done

  local cmd="${1:-}"
  [[ -z "$cmd" ]] && { usage; exit 1; }
  shift || true

  # Stream/interactive commands should not be captured/wrapped
  local stream=0
  case "$cmd" in
    sniff|watch|wait) stream=1 ;;
    guard) [[ "${1:-}" == "watch" ]] && stream=1 || true ;;
  esac

  if ((NETX_JSON)) && ((stream==0)); then
    local out errf rc
    out="$(mktemp 2>/dev/null || mktemp -t netx)"
    errf="$(mktemp 2>/dev/null || mktemp -t netx)"
    NETX_JSON_NATIVE=0
    dispatch_cmd "$cmd" "$@" >"$out" 2>"$errf" || rc=$?
    rc="${rc:-0}"

    if ((NETX_JSON_NATIVE)); then
      cat "$out"
    else
      printf '{'
      printf '"ok":%s,' "$([[ "$rc" -eq 0 ]] && echo true || echo false)"
      printf '"exit_code":%s,' "$rc"
      printf '"cmd":"%s",' "$(printf '%s' "$cmd" | json_escape)"
      printf '"stdout":"%s",' "$(cat "$out" | json_escape)"
      printf '"stderr":"%s"' "$(cat "$errf" | json_escape)"
      printf '}
'
    fi
    rm -f "$out" "$errf"
    return "$rc"
  fi

  dispatch_cmd "$cmd" "$@"
}


main "$@"
