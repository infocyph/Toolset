#!/usr/bin/env bash
# netx - Network toolbox for diagnostics, security and benchmarks
set -euo pipefail

VERSION="0.1.0"

# -------------------- Helpers --------------------

have() { command -v "$1" >/dev/null 2>&1; }

err()  { printf 'netx: %s\n' "$*" >&2; }
die()  { err "$@"; exit 1; }

usage() {
  cat <<'EOF'
Usage: netx <command> [subcommand] [options]

Core:
  netx doctor <host> [--port P] [--http] [--tls] [--raw]

DNS:
  netx dns resolve <name> [--type T] [--resolver IP]
  netx dns dump <name> [--full]
  netx dns compare <name> [--type T] [--resolver ip1,ip2,...]
  netx dns trace <name> [--type T]
  netx dns reverse <ip>
  netx dns system
  netx dns hosts <host>

HTTP / Proxy:
  netx http get <url> [--headers] [--body] [--json] [--timeout N]
  netx http head <url> [--timeout N]
  netx http trace <url> [--timeout N]
  netx proxy env
  netx proxy test <url>

Benchmark (curl only):
  netx bench http <url> [--requests N] [--concurrency N] [--timeout N]
  netx bench ping <host> [--count N]

TLS:
  netx tls info <host> [--port P]
  netx tls verify <host> [--port P] [--strict]
  netx tls chain <host> [--port P]

Ports / Connections:
  netx port ls [--listening] [--tcp] [--udp] [--process]
  netx port find <port> [--process]
  netx port check <host> <port> [--timeout N] [--udp]
  netx port scan <host> [--ports 80,443,3306]

  netx conn ls [--all] [--outbound] [--listening] [--suspicious-only]
  netx conn record [--interval N] [--duration N] [--out file]
  netx conn summary [--file file]

Outbound Guard:
  netx guard snapshot [--file path]
  netx guard diff [--file path]
  netx guard watch [--interval N] [--file path]
                    [--exclude-user list] [--exclude-port list]
                    [--exclude-cidr list] [--exec cmd]

Security / Suspicious Listeners:
  netx sec listeners [--exclude-user list] [--exclude-port list]

IP / Interfaces / Routes:
  netx ip info
  netx ip public [--ipv4] [--ipv6]
  netx if ls
  netx if stats <iface>
  netx route show

Watchers / Waiters:
  netx watch ping <host> [--interval N] [--loss-threshold PCT]
  netx watch http <url> [--interval N] [--expect-status CODE]
  netx wait port <host> <port> [--timeout N]

Stacks:
  netx stack check <name>

Namespaces:
  netx ns ls
  netx ns inspect <ns>
  netx ns exec <ns> <cmd...>

Path / Firewall / Report:
  netx path trace <host> [--max-hops N]
  netx fw summary
  netx fw list [--raw]
  netx report [--out file]

EOF
}

# Default config paths
NETX_DIR="${HOME}/.netx"
mkdir -p "$NETX_DIR"

# -------------------- Low-level utility helpers --------------------

normalize_conn_ss_line() {
  # Input: full ss -tunp line
  # Output key: proto|local|remote|pid|comm|user
  # shellcheck disable=SC2016
  awk '
    {
      proto=$1
      local=$5
      remote=$6
      pid="?"
      comm="?"
      user="?"
      # users:((("pid","program"))), but format can vary
      for (i=1;i<=NF;i++) {
        if ($i ~ /users:\(\(".*.*/ ) {
          gsub(/users:\(\("/, "", $i)
          gsub(/"\)\)/, "", $i)
          split($i, a, ",")
          comm=a[1]
          # pid=... is often separate field
        }
        if ($i ~ /pid=/) {
          sub(/pid=/, "", $i)
          pid=$i
        }
        if ($i ~ /uid=/) {
          # we could map uid->user via getent, but too heavy here
          # leave uid as-is or try id -nu
          sub(/uid=/,"",$i)
          uid=$i
        }
      }
      print proto"|"local"|"remote"|"pid"|"comm"|"user
    }
  '
}

is_private_ip() {
  local ip="$1"
  case "$ip" in
    10.*|192.168.*|172.16.*|172.17.*|172.18.*|172.19.*|172.2[0-9].*|172.3[0-1].*)
      return 0 ;;
    127.*) return 0 ;;
    ::1|fc*|fd*|fe80:*) return 0 ;;
  esac
  return 1
}

split_csv() { # split "a,b,c" to lines
  tr ',' '\n' <<<"$1"
}

now_ms() {
  # Needs date +%s%3N
  date +%s%3N 2>/dev/null || python - "$@" <<'PY'
import time,sys
print(int(time.time()*1000))
PY
}

# -------------------- 1. Doctor --------------------

doctor_cmd() {
  local host="" port=443 do_http=0 do_tls=0 raw=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --port) port="$2"; shift;;
      --http) do_http=1;;
      --tls)  do_tls=1;;
      --raw)  raw=1;;
      *)
        if [[ -z "$host" ]]; then host="$1"; else die "Unexpected arg: $1"; fi
        ;;
    esac
    shift || true
  done
  [[ -z "$host" ]] && die "doctor: host required"

  echo "== netx doctor: $host:$port =="

  # DNS
  local dns_start dns_end dns_ms
  dns_start=$(now_ms)
  local dns_out="" dns_tool=""
  if have dig; then
    dns_tool="dig"
    dns_out=$(dig +short "$host" A 2>/dev/null | head -n 3)
  elif have getent; then
    dns_tool="getent"
    dns_out=$(getent ahostsv4 "$host" 2>/dev/null | awk '{print $1}' | head -n 3)
  else
    dns_tool="getent"
    dns_out=$(getent hosts "$host" 2>/dev/null | awk '{print $1}' | head -n 3)
  fi
  dns_end=$(now_ms)
  dns_ms=$((dns_end - dns_start))
  if [[ -n "$dns_out" ]]; then
    echo "[DNS] ($dns_tool, ${dns_ms}ms):"
    echo "$dns_out"
  else
    echo "[DNS] FAILED ($dns_tool, ${dns_ms}ms)"
  fi

  # Ping (best-effort)
  if have ping; then
    local ping_line
    ping_line=$(ping -c 3 -W 2 "$host" 2>/dev/null | tail -n 1)
    echo "[PING] $ping_line"
  else
    echo "[PING] ping not available"
  fi

  # Route (traceroute minimal)
  if have traceroute; then
    echo "[ROUTE] (first 3 hops)"
    traceroute -n -m 10 "$host" 2>/dev/null | head -n 4
  else
    echo "[ROUTE] traceroute not available"
  fi

  # Port check
  if have nc; then
    if nc -z -w 3 "$host" "$port" 2>/dev/null; then
      echo "[PORT] $host:$port reachable"
    else
      echo "[PORT] $host:$port NOT reachable"
    fi
  else
    echo "[PORT] nc not available"
  fi

  # HTTP
  if (( do_http )); then
    if ! have curl; then
      echo "[HTTP] curl not available"
    else
      echo "[HTTP]"
      curl -sS -o /dev/null -w '  status=%{http_code} time_total=%{time_total}s size=%{size_download}B redirect=%{num_redirects}\n' \
        --max-time 10 "http://$host:$port" || echo "  HTTP request failed"
    fi
  fi

  # TLS
  if (( do_tls )) || [[ "$port" -eq 443 ]]; then
    if have openssl; then
      echo "[TLS]"
      echo | openssl s_client -servername "$host" -connect "$host:$port" 2>/dev/null \
        | openssl x509 -noout -subject -issuer -dates || echo "  TLS info failed"
    else
      echo "[TLS] openssl not available"
    fi
  fi

  (( raw )) && echo "[RAW] doctor completed"
}

# -------------------- 2. DNS --------------------

dns_cmd() {
  local sub="$1"; shift || true
  case "$sub" in
    resolve) dns_resolve "$@";;
    dump)    dns_dump "$@";;
    compare) dns_compare "$@";;
    trace)   dns_trace "$@";;
    reverse) dns_reverse "$@";;
    system)  dns_system;;
    hosts)   dns_hosts "$@";;
    *) die "dns: unknown subcommand '$sub'";;
  esac
}

dns_resolve() {
  local name="" type="A" resolver=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --type) type="$2"; shift;;
      --resolver) resolver="$2"; shift;;
      *) name="$1";;
    esac
    shift || true
  done
  [[ -z "$name" ]] && die "dns resolve: name required"
  if have dig; then
    if [[ -n "$resolver" ]]; then
      dig @"$resolver" "$name" "$type" +short
    else
      dig "$name" "$type" +short
    fi
  elif have host; then
    host "$name"
  else
    die "dns: need dig or host"
  fi
}

dns_dump() {
  local name="" full=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --full) full=1;;
      *) name="$1";;
    esac
    shift || true
  done
  [[ -z "$name" ]] && die "dns dump: name required"
  local types="A AAAA CNAME MX NS TXT"
  [[ $full -eq 1 ]] && types="A AAAA CNAME MX NS TXT SRV"
  for t in $types; do
    echo "[$t]"
    dns_resolve "$name" --type "$t" || true
    echo
  done
}

dns_compare() {
  local name="" type="A" resolvers=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --type) type="$2"; shift;;
      --resolver) resolvers="$2"; shift;;
      *) name="$1";;
    esac
    shift || true
  done
  [[ -z "$name" ]] && die "dns compare: name required"
  [[ -z "$resolvers" ]] && resolvers="1.1.1.1,8.8.8.8,9.9.9.9"
  for r in $(split_csv "$resolvers"); do
    echo "Resolver $r:"
    dns_resolve "$name" --type "$type" --resolver "$r" || echo "  (failed)"
    echo
  done
}

dns_trace() {
  local name="" type="A"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --type) type="$2"; shift;;
      *) name="$1";;
    esac
    shift || true
  done
  [[ -z "$name" ]] && die "dns trace: name required"
  if have dig; then
    dig "$name" "$type" +trace
  else
    die "dns trace: dig required"
  fi
}

dns_reverse() {
  local ip="${1:-}"
  [[ -z "$ip" ]] && die "dns reverse: ip required"
  if have dig; then
    dig -x "$ip" +short
  elif have host; then
    host "$ip"
  else
    die "dns reverse: dig or host required"
  fi
}

dns_system() {
  echo "[/etc/resolv.conf]"
  [[ -f /etc/resolv.conf ]] && sed 's/^/  /' /etc/resolv.conf || echo "  not found"
  if have systemd-resolve; then
    echo
    echo "[systemd-resolve --status]"
    systemd-resolve --status 2>/dev/null | sed 's/^/  /'
  fi
}

dns_hosts() {
  local host="${1:-}"
  [[ -z "$host" ]] && die "dns hosts: host required"
  if [[ -f /etc/hosts ]]; then
    grep -iE "[[:space:]]$host([[:space:]]|\$)" /etc/hosts || echo "No entry for $host"
  else
    echo "/etc/hosts not found"
  fi
}

# -------------------- 3. HTTP / Proxy --------------------

http_cmd() {
  local sub="$1"; shift || true
  case "$sub" in
    get)   http_get "$@";;
    head)  http_head "$@";;
    trace) http_trace "$@";;
    *) die "http: unknown subcommand '$sub'";;
  esac
}

require_curl() { have curl || die "curl required"; }

http_get() {
  require_curl
  local url="" headers=0 body=0 json=0 timeout=5
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --headers) headers=1;;
      --body)    body=1;;
      --json)    json=1;;
      --timeout) timeout="$2"; shift;;
      *) url="$1";;
    esac
    shift || true
  done
  [[ -z "$url" ]] && die "http get: url required"

  local curl_args=(-sS --max-time "$timeout")
  (( headers )) && curl_args+=(-D -)
  (( json )) && curl_args+=(-H 'Accept: application/json')
  if (( body )); then
    curl "${curl_args[@]}" "$url"
  else
    curl "${curl_args[@]}" -o /dev/null -w 'status=%{http_code} time_total=%{time_total}s size=%{size_download}B redirect=%{num_redirects}\n' "$url"
  fi
}

http_head() {
  require_curl
  local url="" timeout=5
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --timeout) timeout="$2"; shift;;
      *) url="$1";;
    esac
    shift || true
  done
  [[ -z "$url" ]] && die "http head: url required"
  curl -sS -I --max-time "$timeout" "$url"
}

http_trace() {
  require_curl
  local url="" timeout=5
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --timeout) timeout="$2"; shift;;
      *) url="$1";;
    esac
    shift || true
  done
  [[ -z "$url" ]] && die "http trace: url required"

  curl -sS -o /dev/null --max-time "$timeout" \
    -w 'dns=%{time_namelookup}s connect=%{time_connect}s tls=%{time_appconnect}s ttfb=%{time_starttransfer}s total=%{time_total}s status=%{http_code} size=%{size_download}B redirect=%{num_redirects}\n' \
    "$url"
}

proxy_cmd() {
  local sub="$1"; shift || true
  case "$sub" in
    env) proxy_env;;
    test) proxy_test "$@";;
    *) die "proxy: unknown subcommand '$sub'";;
  esac
}

proxy_env() {
  echo "HTTP_PROXY=${HTTP_PROXY:-}"
  echo "HTTPS_PROXY=${HTTPS_PROXY:-}"
  echo "NO_PROXY=${NO_PROXY:-${no_proxy:-}}"
}

proxy_test() {
  require_curl
  local url="${1:-}"
  [[ -z "$url" ]] && die "proxy test: url required"
  echo "[Direct]"
  NO_PROXY="*" no_proxy="*" curl -sS -o /dev/null -w 'status=%{http_code} time=%{time_total}s\n' "$url" || echo "  failed"
  echo
  echo "[Proxy env]"
  curl -sS -o /dev/null -w 'status=%{http_code} time=%{time_total}s\n' "$url" || echo "  failed"
}

# -------------------- 4. Benchmarks (curl only) --------------------

bench_cmd() {
  local sub="$1"; shift || true
  case "$sub" in
    http) bench_http "$@";;
    ping) bench_ping "$@";;
    *) die "bench: unknown subcommand '$sub'";;
  esac
}

bench_http() {
  require_curl
  local url="" requests=50 concurrency=5 timeout=5
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --requests) requests="$2"; shift;;
      --concurrency) concurrency="$2"; shift;;
      --timeout) timeout="$2"; shift;;
      *) url="$1";;
    esac
    shift || true
  done
  [[ -z "$url" ]] && die "bench http: url required"

  # Build tasks: each line is a curl invocation
  local tmp_times
  tmp_times=$(mktemp)
  trap 'rm -f "$tmp_times"' EXIT

  # Generate N jobs and run with xargs -P (multi-curl)
  seq 1 "$requests" | xargs -I{} -P "$concurrency" bash -c '
    url="$0"; timeout="$1";
    start=$(date +%s%N 2>/dev/null || python - <<PY
import time; print(int(time.time()*1e9))
PY
)
    code=$(curl -sS -o /dev/null --max-time "$timeout" -w "%{http_code}" "$url" || echo 0)
    end=$(date +%s%N 2>/dev/null || python - <<PY
import time; print(int(time.time()*1e9))
PY
)
    dur_ns=$((end-start))
    echo "$code $dur_ns"
  ' "$url" "$timeout" >"$tmp_times"

  # Aggregate
  local total=0 ok=0 codes=() durations=()
  while read -r code ns; do
    (( total++ ))
    (( code >= 200 && code < 400 )) && (( ok++ ))
    codes+=("$code")
    durations+=("$ns")
  done <"$tmp_times"

  if (( total == 0 )); then
    echo "No successful measurements"
    return 1
  fi

  # Convert ns to ms floats in awk and compute stats
  awk -v total="$total" -v ok="$ok" '
    {
      code=$1; ns=$2;
      ms=ns/1000000.0;
      times[count++]=ms;
    }
    END {
      n=count;
      if (n==0) { print "No data"; exit }
      # sort
      for (i=0;i<n;i++) {
        for (j=i+1;j<n;j++) {
          if (times[j]<times[i]) {
            tmp=times[i]; times[i]=times[j]; times[j]=tmp;
          }
        }
      }
      min=times[0]; max=times[n-1];
      sum=0;
      for (i=0;i<n;i++) sum+=times[i];
      avg=sum/n;
      # p95 and p99 indices
      p95_idx=int(0.95*(n-1)+0.5);
      p99_idx=int(0.99*(n-1)+0.5);
      p95=times[p95_idx];
      p99=times[p99_idx];
      rps = total>0 ? (total / (sum/1000.0)) : 0;
      print "Requests:", total;
      print "Success :", ok;
      print "Min(ms) :", min;
      print "Avg(ms) :", avg;
      print "P95(ms) :", p95;
      print "P99(ms) :", p99;
      print "Max(ms) :", max;
      print "Req/s   :", rps;
    }
  ' "$tmp_times"
}

bench_ping() {
  local host="" count=50
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --count) count="$2"; shift;;
      *) host="$1";;
    esac
    shift || true
  done
  [[ -z "$host" ]] && die "bench ping: host required"
  have ping || die "ping required"
  ping -c "$count" "$host"
}

# -------------------- 5. TLS --------------------

tls_cmd() {
  local sub="$1"; shift || true
  case "$sub" in
    info)   tls_info "$@";;
    verify) tls_verify "$@";;
    chain)  tls_chain "$@";;
    *) die "tls: unknown subcommand '$sub'";;
  esac
}

tls_info() {
  have openssl || die "openssl required"
  local host="" port=443
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --port) port="$2"; shift;;
      *) host="$1";;
    esac
    shift || true
  done
  [[ -z "$host" ]] && die "tls info: host required"
  echo | openssl s_client -servername "$host" -connect "$host:$port" 2>/dev/null \
    | openssl x509 -noout -subject -issuer -dates
}

tls_verify() {
  have openssl || die "openssl required"
  local host="" port=443 strict=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --port) port="$2"; shift;;
      --strict) strict=1;;
      *) host="$1";;
    esac
    shift || true
  done
  [[ -z "$host" ]] && die "tls verify: host required"

  local cert tmp
  tmp=$(mktemp)
  echo | openssl s_client -servername "$host" -connect "$host:$port" 2>/dev/null \
    | openssl x509 -noout -dates -issuer -subject >"$tmp" || true
  [[ ! -s "$tmp" ]] && { echo "TLS: FAILED to retrieve cert"; rm -f "$tmp"; return 1; }

  echo "[CERT]"
  cat "$tmp"

  local notafter
  notafter=$(grep notAfter "$tmp" | sed 's/^notAfter=//')
  if [[ -n "$notafter" ]]; then
    local end_epoch now
    end_epoch=$(date -d "$notafter" +%s 2>/dev/null || echo 0)
    now=$(date +%s)
    local days_left=$(( (end_epoch - now) / 86400 ))
    echo
    echo "Days remaining: $days_left"
    if (( days_left < 0 )); then
      echo "Status: EXPIRED"
    elif (( days_left < 30 )); then
      echo "Status: WARN (expiring soon)"
    else
      echo "Status: OK"
    fi
  fi

  rm -f "$tmp"
}

tls_chain() {
  have openssl || die "openssl required"
  local host="" port=443
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --port) port="$2"; shift;;
      *) host="$1";;
    esac
    shift || true
  done
  [[ -z "$host" ]] && die "tls chain: host required"
  echo | openssl s_client -servername "$host" -connect "$host:$port" -showcerts 2>/dev/null \
    | awk '/BEGIN CERTIFICATE/,/END CERTIFICATE/ {print} /END CERTIFICATE/ {print "---"}' \
    | awk '
      /BEGIN CERTIFICATE/ {buf=""; next}
      /END CERTIFICATE/ {
        print "[CERT]"
        print buf | "openssl x509 -noout -subject -issuer"
        close("openssl x509 -noout -subject -issuer")
        next
      }
      {buf = buf $0 ORS}
    '
}

# -------------------- 6. Ports / Connections --------------------

port_cmd() {
  local sub="$1"; shift || true
  case "$sub" in
    ls)   port_ls "$@";;
    find) port_find "$@";;
    check) port_check "$@";;
    scan) port_scan "$@";;
    *) die "port: unknown subcommand '$sub'";;
  esac
}

require_ss_or_netstat() {
  have ss || have netstat || die "need ss or netstat"
}

port_ls() {
  require_ss_or_netstat
  local listening=0 tcp=0 udp=0 process=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --listening) listening=1;;
      --tcp) tcp=1;;
      --udp) udp=1;;
      --process) process=1;;
    esac
    shift || true
  done
  if have ss; then
    local args=" -n"
    (( listening )) && args+=" -l"
    (( tcp )) && args+=" -t"
    (( udp )) && args+=" -u"
    (( process )) && args+=" -p"
    # shellcheck disable=SC2086
    ss$args
  else
    netstat -anp
  fi
}

port_find() {
  require_ss_or_netstat
  local port="${1:-}" process=0
  [[ -z "$port" ]] && die "port find: port required"
  [[ "${2:-}" == "--process" ]] && process=1
  if have ss; then
    if (( process )); then
      ss -lntup | grep ":$port " || true
    else
      ss -lnt | grep ":$port " || true
    fi
  else
    if (( process )); then
      netstat -lntup | grep ":$port " || true
    else
      netstat -lnt | grep ":$port " || true
    fi
  fi
}

port_check() {
  local host="" port="" timeout=3 udp=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --timeout) timeout="$2"; shift;;
      --udp) udp=1;;
      *)
        if [[ -z "$host" ]]; then host="$1"
        elif [[ -z "$port" ]]; then port="$1"
        else die "Unexpected arg: $1"
        fi
        ;;
    esac
    shift || true
  done
  [[ -z "$host" || -z "$port" ]] && die "port check: host and port required"
  have nc || die "nc required"
  if (( udp )); then
    nc -z -u -w "$timeout" "$host" "$port" && echo "OK" || { echo "FAIL"; return 1; }
  else
    nc -z -w "$timeout" "$host" "$port" && echo "OK" || { echo "FAIL"; return 1; }
  fi
}

port_scan() {
  local host="" ports="80,443,3306"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --ports) ports="$2"; shift;;
      *) host="$1";;
    esac
    shift || true
  done
  [[ -z "$host" ]] && die "port scan: host required"
  for p in $(split_csv "$ports"); do
    printf "%s:%s " "$host" "$p"
    if port_check "$host" "$p" --timeout 2 >/dev/null 2>&1; then
      echo "OPEN"
    else
      echo "CLOSED"
    fi
  done
}

# Connection inspector

conn_cmd() {
  local sub="$1"; shift || true
  case "$sub" in
    ls)      conn_ls "$@";;
    record)  conn_record "$@";;
    summary) conn_summary "$@";;
    *) die "conn: unknown subcommand '$sub'";;
  esac
}

conn_ls() {
  require_ss_or_netstat
  local all=0 outbound=0 listening=0 suspicious=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --all) all=1;;
      --outbound) outbound=1;;
      --listening) listening=1;;
      --suspicious-only) suspicious=1;;
    esac
    shift || true
  done
  if have ss; then
    local args="-tunp"
    (( listening )) && args="-lntup"
    ss $args | awk 'NR==1 {next} {print}' | while read -r line; do
      proto=$(awk '{print $1}' <<<"$line")
      local_addr=$(awk '{print $5}' <<<"$line")
      remote_addr=$(awk '{print $6}' <<<"$line")
      state=$(awk '{print $2}' <<<"$line")
      # Extract pid/program
      pid=""; comm=""; user=""
      if [[ "$line" =~ pid=([0-9]+) ]]; then pid="${BASH_REMATCH[1]}"; fi
      if [[ "$line" =~ \"([^\"]+)\" ]]; then comm="${BASH_REMATCH[1]}"; fi

      if (( outbound )) && [[ "$state" != "ESTAB" ]]; then
        continue
      fi
      if (( suspicious )); then
        # Very rough heuristic: remote non-private and proc under /tmp or name odd (not implemented deeply)
        remote_ip=${remote_addr%:*}
        if is_private_ip "$remote_ip"; then
          continue
        fi
      fi

      printf "%-5s %-20s %-22s %-10s pid=%-6s proc=%s\n" \
        "$proto" "$local_addr" "$remote_addr" "$state" "${pid:-?}" "${comm:-?}"
    done
  else
    netstat -tunp
  fi
}

conn_record() {
  require_ss_or_netstat
  local interval=5 duration=120 out="$NETX_DIR/connections.log"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --interval) interval="$2"; shift;;
      --duration) duration="$2"; shift;;
      --out) out="$2"; shift;;
    esac
    shift || true
  done
  local end=$((SECONDS + duration))
  : >"$out"
  while (( SECONDS < end )); do
    echo "### $(date -Is)" >>"$out"
    if have ss; then
      ss -tunp >>"$out" 2>/dev/null || true
    else
      netstat -tunp >>"$out" 2>/dev/null || true
    fi
    sleep "$interval"
  done
  echo "Recorded to $out"
}

conn_summary() {
  local file="${1:-}"
  if [[ "$file" == "--file" ]]; then
    file="$2"
  fi
  [[ -z "$file" ]] && die "conn summary: --file path required"
  [[ -f "$file" ]] || die "File not found: $file"
  echo "Unique remote endpoints:"
  grep -E 'ESTAB|ESTABLISHED' "$file" | awk '{print $6}' | sort -u | sed 's/^/  /'
}

# -------------------- 7. Outbound Guard --------------------

guard_cmd() {
  local sub="$1"; shift || true
  case "$sub" in
    snapshot) guard_snapshot "$@";;
    diff)     guard_diff "$@";;
    watch)    guard_watch "$@";;
    *) die "guard: unknown subcommand '$sub'";;
  esac
}

guard_file_default="$NETX_DIR/outbound_baseline.txt"

guard_snapshot() {
  require_ss_or_netstat
  local file="$guard_file_default"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --file) file="$2"; shift;;
    esac
    shift || true
  done
  if have ss; then
    ss -tunp | awk 'NR>1' | normalize_conn_ss_line | sort -u >"$file"
  else
    netstat -tunp | awk 'NR>2' | normalize_conn_ss_line | sort -u >"$file"
  fi
  echo "Baseline saved to $file"
}

guard_diff() {
  require_ss_or_netstat
  local file="$guard_file_default"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --file) file="$2"; shift;;
    esac
    shift || true
  done
  [[ -f "$file" ]] || die "Baseline file not found: $file"
  local tmp
  tmp=$(mktemp)
  if have ss; then
    ss -tunp | awk 'NR>1' | normalize_conn_ss_line | sort -u >"$tmp"
  else
    netstat -tunp | awk 'NR>2' | normalize_conn_ss_line | sort -u >"$tmp"
  fi
  echo "New outbound connections since baseline:"
  comm -13 "$file" "$tmp" || true
  rm -f "$tmp"
}

guard_watch() {
  require_ss_or_netstat
  local file="$guard_file_default" interval=20 exec_cmd=""
  local exclude_user="" exclude_port="" exclude_cidr=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --file) file="$2"; shift;;
      --interval) interval="$2"; shift;;
      --exclude-user) exclude_user="$2"; shift;;
      --exclude-port) exclude_port="$2"; shift;;
      --exclude-cidr) exclude_cidr="$2"; shift;;
      --exec) exec_cmd="$2"; shift;;
    esac
    shift || true
  done
  [[ -f "$file" ]] || guard_snapshot --file "$file"
  echo "Watching outbound connections every ${interval}s (baseline: $file)"
  while :; do
    local tmp
    tmp=$(mktemp)
    if have ss; then
      ss -tunp | awk 'NR>1' | normalize_conn_ss_line | sort -u >"$tmp"
    else
      netstat -tunp | awk 'NR>2' | normalize_conn_ss_line | sort -u >"$tmp"
    fi
    local new
    new=$(comm -13 "$file" "$tmp" || true)
    if [[ -n "$new" ]]; then
      echo "[ALERT] New outbound connection(s):"
      echo "$new"
      if [[ -n "$exec_cmd" ]]; then
        echo "$new" | eval "$exec_cmd" || true
      fi
    fi
    mv "$tmp" "$file"
    sleep "$interval"
  done
}

# -------------------- 8. Security / Suspicious listeners --------------------

sec_cmd() {
  local sub="$1"; shift || true
  case "$sub" in
    listeners) sec_listeners "$@";;
    *) die "sec: unknown subcommand '$sub'";;
  esac
}

sec_listeners() {
  require_ss_or_netstat
  local ex_users="" ex_ports=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --exclude-user) ex_users="$2"; shift;;
      --exclude-port) ex_ports="$2"; shift;;
    esac
    shift || true
  done
  if have ss; then
    ss -lntup | awk 'NR>1' | while read -r line; do
      local_addr=$(awk '{print $5}' <<<"$line")
      proto=$(awk '{print $1}' <<<"$line")
      port="${local_addr##*:}"
      pid=""; comm=""
      if [[ "$line" =~ pid=([0-9]+) ]]; then pid="${BASHREMATCH[1]}"; fi
      if [[ "$line" =~ \"([^\"]+)\" ]]; then comm="${BASHREMATCH[1]}"; fi

      # skip excluded ports
      if [[ -n "$ex_ports" ]]; then
        for p in $(split_csv "$ex_ports"); do
          [[ "$p" == "$port" ]] && continue 2
        done
      fi

      # try to get exe path
      path=""
      if [[ -n "$pid" && -e "/proc/$pid/exe" ]]; then
        path=$(readlink "/proc/$pid/exe" 2>/dev/null || true)
      fi

      warn=0
      [[ "$local_addr" == "0.0.0.0"* ]] && warn=1
      [[ "$port" -gt 1024 ]] && warn=1
      [[ "$path" == /tmp/* || "$path" == /dev/shm/* ]] && warn=1

      (( warn )) || continue
      echo "[WARN] $proto $local_addr pid=$pid proc=$comm path=$path"
    done
  else
    netstat -lntup
  fi
}

# -------------------- 9. IP / Interface / Routes --------------------

ip_cmd() {
  local sub="$1"; shift || true
  case "$sub" in
    info) ip_info;;
    public) ip_public "$@";;
    *) die "ip: unknown subcommand '$sub'";;
  esac
}

ip_info() {
  have ip || die "ip command required"
  echo "[Interfaces]"
  ip -o addr show | awk '{print $2,$3,$4}' | sed 's/^/  /'
  echo
  echo "[Default route]"
  ip route show default | sed 's/^/  /'
  echo
  echo "[DNS]"
  dns_system
}

ip_public() {
  require_curl
  local want4=0 want6=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --ipv4) want4=1;;
      --ipv6) want6=1;;
    esac
    shift || true
  done
  if (( !want4 && !want6 )); then want4=1; want6=1; fi
  (( want4 )) && { echo -n "IPv4: "; curl -sS https://ipv4.icanhazip.com || echo "failed"; }
  (( want6 )) && { echo -n "IPv6: "; curl -sS https://ipv6.icanhazip.com || echo "failed"; }
}

if_cmd() {
  local sub="$1"; shift || true
  case "$sub" in
    ls) if_ls;;
    stats) if_stats "$@";;
    *) die "if: unknown subcommand '$sub'";;
  esac
}

if_ls() {
  have ip || die "ip required"
  ip -o link show | awk -F': ' '{print $1, $2}' | sed 's/^/  /'
}

if_stats() {
  have ip || die "ip required"
  local iface="${1:-}"
  [[ -z "$iface" ]] && die "if stats: iface required"
  ip -s link show "$iface"
}

route_cmd() {
  local sub="$1"; shift || true
  case "$sub" in
    show) route_show;;
    *) die "route: unknown subcommand '$sub'";;
  esac
}

route_show() {
  have ip || die "ip required"
  ip route show | sed 's/^/  /'
}

# -------------------- 10. Watchers / Waiters --------------------

watch_cmd() {
  local sub="$1"; shift || true
  case "$sub" in
    ping) watch_ping "$@";;
    http) watch_http "$@";;
    *) die "watch: unknown subcommand '$sub'";;
  esac
}

watch_ping() {
  have ping || die "ping required"
  local host="" interval=1 loss_threshold=10
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --interval) interval="$2"; shift;;
      --loss-threshold) loss_threshold="$2"; shift;;
      *) host="$1";;
    esac
    shift || true
  done
  [[ -z "$host" ]] && die "watch ping: host required"
  while :; do
    echo "== $(date -Is) =="
    ping -c 3 -W 2 "$host" || true
    sleep "$interval"
  done
}

watch_http() {
  require_curl
  local url="" interval=5 expect=200
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --interval) interval="$2"; shift;;
      --expect-status) expect="$2"; shift;;
      *) url="$1";;
    esac
    shift || true
  done
  [[ -z "$url" ]] && die "watch http: url required"
  while :; do
    local code
    code=$(curl -sS -o /dev/null -w '%{http_code}' "$url" || echo 0)
    echo "$(date -Is) status=$code"
    sleep "$interval"
  done
}

wait_cmd() {
  local sub="$1"; shift || true
  case "$sub" in
    port) wait_port "$@";;
    *) die "wait: unknown subcommand '$sub'";;
  esac
}

wait_port() {
  local host="" port="" timeout=60
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --timeout) timeout="$2"; shift;;
      *)
        if [[ -z "$host" ]]; then host="$1"
        elif [[ -z "$port" ]]; then port="$1"
        else die "Unexpected arg: $1"
        fi
        ;;
    esac
    shift || true
  done
  [[ -z "$host" || -z "$port" ]] && die "wait port: host and port required"
  have nc || die "nc required"
  local end=$((SECONDS + timeout))
  while (( SECONDS < end )); do
    if nc -z -w 2 "$host" "$port" >/dev/null 2>&1; then
      echo "Port $host:$port is up"
      return 0
    fi
    sleep 1
  done
  echo "Timed out waiting for $host:$port"
  return 1
}

# -------------------- 11. Stack check --------------------

stack_cmd() {
  local sub="$1"; shift || true
  case "$sub" in
    check) stack_check "$@";;
    *) die "stack: unknown subcommand '$sub'";;
  esac
}

stack_check() {
  local name="${1:-}"
  [[ -z "$name" ]] && die "stack check: name required"
  local cfg="${HOME}/.config/netx/stacks/${name}.conf"
  [[ -f "$cfg" ]] || die "stack config not found: $cfg"
  echo "Stack: $name"
  # Simple INI parser: lines under [services]
  awk -F'=' '
    /^\[services\]/ {in_s=1; next}
    /^\[/ {in_s=0; next}
    in_s && $1!="" {
      gsub(/[[:space:]]+/,"",$1);
      gsub(/^[[:space:]]+|[[:space:]]+$/,"",$2);
      print $1,$2
    }
  ' "$cfg" | while read -r svc target; do
    if [[ "$target" =~ ^https?:// ]]; then
      printf "[HTTP] %-10s %s -> " "$svc" "$target"
      local line
      line=$(http_trace "$target" 2>/dev/null || echo "failed")
      echo "$line"
    else
      host=${target%:*}
      port=${target##*:}
      printf "[TCP ] %-10s %s:%s -> " "$svc" "$host" "$port"
      if port_check "$host" "$port" --timeout 2 >/dev/null 2>&1; then
        echo "OK"
      else
        echo "FAIL"
      fi
    fi
  done
}

# -------------------- 12. Namespaces --------------------

ns_cmd() {
  local sub="$1"; shift || true
  case "$sub" in
    ls) ns_ls;;
    inspect) ns_inspect "$@";;
    exec) ns_exec "$@";;
    *) die "ns: unknown subcommand '$sub'";;
  esac
}

ns_ls() {
  have ip || die "ip required"
  ip netns list 2>/dev/null || echo "No network namespaces"
}

ns_inspect() {
  have ip || die "ip required"
  local ns="${1:-}"
  [[ -z "$ns" ]] && die "ns inspect: ns required"
  echo "[Interfaces]"
  ip netns exec "$ns" ip -o addr show | sed 's/^/  /'
  echo
  echo "[Routes]"
  ip netns exec "$ns" ip route show | sed 's/^/  /'
}

ns_exec() {
  have ip || die "ip required"
  local ns="${1:-}"; shift || true
  [[ -z "$ns" ]] && die "ns exec: ns required"
  [[ $# -eq 0 ]] && die "ns exec: command required"
  ip netns exec "$ns" "$@"
}

# -------------------- 13. Path trace --------------------

path_cmd() {
  local sub="$1"; shift || true
  case "$sub" in
    trace) path_trace "$@";;
    *) die "path: unknown subcommand '$sub'";;
  esac
}

path_trace() {
  local host="" max_hops=15
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --max-hops) max_hops="$2"; shift;;
      *) host="$1";;
    esac
    shift || true
  done
  [[ -z "$host" ]] && die "path trace: host required"
  if have mtr; then
    mtr -n -c 3 -r "$host"
  elif have traceroute; then
    traceroute -n -m "$max_hops" "$host"
  else
    die "path trace: need mtr or traceroute"
  fi
}

# -------------------- 14. Firewall --------------------

fw_cmd() {
  local sub="$1"; shift || true
  case "$sub" in
    summary) fw_summary;;
    list)    fw_list "$@";;
    *) die "fw: unknown subcommand '$sub'";;
  esac
}

fw_summary() {
  if have nft; then
    echo "[nftables summary]"
    nft list ruleset 2>/dev/null | grep -E 'table|chain' | sed 's/^/  /' | head -n 50
  elif have iptables; then
    echo "[iptables summary]"
    iptables -L -n --line-numbers | sed 's/^/  /'
  else
    echo "No nftables/iptables found"
  fi
}

fw_list() {
  local raw=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --raw) raw=1;;
    esac
    shift || true
  done
  if have nft; then
    if (( raw )); then
      nft list ruleset
    else
      nft list ruleset | sed 's/^/  /'
    fi
  elif have iptables; then
    if (( raw )); then
      iptables-save
    else
      iptables -S | sed 's/^/  /'
    fi
  else
    echo "No nftables/iptables found"
  fi
}

# -------------------- 15. Net report --------------------

report_cmd() {
  local out="$NETX_DIR/net-report.txt"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --out) out="$2"; shift;;
    esac
    shift || true
  done
  {
    echo "netx report $(date -Is)"
    echo
    echo "== ip info =="
    ip_info || true
    echo
    echo "== route show =="
    route_show || true
    echo
    echo "== dns system =="
    dns_system || true
    echo
    echo "== port ls (listening tcp) =="
    port_ls --listening --tcp --process || true
    echo
    echo "== conn ls (outbound) =="
    conn_ls --outbound || true
  } >"$out"
  echo "Report saved to $out"
}

# -------------------- Main dispatcher --------------------

main() {
  local cmd="${1:-}"
  [[ -z "$cmd" ]] && { usage; exit 1; }
  shift || true
  case "$cmd" in
    -h|--help|help) usage;;
    --version|-V) echo "netx $VERSION";;

    doctor) doctor_cmd "$@";;

    dns)    [[ $# -gt 0 ]] || die "dns subcommand required"; dns_cmd "$@";;
    http)   [[ $# -gt 0 ]] || die "http subcommand required"; http_cmd "$@";;
    proxy)  [[ $# -gt 0 ]] || die "proxy subcommand required"; proxy_cmd "$@";;
    bench)  [[ $# -gt 0 ]] || die "bench subcommand required"; bench_cmd "$@";;

    tls)    [[ $# -gt 0 ]] || die "tls subcommand required"; tls_cmd "$@";;

    port)   [[ $# -gt 0 ]] || die "port subcommand required"; port_cmd "$@";;
    conn)   [[ $# -gt 0 ]] || die "conn subcommand required"; conn_cmd "$@";;
    guard)  [[ $# -gt 0 ]] || die "guard subcommand required"; guard_cmd "$@";;
    sec)    [[ $# -gt 0 ]] || die "sec subcommand required"; sec_cmd "$@";;

    ip)     [[ $# -gt 0 ]] || die "ip subcommand required"; ip_cmd "$@";;
    if)     [[ $# -gt 0 ]] || die "if subcommand required"; if_cmd "$@";;
    route)  [[ $# -gt 0 ]] || die "route subcommand required"; route_cmd "$@";;

    watch)  [[ $# -gt 0 ]] || die "watch subcommand required"; watch_cmd "$@";;
    wait)   [[ $# -gt 0 ]] || die "wait subcommand required"; wait_cmd "$@";;

    stack)  [[ $# -gt 0 ]] || die "stack subcommand required"; stack_cmd "$@";;

    ns)     [[ $# -gt 0 ]] || die "ns subcommand required"; ns_cmd "$@";;

    path)   [[ $# -gt 0 ]] || die "path subcommand required"; path_cmd "$@";;

    fw)     [[ $# -gt 0 ]] || die "fw subcommand required"; fw_cmd "$@";;

    report) report_cmd "$@";;

    *)
      die "Unknown command: $cmd"
      ;;
  esac
}

main "$@"
