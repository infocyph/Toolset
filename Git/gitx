#!/bin/bash

# Fallback colors/log_action if not provided by environment
: "${RED:=}"
: "${GREEN:=}"
: "${YELLOW:=}"
: "${NC:=}"

if ! declare -F log_action >/dev/null 2>&1; then
  log_action() { :; }
fi

# Helper function for displaying usage
usage() {
  echo "Usage: gitx <command> [options]"
  echo ""
  echo "üìÇ Repository & Branch Management:"
  echo "  status                                           Show repository status, branch tracking, and remote info"
  echo "  fetch                                            Fetch remote branches and prune stale references"
  echo "  sync                                             Sync alpha and develop with master/main"
  echo "  create <branch_type> <name>                      Create a new branch from master/main"
  echo "      - branch_type: feature, bugfix, hotfix, release, docs, ci, experiment"
  echo "      - name: A short descriptive name for the branch"
  echo "  merge <source_branch> <target_branch>            Merge one branch into another"
  echo "      - source_branch: The branch to merge from"
  echo "      - target_branch: The branch to merge into"
  echo "  reset-branch                                     Reset current branch to remote state"
  echo "      - Interactive mode with soft/hard reset options"
  echo "  prune                                            Prune remote branches and delete local tracking branches"
  echo "  cleanup                                          Delete merged branches"
  echo "      - Prompts to confirm deletion"
  echo "  orphan-branches [days]                           List/delete unmerged branches older than N days (default: 30)"
  echo "  compare <branch1> <branch2>                      Compare two branches"
  echo "      - branch1: The first branch to compare (optional, default: current)"
  echo "      - branch2: The second branch to compare (optional, default: main)"
  echo ""
  echo "üì¶ Commit & Change Management:"
  echo "  commit                                           Interactive commit helper"
  echo "      - Allows selecting files and entering a commit message"
  echo "  amend                                            Amend the last commit message"
  echo "      - Optionally enter a new commit message or edit interactively"
  echo "  cherry-pick                                      Interactive cherry-pick helper"
  echo "  revert                                           Revert specific commits with options"
  echo "      - Interactive mode to select commits"
  echo "  unstage                                          Unstage all files"
  echo "      - Requires confirmation before unstaging"
  echo "  stage-deleted                                    Stage all deleted files"
  echo "  stage-deleted-dir <directory>                    Stage deleted files in a specific directory"
  echo "      - directory: Path to the directory"
  echo "  diff [output_file]                               Interactive staged diff (view/save)"
  echo "  diff <start> <end> [--stat|--name-only|--patch] [-- <path...>]"
  echo "      - start/end: commit/tag OR YYYY-MM-DD YYYY-MM-DD"
  echo "      - tip: date diff is inclusive (start-commit parent ‚Üí end-commit)"
  echo ""
  echo "üîç Tracking & Reporting:"
  echo "  log-file <file_path>                             View commit history and diffs for a specific file"
  echo "      - file_path: Path to the file to inspect"
  echo "  commit-report <start_commit..end_commit>         Generate a commit report for a commit range"
  echo "  commit-report <start_date> <end_date>            Generate a commit report for a date range"
  echo "      - dates: YYYY-MM-DD format"
  echo "  worklog <range>|<start_date> <end_date>          Generate CSV worklog for task logs"
  echo "      - range: e.g., HEAD~50..HEAD"
  echo "      - dates: YYYY-MM-DD format"
  echo "  summary [commit_range] [include-all] [mode]      Summarize commits + surviving code per author"
  echo "  summary <start_date> <end_date> [include-all] [mode]  Same summary using date window (YYYY-MM-DD)"
  echo "      - commit_range: Optional, e.g., HEAD~50"
  echo "      - include-all: Optional, include all text-based files"
  echo "      - mode: heavy (default, full blame) | lite (no blame, fast)"
  echo "  report <start_commit> [end_commit] [file]        Generate PR and commit report"
  echo "  report <start_date> <end_date> [file]              Date window (YYYY-MM-DD) ‚Üí first/last commit boundaries"
  echo "      - start_commit: The starting commit hash or tag"
  echo "      - end_commit: The ending commit hash or tag (default: HEAD)"
  echo "      - file: Output file for the report (optional)"
  echo "  count-changes <start_commit> [end_commit]        Count changes (insertions, deletions) between two commits"
  echo "  list-changes <branch1> <branch2>                 List files changed between two branches"
  echo "      - branch1: The first branch"
  echo "      - branch2: The second branch"
  echo "  changelog <start_commit> <end_commit>            Generate a changelog between commits or tags"
  echo "  changelog <start_date> <end_date> [file]           Date window (YYYY-MM-DD) ‚Üí first/last commit boundaries"
  echo "      - start_commit: The starting commit hash or tag"
  echo "      - end_commit: The ending commit hash or tag"
  echo ""
  echo "üîñ Tags & Releases:"
  echo "  tag <version>                                    Tag the current branch with a version (e.g., v1.0.0)"
  echo "      - version: Must follow semantic versioning (vX.Y.Z)"
  echo "  latest-tag                                       Get the latest tag in the repository"
  echo "  initial-commit                                   Get the initial commit hash"
  echo ""
  echo "üóÑÔ∏è Stashing & Cleanup:"
  echo "  stash [subcommand]                               Manage stash operations"
  echo "      - stash                      (interactive menu)"
  echo "      - stash save [msg...]           Save with message (default WIP-style)"
  echo "      - stash list                 List stashes"
  echo "      - stash apply <n>            Apply stash@{n}"
  echo "      - stash pop <n>              Pop stash@{n}"
  echo "      - stash drop <n>             Drop stash@{n}"
  echo "      - stash rename <n> <name...>    Rename stash@{n}"
  echo "      - stash clear                Delete all stashes"
  echo "  wip <save|list|pop|apply|clear>                  Opinionated WIP stash helper"
  echo "  clean [--force]                                 Clean untracked files and directories"
  echo "      - Interactive mode by default"
  echo "      - --force: Non-interactive full clean (git clean -fd)"
  echo "  large-files                                      Show the largest files in the repository"
  echo "      - Prompts for the number of files to display"
  echo ""
  echo "‚öôÔ∏è Configuration & Utilities:"
  echo "  add-remote <name> <url>                          Add a new remote repository"
  echo "  push-remote <remote> <branch>                    Push to a specific remote branch"
  echo "  pull-remote <remote> <branch>                    Pull from a specific remote branch"
  echo "  config                                           Edit Git configuration (add/edit/remove keys)"
  echo "  set-lf                                           Set Git to use LF line endings"
  echo "  doctor                                           Run repository health checks"
  echo "  hooks init                                       Install Git hook templates"
  echo "  self-update                                      Update gitx to the latest version"
  echo "  summarize [short]                                Repository summary (branches, tags, contributors, etc.)"
  echo ""
  echo "üîπ Example Usages:"
  echo "  gitx commit                                      # Interactive commit helper"
  echo "  gitx report v1.0.0 v2.0.0                        # Generate PR and commit report"
  echo "  gitx reset-branch                                # Reset current branch to match remote"
  echo "  gitx compare develop main                        # Compare two branches"
  echo "  gitx summary HEAD~50 include-all heavy           # Full blame, accurate surviving code"
  echo "  gitx worklog 2025-01-01 2025-01-31               # CSV worklog for a month"
  echo ""
  exit 1
}

require_sudo() {
  if [[ "$EUID" -ne 0 ]]; then
    echo -e "${RED}Please run this script with sudo or as root.${NC}"
    log_action "ERROR" "Script not run with sudo (EUID=$EUID)."
    exit 1
  fi
}

# Ensure Git repository
ensure_git_repo() {
  if ! git rev-parse --is-inside-work-tree &>/dev/null; then
    echo "Error: Not inside a Git repository."
    exit 1
  fi
}

# -------------------------- range helpers --------------------------

is_iso_date() {
  [[ "${1:-}" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]
}

# Resolve a YYYY-MM-DD..YYYY-MM-DD window to commit boundaries:
# - first commit within window (chronological)
# - last commit within window
# Prints: "<first> <last>"
resolve_date_range_to_commits() {
  ensure_git_repo
  local start_date="${1:-}"
  local end_date="${2:-}"

  if ! is_iso_date "$start_date" || ! is_iso_date "$end_date"; then
    echo "Error: Dates must be in YYYY-MM-DD format."
    return 1
  fi

  local since="${start_date} 00:00"
  local until="${end_date} 23:59:59"

  # First commit in the window (chronological) and last commit (newest).
  local first last
  first="$(git rev-list --reverse --since="$since" --until="$until" HEAD | head -n 1 || true)"
  last="$(git rev-list --since="$since" --until="$until" HEAD | head -n 1 || true)"

  if [[ -z "$first" || -z "$last" ]]; then
    echo "No commits found between ${start_date} and ${end_date}."
    return 2
  fi

  printf '%s %s
' "$first" "$last"
}

# Build an inclusive range spec from two commit hashes.
# Prefer "<first>^.. <last>" so the first commit is included.
build_inclusive_range_spec() {
  local first="${1:-}"
  local last="${2:-}"
  if [[ -z "$first" || -z "$last" ]]; then
    return 1
  fi

  # If window resolves to a single commit, using the commit hash is the most robust.
  if [[ "$first" == "$last" ]]; then
    printf '%s
' "$first"
    return 0
  fi

  # Prefer "<first>^.. <last>" so the first commit is included.
  if git rev-parse "${first}^" >/dev/null 2>&1; then
    printf '%s
' "${first}^..${last}"
  else
    # Root commit has no parent; best-effort inclusive: log up to "last" includes the root.
    printf '%s
' "${last}"
  fi
}

# Unstage all files
unstage_all() {
  ensure_git_repo
  echo "WARNING: This will unstage all files!"
  read -rp "Are you sure? (y/n): " confirm
  [[ "$confirm" != "y" ]] && {
    echo "Operation cancelled."
    return
  }
  git reset --staged .
  echo "All files have been unstaged."
}

# Amend the last commit message
amend_commit_message() {
  ensure_git_repo
  read -rp "Enter the new commit message (leave blank to edit interactively): " new_message
  if [[ -z "$new_message" ]]; then
    git commit --amend
  else
    git commit --amend -m "$new_message"
  fi
  echo "Commit message amended."
}

# Add a new remote repository (CLI-first)
add_remote() {
  ensure_git_repo
  local remote_name="${1:-}"
  local remote_url="${2:-}"

  if [[ -z "$remote_name" ]]; then
    read -rp "Enter the remote name (e.g., origin): " remote_name
  fi
  if [[ -z "$remote_url" ]]; then
    read -rp "Enter the remote URL: " remote_url
  fi

  if [[ -z "$remote_name" || -z "$remote_url" ]]; then
    echo "Error: Remote name and URL are required."
    return 1
  fi

  git remote add "$remote_name" "$remote_url" && echo "Remote '$remote_name' added."
}

# Push to a specific remote branch (CLI-first)
push_to_remote() {
  ensure_git_repo
  local remote_name="${1:-}"
  local branch_name="${2:-}"

  if [[ -z "$remote_name" ]]; then
    read -rp "Enter the remote name (default: origin): " remote_name
    remote_name=${remote_name:-origin}
  fi

  if [[ -z "$branch_name" ]]; then
    read -rp "Enter the branch name to push: " branch_name
  fi

  if ! git rev-parse --verify "$branch_name" >/dev/null 2>&1; then
    echo "Error: Branch '$branch_name' does not exist."
    return 1
  fi

  git push "$remote_name" "$branch_name"
  echo "Pushed branch '$branch_name' to remote '$remote_name'."
}

# Pull from a specific remote branch (CLI-first)
pull_from_remote() {
  ensure_git_repo
  local remote_name="${1:-}"
  local branch_name="${2:-}"

  if [[ -z "$remote_name" ]]; then
    read -rp "Enter the remote name (default: origin): " remote_name
    remote_name=${remote_name:-origin}
  fi

  if [[ -z "$branch_name" ]]; then
    read -rp "Enter the branch name to pull: " branch_name
  fi

  if ! git remote | grep -qw "$remote_name"; then
    echo "Error: Remote '$remote_name' does not exist."
    return 1
  fi

  git pull "$remote_name" "$branch_name"
  echo "Pulled branch '$branch_name' from remote '$remote_name'."
}

# Stage all deleted files (safe for spaces)
stage_deleted_files() {
  ensure_git_repo

  if ! git ls-files --deleted -z | grep -q .; then
    echo "No deleted files to stage."
    return 0
  fi

  git ls-files --deleted -z | xargs -0 git add
  echo "Deleted files have been staged."
}

# Stage deleted files in a specific directory (CLI-first, safe)
stage_deleted_in_directory() {
  ensure_git_repo
  local dir_path="${1:-}"

  if [[ -z "$dir_path" ]]; then
    read -rp "Enter the directory path: " dir_path
  fi

  if [[ ! -d "$dir_path" ]]; then
    echo "Error: Directory '$dir_path' does not exist."
    return 1
  fi

  if ! git ls-files --deleted -z -- "$dir_path" | grep -q .; then
    echo "No deleted files to stage in '$dir_path'."
    return 0
  fi

  git ls-files --deleted -z -- "$dir_path" | xargs -0 git add
  echo "Deleted files in '$dir_path' have been staged."
}

# Get the initial commit hash
get_initial_commit() {
  ensure_git_repo
  local initial_commit
  initial_commit=$(git rev-list --max-parents=0 HEAD 2>/dev/null)

  if [[ -z "$initial_commit" ]]; then
    echo "Error: No commits found in this repository."
    return 1
  fi

  echo "Initial Commit: $initial_commit"
}

# Get the latest tag in the repository
get_latest_tag() {
  ensure_git_repo
  local latest_tag
  latest_tag=$(git describe --tags --abbrev=0 2>/dev/null)

  if [[ -z "$latest_tag" ]]; then
    echo "No tags found in this repository."
    return 1
  fi

  echo "Latest Tag: $latest_tag"
}

# Detect master/main branch
detect_main_branch() {
  if git symbolic-ref refs/remotes/origin/HEAD &>/dev/null; then
    git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'
  elif git branch -r | grep -q "origin/main"; then
    echo "main"
  elif git branch -r | grep -q "origin/trunk"; then
    echo "trunk"
  else
    echo "master"
  fi
}

# Generate a changelog between two commits or tags (CLI-first)
generate_changelog() {
  ensure_git_repo

  local a1="${1:-}"
  local a2="${2:-}"
  local a3="${3:-}"

  local start_ref=""
  local end_ref=""
  local range_spec=""
  local changelog_file=""

  # Date-range mode: changelog <start_date> <end_date> [file]
  if is_iso_date "$a1" && is_iso_date "$a2"; then
    local commits first last
    commits="$(resolve_date_range_to_commits "$a1" "$a2")" || return $?
    first="$(awk '{print $1}' <<<"$commits")"
    last="$(awk '{print $2}' <<<"$commits")"

    start_ref="$first"
    end_ref="$last"
    range_spec="$(build_inclusive_range_spec "$first" "$last")"

    changelog_file="${a3:-changelog_${a1}_to_${a2}.txt}"
  else
    # Commit/tag mode: changelog <start_ref> <end_ref>
    start_ref="$a1"
    end_ref="$a2"

    if [[ -z "$start_ref" ]]; then
      read -rp "Enter the start commit or tag: " start_ref
    fi
    if [[ -z "$end_ref" ]]; then
      read -rp "Enter the end commit or tag (default: HEAD): " end_ref
      end_ref=${end_ref:-HEAD}
    fi

    local safe_start safe_end
    safe_start=${start_ref//\//_}
    safe_end=${end_ref//\//_}
    changelog_file="changelog_${safe_start}_to_${safe_end}.txt"

    range_spec="${start_ref}..${end_ref}"
  fi

  git log "$range_spec" --pretty=format:"%h - %s (%an, %ad)" --date=short >"$changelog_file"
  echo "Changelog saved to $changelog_file."
}

# Count changes between two commits (CLI-first)
count_changes_between_commits() {
  ensure_git_repo
  local start_commit="${1:-}"
  local end_commit="${2:-HEAD}"

  if [[ -z "$start_commit" ]]; then
    read -rp "Enter the start commit: " start_commit
  fi
  if [[ -z "$end_commit" ]]; then
    end_commit="HEAD"
  fi

  local changes_count
  changes_count=$(git diff --shortstat "$start_commit" "$end_commit")
  echo "Changes between $start_commit and $end_commit: $changes_count"
}

# List files changed between two branches (CLI-first)
list_changed_files_between_branches() {
  ensure_git_repo
  local branch1="${1:-}"
  local branch2="${2:-}"

  if [[ -z "$branch1" ]]; then
    read -rp "Enter the first branch: " branch1
  fi
  if [[ -z "$branch2" ]]; then
    read -rp "Enter the second branch: " branch2
  fi

  echo "Files changed between $branch1 and $branch2:"
  git diff --name-only "$branch1" "$branch2"
}

# Set Git to use LF line endings
set_line_endings_to_lf() {
  ensure_git_repo
  git config --global core.autocrlf false
  echo "Configured Git to use LF line endings."
}

# Create a new branch from master/main
create_branch() {
  local branch_type=$1
  local name=$2
  ensure_git_repo

  if [[ -z "$branch_type" || -z "$name" ]]; then
    echo "Error: Branch type and name are required."
    return 1
  fi

  local branch_name="${branch_type}/${name}"

  if git show-ref --verify --quiet "refs/heads/$branch_name"; then
    echo "Error: Branch '$branch_name' already exists."
    return 1
  fi

  local main_branch
  main_branch="$(detect_main_branch)"

  if [[ $(git rev-parse --abbrev-ref HEAD) != "$main_branch" ]]; then
    echo "Switching to main branch ($main_branch) and pulling latest changes..."
    git checkout "$main_branch" && git pull origin "$main_branch"
  fi

  git checkout -b "$branch_name"
  git push origin "$branch_name"
  echo "Branch created: $branch_name"
}

# Sync alpha and develop with master/main
sync_branches() {
  ensure_git_repo
  local main_branch
  main_branch=$(detect_main_branch)

  echo "Syncing branches with $main_branch..."

  local branches=("alpha" "develop")
  read -rp "Do you want to sync additional branches? (y/n): " sync_more
  if [[ "$sync_more" == "y" ]]; then
    read -rp "Enter branches to sync (comma-separated): " additional_branches
    IFS=',' read -r -a user_branches <<<"$additional_branches"
    branches+=("${user_branches[@]}")
  fi

  git checkout "$main_branch" && git pull origin "$main_branch"

  for branch in "${branches[@]}"; do
    if git show-ref --verify --quiet "refs/heads/$branch"; then
      echo "Merging $main_branch into $branch..."
      git checkout "$branch" && git merge --no-ff "$main_branch" && git push origin "$branch"
      echo "Synced $branch with $main_branch."
    else
      echo "Branch '$branch' does not exist. Skipping..."
    fi
  done
}

# Merge branches
merge_branch() {
  local source=$1
  local target=$2
  ensure_git_repo

  if [[ -z "$source" || -z "$target" ]]; then
    echo "Error: Source and target branches are required."
    return 1
  fi

  if ! git show-ref --verify --quiet "refs/heads/$source" || ! git show-ref --verify --quiet "refs/heads/$target"; then
    echo "Error: One or both branches do not exist."
    return 1
  fi

  echo "About to merge '$source' into '$target'."
  read -rp "Are you sure? (y/n): " confirm
  [[ "$confirm" != "y" ]] && {
    echo "Merge cancelled."
    return
  }

  git checkout "$target" && git pull origin "$target"

  echo "Merging $source into $target..."
  if ! git merge --no-ff "$source"; then
    echo "Merge conflicts detected. Resolve them and commit manually."
    echo "Run 'git merge --abort' to cancel the merge."
    return 1
  fi

  git push origin "$target"
  echo "Successfully merged $source into $target."
}

# Tag a release
tag_release() {
  local version=$1
  ensure_git_repo

  if [[ -z "$version" ]]; then
    echo "Error: Version is required for tagging."
    return 1
  fi

  if ! [[ "$version" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    echo "Error: Version format must be 'vX.Y.Z' (e.g., v1.0.0)."
    return 1
  fi

  if git rev-parse "refs/tags/$version" >/dev/null 2>&1; then
    echo "Error: Tag '$version' already exists."
    return 1
  fi

  echo "Creating tag '$version'..."
  git tag -a "$version" -m "Release $version" && git push origin "$version"
  echo "Tag '$version' created successfully."
}

# Cleanup merged branches
cleanup_branches() {
  ensure_git_repo
  echo "Merged branches (excluding main branches):"
  local merged_branches
  merged_branches=$(git branch --merged | grep -vE "(^\*|master|main|develop|alpha)")

  if [[ -z "$merged_branches" ]]; then
    echo "No merged branches found."
    return 0
  fi

  echo "$merged_branches"
  read -rp "Do you want to delete all merged branches? (y/n): " delete_all

  if [[ "$delete_all" == "y" ]]; then
    echo "$merged_branches" | xargs git branch -d
    echo "Deleted all merged branches."
  else
    echo "$merged_branches" | while read -r branch; do
      read -rp "Delete branch '$branch'? (y/n): " confirm
      [[ "$confirm" == "y" ]] && git branch -d "$branch"
    done
  fi
}

# Orphan branches (not merged into main, older than N days)
orphan_branches() {
  ensure_git_repo
  local days="${1:-30}"
  local base_branch
  base_branch=$(detect_main_branch)
  local now epoch_now
  epoch_now=$(date +%s)

  echo "Looking for branches NOT merged into '$base_branch' and older than ${days} days..."
  local found=0
  git for-each-ref --format='%(refname:short)|%(committerdate:unix)' refs/heads/ |
    while IFS='|' read -r branch epoch; do
      case "$branch" in
      master | main | develop | alpha | trunk) continue ;;
      esac
      # Skip branches already merged into base
      if git merge-base --is-ancestor "$branch" "$base_branch" 2>/dev/null; then
        continue
      fi
      local age_days=$(((epoch_now - epoch) / 86400))
      if ((age_days >= days)); then
        echo "$branch (last commit: $age_days days ago)"
        found=1
      fi
    done

  if [[ "$found" -eq 0 ]]; then
    echo "No orphan branches found for threshold ${days} days."
    return 0
  fi

  echo ""
  read -rp "Do you want to delete any of these branches? (y/n): " yn
  [[ "$yn" != "y" ]] && return 0

  read -rp "Enter branch names to delete (space-separated) or 'all': " to_del
  if [[ "$to_del" == "all" ]]; then
    git for-each-ref --format='%(refname:short)|%(committerdate:unix)' refs/heads/ |
      while IFS='|' read -r branch epoch; do
        case "$branch" in
        master | main | develop | alpha | trunk) continue ;;
        esac
        if git merge-base --is-ancestor "$branch" "$base_branch" 2>/dev/null; then
          continue
        fi
        local age_days=$(((epoch_now - epoch) / 86400))
        if ((age_days >= days)); then
          echo "Deleting $branch..."
          git branch -D "$branch"
        fi
      done
  else
    for b in $to_del; do
      echo "Deleting $b..."
      git branch -D "$b"
    done
  fi
}

# Fetch PRs, Non-PR Merges, and Standalone Commits
fetch_prs_and_commits() {
  ensure_git_repo

  local a1="${1:-}"
  local a2="${2:-}"
  local a3="${3:-}"

  local start_ref=""
  local end_ref=""
  local commit_range=""
  local output_file=""

  # Date-range mode: report <start_date> <end_date> [file]
  if is_iso_date "$a1" && is_iso_date "$a2"; then
    local commits first last
    commits="$(resolve_date_range_to_commits "$a1" "$a2")" || return $?
    first="$(awk '{print $1}' <<<"$commits")"
    last="$(awk '{print $2}' <<<"$commits")"

    start_ref="$first"
    end_ref="$last"
    commit_range="$(build_inclusive_range_spec "$first" "$last")"
    output_file="${a3:-pr_report_${a1}_to_${a2}.txt}"
  else
    # Commit/tag mode: report <start_commit> [end_commit] [file]
    start_ref="$a1"
    end_ref="${a2:-HEAD}"

    if [[ -z "$start_ref" ]]; then
      echo "‚ùå Error: Start commit is required."
      read -rp "Enter the start commit hash or tag: " start_ref
    fi

    # Inclusive on both ends (matches your date-range behavior)
    commit_range="$(build_inclusive_range_spec "$start_ref" "$end_ref")"

    local safe_start safe_end
    safe_start=${start_ref//\//_}
    safe_end=${end_ref//\//_}
    output_file="${a3:-pr_report_${safe_start}_to_${safe_end}.txt}"
  fi

  echo "üöÄ Generating PR and commit report for range: $commit_range"
  echo "üìÅ Saving output to: $output_file"

  {
    echo "PRs, Non-PR Merges, and Standalone Commits Report"
    echo ""

    # ------------------------- PR merges -------------------------
    echo "1Ô∏è‚É£ PRs:"
    echo ""

    git log --merges --date=iso-strict \
      --pretty=format:'%H|%s|%an|%ae|%ad' "$commit_range" |
      while IFS='|' read -r merge_hash subject an ae ad; do
        [[ -z "$merge_hash" ]] && continue
        [[ "$subject" != *"Merge pull request"* ]] && continue

        echo "üîπ Merge Commit: ${merge_hash:0:7} | $subject | $an|$ae|$ad"

        # Keep body without breaking parsing (body is fetched per-merge, not in the list stream)
        local body
        body="$(git show -s --format=%b "$merge_hash" 2>/dev/null || true)"
        if [[ -n "${body//[[:space:]]/}" ]]; then
          echo "   Body:"
          printf '%s\n' "$body" | sed 's/^/   | /'
        fi

        echo "   PR Contains the following commits:"
        git log --no-merges --date=iso-strict \
          --pretty=format:'   - %h | %s | %an (%ad)' \
          "${merge_hash}^1..${merge_hash}" 2>/dev/null || true
        echo ""
      done

    # ---------------------- Non-PR merges ------------------------
    echo "2Ô∏è‚É£ Non-PR Merges:"
    echo ""

    git log --merges --date=iso-strict \
      --pretty=format:'%H|%s|%an|%ae|%ad' "$commit_range" |
      while IFS='|' read -r merge_hash subject an ae ad; do
        [[ -z "$merge_hash" ]] && continue
        [[ "$subject" == *"Merge pull request"* ]] && continue

        echo "üîπ Merge Commit: ${merge_hash:0:7} | $subject | $an|$ae|$ad"

        local body
        body="$(git show -s --format=%b "$merge_hash" 2>/dev/null || true)"
        if [[ -n "${body//[[:space:]]/}" ]]; then
          echo "   Body:"
          printf '%s\n' "$body" | sed 's/^/   | /'
        fi

        echo "   Contains the following commits:"
        git log --no-merges --date=iso-strict \
          --pretty=format:'   - %h | %s | %an (%ad)' \
          "${merge_hash}^1..${merge_hash}" 2>/dev/null || true
        echo ""
      done

    # ---------------------- Standalone commits -------------------
    echo "3Ô∏è‚É£ Standalone Commits:"
    echo ""

    local all_commits merge_commits standalone_commits merges
    all_commits="$(git log --no-merges --pretty=format:'%H' "$commit_range" 2>/dev/null | LC_ALL=C sort -u)"
    merges="$(git log --merges --pretty=format:'%H' "$commit_range" 2>/dev/null || true)"

    merge_commits="$(
      while IFS= read -r m; do
        [[ -z "$m" ]] && continue
        git log --no-merges --pretty=format:'%H' "${m}^1..${m}" 2>/dev/null || true
      done <<<"$merges" | LC_ALL=C sort -u
    )"

    standalone_commits="$(comm -23 <(printf '%s\n' "$all_commits") <(printf '%s\n' "$merge_commits"))"

    while IFS= read -r commit; do
      [[ -z "$commit" ]] && continue
      git show -s --date=iso-strict \
        --pretty=format:'üî∏ %h | %s | %an (%ad)%n' \
        "$commit"
    done <<<"$standalone_commits"

    echo ""
  } | tee "$output_file"

  echo "‚úÖ Report generated in $output_file"
}

# Unified stash operations (CLI + interactive)
stash_operations() {
  ensure_git_repo
  local sub="${1:-}"
  shift || true

  if [[ -n "$sub" ]]; then
    case "$sub" in
    save)
      local msg="$*"
      local timestamp branch_name stash_name
      timestamp=$(date +"%Y-%m-%d_%H-%M-%S")
      branch_name=$(git rev-parse --abbrev-ref HEAD)
      if [[ -z "$msg" ]]; then
        stash_name="Stash on $branch_name @ $timestamp"
      else
        stash_name="$msg"
      fi
      git stash push -m "$stash_name"
      echo "‚úÖ Changes stashed as: $stash_name"
      ;;
    list)
      git stash list
      ;;
    apply)
      local n="${1:-0}"
      git stash apply "stash@{$n}"
      ;;
    pop)
      local n="${1:-0}"
      git stash pop "stash@{$n}"
      ;;
    drop)
      local n="${1:-0}"
      git stash drop "stash@{$n}"
      ;;
    rename)
      local n="${1:-}"
      shift || true
      local new_name="$*"

      if [[ -z "$n" || -z "$new_name" ]]; then
        echo "Usage: gitx stash rename <n> <new_name>"
        return 1
      fi

      local commit
      commit="$(git rev-parse "stash@{$n}" 2>/dev/null || true)"
      if [[ -z "$commit" ]]; then
        echo "Invalid stash index: $n"
        return 1
      fi

      git stash store -m "$new_name" "$commit" || return 1
      git stash drop "stash@{$n}" >/dev/null 2>&1 || true
      echo "‚úÖ Renamed stash@{$n} -> $new_name"
      ;;
    clear)
      git stash clear
      echo "‚úÖ All stashes deleted."
      ;;
    *)
      echo "Unknown stash subcommand: $sub"
      echo "Use: save|list|apply|pop|drop|rename|clear or run 'gitx stash' for interactive mode."
      return 1
      ;;
    esac
    return 0
  fi

  # Interactive menu
  echo "üöÄ Stash Manager:"
  echo "1. Save changes to stash"
  echo "2. List stashes"
  echo "3. Apply a stash"
  echo "4. Pop (apply & delete) a stash"
  echo "5. Drop a stash"
  echo "6. Rename a stash"
  echo "7. Delete all stashes"
  read -rp "Enter your choice: " choice

  case $choice in
  1)
    local timestamp branch_name stash_name
    timestamp=$(date +"%Y-%m-%d_%H-%M-%S")
    branch_name=$(git rev-parse --abbrev-ref HEAD)
    stash_name="Stash on $branch_name @ $timestamp"
    git stash push -m "$stash_name"
    echo "‚úÖ Changes stashed as: $stash_name"
    ;;
  2) git stash list ;;
  3)
    git stash list
    read -rp "Enter stash number to apply: " stash_number
    git stash apply "stash@{$stash_number}"
    ;;
  4)
    git stash list
    read -rp "Enter stash number to pop: " stash_number
    git stash pop "stash@{$stash_number}"
    ;;
  5)
    git stash list
    read -rp "Enter stash number to drop: " stash_number
    git stash drop "stash@{$stash_number}"
    ;;
  6)
    git stash list
    read -rp "Enter stash number to rename: " stash_number
    read -rp "Enter new stash name: " new_name

    local commit
    commit="$(git rev-parse "stash@{$stash_number}" 2>/dev/null || true)"
    if [[ -z "$commit" ]]; then
      echo "Invalid stash index: $stash_number"
      return 1
    fi

    git stash store -m "$new_name" "$commit" && git stash drop "stash@{$stash_number}" >/dev/null 2>&1 || true
    echo "‚úÖ Renamed stash@{$stash_number} -> $new_name"
    ;;
  7)
    read -rp "Are you sure you want to delete all stashes? (y/n): " confirm
    [[ "$confirm" == "y" ]] && git stash clear && echo "‚úÖ All stashes deleted."
    ;;
  *) echo "‚ùå Invalid choice." ;;
  esac
}

# WIP helper (sugar around stash)
wip_manager() {
  ensure_git_repo
  local action="${1:-}"
  shift || true

  case "$action" in
  save)
    local msg="$*"
    local ts branch
    ts=$(date +"%Y-%m-%d_%H-%M-%S")
    branch=$(git rev-parse --abbrev-ref HEAD)
    local name="WIP: ${branch} @ ${ts}"
    [[ -n "$msg" ]] && name+=" - $msg"
    git stash push -m "$name"
    echo "‚úÖ WIP stashed as: $name"
    ;;
  list)
    git stash list | grep "WIP:" || echo "No WIP stashes."
    ;;
  pop)
    git stash pop
    ;;
  apply)
    git stash apply
    ;;
  clear)
    git stash clear
    echo "‚úÖ All stashes (including WIP) cleared."
    ;;
  *)
    echo "Usage: gitx wip <save|list|pop|apply|clear> [message]"
    ;;
  esac
}

# Compare branches (CLI-first)
compare_branches() {
  ensure_git_repo
  local branch1="${1:-}"
  local branch2="${2:-}"

  if [[ -z "$branch1" ]]; then
    read -rp "Enter the first branch to compare (default: current branch): " branch1
    branch1=${branch1:-$(git rev-parse --abbrev-ref HEAD)}
  fi

  if [[ -z "$branch2" ]]; then
    read -rp "Enter the second branch to compare (default: main): " branch2
    branch2=${branch2:-$(detect_main_branch)}
  fi

  if ! git show-ref --verify --quiet "refs/heads/$branch1" || ! git show-ref --verify --quiet "refs/heads/$branch2"; then
    echo "Error: One or both branches do not exist."
    return 1
  fi

  echo "Commits unique to each branch:"
  git log --oneline "$branch1".."$branch2"
  echo "Files changed between branches:"
  git diff --name-only "$branch1".."$branch2"
}

# Git configuration editor
edit_git_config() {
  echo "Current Git Configuration:"
  git config --list
  echo "Options:"
  echo "1. Add/Edit a key"
  echo "2. Remove a key"
  read -rp "Enter your choice: " choice

  case $choice in
  1)
    read -rp "Enter the key you want to add/edit: " key
    if [[ -n "$key" ]]; then
      read -rp "Enter the new value for $key: " value
      git config --global "$key" "$value"
      echo "Updated $key to $value globally."
    else
      echo "No changes made."
    fi
    ;;
  2)
    read -rp "Enter the key you want to remove: " key
    if [[ -n "$key" ]]; then
      git config --global --unset "$key"
      echo "Removed key: $key"
    else
      echo "No changes made."
    fi
    ;;
  *)
    echo "Invalid choice."
    ;;
  esac
}

summarize_repo() {
  ensure_git_repo
  local mode="${1:-full}"

  echo "Repository Summary:"
  echo "===================="
  echo "Current Branch: $(git rev-parse --abbrev-ref HEAD)"
  echo "Latest Commit: $(git log -1 --pretty=format:'%h - %s (%an, %ad)' --date=short)"
  echo "Total Commits: $(git rev-list --count HEAD)"
  echo "Number of Tags: $(git tag | wc -l)"
  echo "Number of Stashes: $(git stash list | wc -l)"
  echo "Repository Size: $(du -sh .git 2>/dev/null | awk '{print $1}')"
  echo "Remotes:"
  git remote -v | awk '{print "  - " $1 " -> " $2}' | sort | uniq

  if [[ "$mode" != "short" ]]; then
    echo "Branches:"
    git branch -a
    echo ""
    echo "Contributors:"
    git shortlog -sne | awk '{printf "%s %s (%s commits)\n", $2, $3, $1}'
    echo ""
  fi
}

track_staged_changes() {
  local diff_file="${1:-diffs.txt}"

  ensure_git_repo
  echo "Choose an action:"
  echo "1. Save staged changes to a file"
  echo "2. View staged changes inline"
  read -rp "Enter your choice: " choice

  case $choice in
  1)
    if [[ -f "$diff_file" ]]; then
      read -rp "File $diff_file already exists. Overwrite? (y/n): " overwrite
      if [[ "$overwrite" != "y" ]]; then
        echo "Aborting save operation."
        return
      fi
    fi
    git --no-pager diff --cached >"$diff_file"
    if [[ -s "$diff_file" ]]; then
      echo "Staged changes saved to $diff_file"
    else
      echo "No changes are currently staged."
    fi
    ;;
  2)
    git --no-pager diff --cached
    ;;
  *)
    echo "Invalid choice."
    ;;
  esac
}

_gitx_empty_tree() {
  git hash-object -t tree /dev/null 2>/dev/null
}

diff_between_refs_or_dates() {
  ensure_git_repo

  local a1="${1:-}"
  local a2="${2:-}"
  shift 2 || true

  if [[ -z "$a1" || -z "$a2" ]]; then
    echo "Usage: gitx diff <start> <end> [--stat|--name-only|--patch] [-- <path...>]"
    return 1
  fi

  local mode="--patch"
  if [[ "${1:-}" == "--stat" || "${1:-}" == "--name-only" || "${1:-}" == "--patch" ]]; then
    mode="$1"
    shift || true
  fi

  local flags=()
  case "$mode" in
  --stat) flags+=(--stat) ;;
  --name-only) flags+=(--name-only) ;;
  --patch) ;;
  *)
    echo "Invalid mode: $mode (use --stat, --name-only, or --patch)"
    return 1
    ;;
  esac

  # Allow explicit path separator `--`, but also accept paths without it.
  if [[ "${1:-}" == "--" ]]; then
    shift || true
  fi

  local from_ref="" to_ref="" start_hash="" end_hash="" parent_start=""

  # Date mode (YYYY-MM-DD YYYY-MM-DD)
  if is_iso_date "$a1" && is_iso_date "$a2"; then
    local commits first last
    commits="$(resolve_date_range_to_commits "$a1" "$a2")" || return $?
    first="$(awk '{print $1}' <<<"$commits")"
    last="$(awk '{print $2}' <<<"$commits")"

    start_hash="$first"
    end_hash="$last"
  else
    # Ref mode
    start_hash="$(git rev-parse --verify "$a1^{commit}" 2>/dev/null)" || {
      echo "Error: Invalid start ref: $a1"
      return 1
    }
    end_hash="$(git rev-parse --verify "$a2^{commit}" 2>/dev/null)" || {
      echo "Error: Invalid end ref: $a2"
      return 1
    }
  fi

  # Inclusive: parent(start) -> end
  parent_start="$(git rev-parse "${start_hash}^" 2>/dev/null || true)"
  if [[ -n "$parent_start" ]]; then
    from_ref="$parent_start"
  else
    from_ref="$(_gitx_empty_tree)"
  fi
  to_ref="$end_hash"

  git diff --no-renames "${flags[@]}" "$from_ref" "$to_ref" -- "$@"
}

gitx_diff() {
  # Range/date diff if 2+ args are provided, otherwise keep existing staged diff UX.
  if [[ $# -ge 2 ]]; then
    diff_between_refs_or_dates "$@"
  else
    track_staged_changes "${1:-}"
  fi
}


cherry_pick_commit() {
  ensure_git_repo
  echo "Recent Commit History:"
  git log --oneline | nl -w2 -s". " | tee /tmp/git_log.txt

  read -rp "Enter the numbers of the commits to cherry-pick (comma-separated): " commit_numbers
  local commit_hashes
  commit_hashes=$(echo "$commit_numbers" | tr ',' '\n' | while read -r num; do
    sed -n "${num}p" /tmp/git_log.txt | awk '{print $2}'
  done)

  if [[ -z "$commit_hashes" ]]; then
    echo "No valid commits selected. Exiting."
    return
  fi

  for commit in $commit_hashes; do
    git cherry-pick "$commit" || {
      echo "Conflict detected during cherry-pick of $commit."
      read -rp "Do you want to resolve conflicts manually or abort? (resolve/abort): " action
      if [[ "$action" == "abort" ]]; then
        git cherry-pick --abort
        echo "Cherry-pick aborted."
        return
      fi
    }
    echo "Cherry-picked commit: $commit"
  done
}

clean_untracked() {
  ensure_git_repo
  local mode="${1:-}"

  if [[ "$mode" == "--force" || "$mode" == "force" ]]; then
    echo "Running non-interactive clean: git clean -fd"
    git clean -fd
    echo "Untracked files and directories cleaned."
    return 0
  fi

  echo "Choose an action:"
  echo "1. Preview untracked files and directories (dry-run)"
  echo "2. Clean untracked files and directories"
  read -rp "Enter your choice: " choice

  case $choice in
  1)
    echo "Preview of untracked files and directories:"
    git clean -fdn
    ;;
  2)
    echo "This action will permanently delete untracked files and directories."
    read -rp "Are you sure you want to proceed? (y/n): " confirm
    if [[ "$confirm" == "y" ]]; then
      git clean -fd
      echo "Untracked files and directories cleaned."
    else
      echo "Operation canceled."
    fi
    ;;
  *)
    echo "Invalid choice."
    ;;
  esac
}

show_large_files() {
  ensure_git_repo

  read -rp "How many large files do you want to display? (default 10): " count
  count=${count:-10}

  echo "Choose an action:"
  echo "1. Display results inline"
  echo "2. Save results to a file"
  read -rp "Enter your choice: " choice

  local cmd="
    git rev-list --objects --all |
    git cat-file --batch-check='%(objecttype) %(objectname) %(objectsize) %(rest)' |
    awk '\$1 == \"blob\" {print \$3, \$4}' |
    sort -k1 -nr |
    head -${count}
  "

  case $choice in
  1)
    echo "Top $count largest files in the repository:"
    eval "$cmd" | awk '{printf "%s bytes  %s\n", $1, $2}'
    ;;
  2)
    read -rp "Enter the output file name (default: large_files.txt): " output_file
    output_file=${output_file:-large_files.txt}
    eval "$cmd" | awk '{printf "%s bytes  %s\n", $1, $2}' >"$output_file"
    echo "Results saved to $output_file"
    ;;
  *)
    echo "Invalid choice."
    ;;
  esac
}

fetch_and_prune() {
  ensure_git_repo
  echo "Fetching remote branches and pruning stale references..."
  git fetch --prune
  echo "Done."
}

# File log (CLI-first)
file_log() {
  ensure_git_repo
  local file_path="${1:-}"

  if [[ -z "$file_path" ]]; then
    read -rp "Enter the file path to view its history: " file_path
  fi

  if [[ ! -f "$file_path" ]]; then
    echo "‚ùå Error: File '$file_path' does not exist."
    return 1
  fi

  echo "üìå Choose an action:"
  echo "1. View commit history of the file"
  echo "2. View diffs for commits affecting the file"
  read -rp "Enter your choice: " choice

  case $choice in
  1)
    echo "üìå Commit history for $file_path:"
    git log --follow --pretty=format:"%h - %s (%an, %ad)" --date=short -- "$file_path"
    ;;
  2)
    echo "üìå Diffs for commits affecting $file_path:"
    git log --follow -p -- "$file_path"
    ;;
  *) echo "‚ùå Invalid choice." ;;
  esac
}

revert_commit() {
  ensure_git_repo
  echo "üìå Recent Commit History:"
  git log --oneline | nl -w2 -s". " | tee /tmp/git_log.txt

  read -rp "Enter the numbers of the commits to revert (comma-separated): " commit_numbers

  local commit_hashes
  commit_hashes=$(echo "$commit_numbers" | tr ',' '\n' | while read -r num; do
    sed -n "${num}p" /tmp/git_log.txt | awk '{print $2}'
  done)

  if [[ -z "$commit_hashes" ]]; then
    echo "‚ùå No valid commits selected."
    return 1
  fi

  echo "üìå Choose an action:"
  echo "1. Create revert commits for each selected commit"
  echo "2. Revert and amend the last commit"
  read -rp "Enter your choice: " choice

  case $choice in
  1)
    for commit in $commit_hashes; do
      git revert "$commit" || {
        echo "‚ö†Ô∏è Conflict detected while reverting $commit. Resolve manually."
        exit 1
      }
      echo "‚úÖ Reverted commit: $commit"
    done
    ;;
  2)
    for commit in $commit_hashes; do
      git revert --no-commit "$commit"
    done
    git commit --amend -m "Amended revert: $(git log -1 --pretty=%B)"
    echo "‚úÖ Reverted commits and amended the last commit."
    ;;
  *) echo "‚ùå Invalid choice." ;;
  esac
}

reset_branch_to_remote() {
  ensure_git_repo
  local branch
  branch=$(git rev-parse --abbrev-ref HEAD)

  if ! git ls-remote --exit-code origin "$branch" &>/dev/null; then
    echo "‚ùå Error: Remote branch '$branch' does not exist."
    return 1
  fi

  echo "üö® WARNING: This will reset '$branch' to match 'origin/$branch'."
  echo "1. Soft reset (keep local changes)"
  echo "2. Hard reset (discard all local changes)"
  echo "3. Dry-run (preview only)"
  read -rp "Enter your choice: " reset_type

  case $reset_type in
  1)
    git fetch origin && git reset --soft "origin/$branch" && echo "‚úÖ Soft reset completed."
    ;;
  2)
    read -rp "Are you sure? This will discard ALL local changes. (y/n): " confirm
    [[ "$confirm" == "y" ]] && git fetch origin && git reset --hard "origin/$branch" && echo "‚úÖ Hard reset completed."
    ;;
  3)
    git fetch origin && git diff --stat "origin/$branch"
    ;;
  *) echo "‚ùå Invalid choice." ;;
  esac
}

prune_remote_branches() {
  ensure_git_repo
  echo "üöÄ Fetching and pruning stale remote branches..."
  git fetch --prune

  echo "üóëÔ∏è Checking for deleted remote branches..."
  local deleted_branches
  deleted_branches=$(git branch -vv | awk '/: gone]/{print $1}')

  if [[ -z "$deleted_branches" ]]; then
    echo "‚úÖ No local branches need pruning."
    return 0
  fi

  echo "$deleted_branches"
  read -rp "Do you want to delete all these branches? (y/n): " delete_all

  if [[ "$delete_all" == "y" ]]; then
    echo "$deleted_branches" | xargs git branch -D
    echo "‚úÖ Deleted all local branches tracking removed remote branches."
  else
    echo "$deleted_branches" | while read -r branch; do
      read -rp "Delete branch '$branch'? (y/n): " confirm
      [[ "$confirm" == "y" ]] && git branch -D "$branch"
    done
  fi
}

interactive_commit() {
  ensure_git_repo

  if [[ -z $(git status --porcelain) ]]; then
    echo "‚úÖ No changes to commit."
    return 0
  fi

  echo "üìå Select files to stage (use numbers):"
  git status -s | nl -w2 -s". " | tee /tmp/git_status.txt

  read -rp "Enter file numbers to stage (comma-separated, 'a' for all): " file_numbers

  if [[ "$file_numbers" == "a" ]]; then
    git add .
  else
    local selected_files
    selected_files=$(echo "$file_numbers" | tr ',' '\n' | while read -r num; do
      sed -n "${num}p" /tmp/git_status.txt | awk '{print $2}'
    done)
    # shellcheck disable=SC2086
    git add $selected_files
  fi

  echo "üìå Staged files:"
  git diff --cached --name-only

  read -rp "Enter your commit message: " commit_message
  git commit -m "$commit_message"
  echo "‚úÖ Committed changes with message: $commit_message"
}

show_status() {
  ensure_git_repo
  echo "üöÄ Repository Status:"
  git status -sb --untracked-files=all
  echo ""
  echo "üìå Branch Tracking Info:"
  git rev-list --left-right --count @{upstream}...HEAD 2>/dev/null || echo "No upstream branch set."
  echo ""
  echo "üåç Remote Status:"
  git remote -v | awk '{print "  - " $1 " -> " $2}' | sort | uniq
}

# Author summary (surviving code %) with heavy/lite modes
generate_git_summary() {
  ensure_git_repo

  local include_all=false
  local mode="heavy"
  local positional=()

  for a in "$@"; do
    case "$a" in
    "") ;;
    include-all) include_all=true ;;
    heavy | HEAVY) mode="heavy" ;;
    lite | LITE | fast | no-blame) mode="lite" ;;
    *) positional+=("$a") ;;
    esac
  done

  local log_range=""

  # Date-range mode: summary <start_date> <end_date> [include-all] [mode]
  if [[ ${#positional[@]} -ge 2 ]] && is_iso_date "${positional[0]}" && is_iso_date "${positional[1]}"; then
    local commits first last
    commits="$(resolve_date_range_to_commits "${positional[0]}" "${positional[1]}")" || return $?
    first="$(awk '{print $1}' <<<"$commits")"
    last="$(awk '{print $2}' <<<"$commits")"
    log_range="$(build_inclusive_range_spec "$first" "$last")"
  elif [[ ${#positional[@]} -ge 1 ]]; then
    local range_arg="${positional[0]}"
    if [[ "$range_arg" == *".."* ]]; then
      log_range="$range_arg"
    else
      log_range="${range_arg}..HEAD"
    fi
  fi

  local heavy_flag=1
  [[ "$mode" == "lite" ]] && heavy_flag=0

  local temp_file
  temp_file="$(mktemp)"

  if [[ -n "$log_range" ]]; then
    git --no-pager log --no-merges "$log_range" \
      --pretty='>>%h|%ce|%ct|%s|%aN' --shortstat |
      awk -F'|' '
        BEGIN { email=""; name=""; }
        /^>>/ {
          email=$2; name=$5;
          print email "|" name "|commit" >> "'"$temp_file"'"
          next
        }
        /files changed/ {
          files=ins=del=0
          for (i=1; i<=NF; i++) {
            if ($i ~ /^[0-9]+$/ && $(i+1) ~ /^files?/) files=$i
            if ($i ~ /^[0-9]+$/ && $(i+1) ~ /^insertion/) ins=$i
            if ($i ~ /^[0-9]+$/ && $(i+1) ~ /^deletion/) del=$i
          }
          print email "|" name "|" files "|" ins "|" del >> "'"$temp_file"'"
        }
      '
  else
    git --no-pager log --no-merges \
      --pretty='>>%h|%ce|%ct|%s|%aN' --shortstat |
      awk -F'|' '
        BEGIN { email=""; name=""; }
        /^>>/ {
          email=$2; name=$5;
          print email "|" name "|commit" >> "'"$temp_file"'"
          next
        }
        /files changed/ {
          files=ins=del=0
          for (i=1; i<=NF; i++) {
            if ($i ~ /^[0-9]+$/ && $(i+1) ~ /^files?/) files=$i
            if ($i ~ /^[0-9]+$/ && $(i+1) ~ /^insertion/) ins=$i
            if ($i ~ /^[0-9]+$/ && $(i+1) ~ /^deletion/) del=$i
          }
          print email "|" name "|" files "|" ins "|" del >> "'"$temp_file"'"
        }
      '
  fi

  local blame_file
  blame_file="$(mktemp)"

  if ((heavy_flag)); then
    # Heavy mode: blame over entire repo (accurate surviving code)
    local files_to_blame
    files_to_blame="$(git ls-files)"

    files_to_blame="$(printf '%s\n' "$files_to_blame" | while read -r f; do
      [[ -z "$f" ]] && continue
      local mime
      mime=$(file --mime-type -b "$f" 2>/dev/null || true)
      if [[ "$include_all" == true && "$mime" =~ ^text/ ]]; then
        echo "$f"
      else
        case "$f" in
        *.sh | *.py | *.js | *.ts | *.go | *.java | *.c | *.cpp | *.php | *.rb | *.html | *.css | *.scss | *.sql | *.xml | *.json | *.yaml | *.yml | *.md | *.toml | *.ini | *.cfg | *.conf | *.properties | Makefile | makefile | Dockerfile | .env | .gitignore)
          echo "$f"
          ;;
        esac
      fi
    done)"

    if [[ -n "$files_to_blame" ]]; then
      local jobs
      if command -v nproc >/dev/null 2>&1; then
        jobs="$(nproc)"
      else
        jobs=4
      fi

      printf '%s\n' "$files_to_blame" | xargs -P"$jobs" -I{} git blame --line-porcelain "{}" 2>/dev/null |
        grep -E "^author-mail" >"$blame_file"
    fi
  fi

  echo "| Author Name | Author Email | Commits | Files Changed | Insertions | Deletions | Surviving Code % |"
  echo "|------------|--------------|---------|--------------|-----------|----------|-------------------|"

  awk -F'|' -v blame_file="$blame_file" -v heavy_mode="$heavy_flag" '
    BEGIN {
      total_surviving = 0
      if (heavy_mode == 1) {
        while ((getline line < blame_file) > 0) {
          split(line, arr, " ")
          author_email = arr[2]
          gsub(/[<>]/, "", author_email)
          surviving_lines[author_email]++
          total_surviving++
        }
        close(blame_file)
      }
    }
    {
      if ($3 == "commit") {
        commits[$1]++
        authors[$1] = $2
      } else {
        files_changed[$1] += $3
        insertions[$1]   += $4
        deletions[$1]    += $5
      }
    }
    END {
      total_commits = 0
      total_files = 0
      total_ins = 0
      total_del = 0

      for (email in commits) {
        ins = insertions[email] + 0
        surv = 0
        surv_str = "N/A"
        if (heavy_mode == 1 && total_surviving > 0 && ins > 0 && surviving_lines[email] > 0) {
          surv = int((surviving_lines[email] / total_surviving) * 100)
          surv_str = surv "%"
        }
        print "| " authors[email] " | " email " | " commits[email] " | " files_changed[email] " | " insertions[email] " | " deletions[email] " | " surv_str " |"

        total_commits += commits[email]
        total_files   += files_changed[email]
        total_ins     += insertions[email]
        total_del     += deletions[email]
      }

      if (total_commits > 0) {
        if (heavy_mode == 1 && total_surviving > 0) {
          total_surv_str = "100%"
        } else {
          total_surv_str = "N/A"
        }
        print "| TOTAL | - | " total_commits " | " total_files " | " total_ins " | " total_del " | " total_surv_str " |"
      }
    }
  ' "$temp_file"

  rm -f "$temp_file" "$blame_file"
}

# Commit report (range or date-based)
generate_commit_report() {
  ensure_git_repo

  local git_log_output
  if [[ $# -eq 1 ]]; then
    local range="$1"
    git_log_output=$(git --no-pager log --no-merges "$range" --pretty='>>%h|%ce|%ct|%s|%b|%aN')
  elif [[ $# -eq 2 ]]; then
    local start_date="$1" end_date="$2"
    local commits first last range_spec

    commits="$(resolve_date_range_to_commits "$start_date" "$end_date")" || return $?
    first="$(awk '{print $1}' <<<"$commits")"
    last="$(awk '{print $2}' <<<"$commits")"
    range_spec="$(build_inclusive_range_spec "$first" "$last")"

    git_log_output=$(git --no-pager log --no-merges "$range_spec" --pretty='>>%h|%ce|%ct|%s|%b|%aN')
  else
    echo "Usage:"
    echo "  gitx commit-report <start_commit..end_commit>"
    echo "  gitx commit-report <start_date> <end_date>   (YYYY-MM-DD)"
    return 1
  fi

  if [[ -z "$git_log_output" ]]; then
    echo "No commits found."
    return 0
  fi

  printf '%s\n' "$git_log_output" | awk -F'|' '
    BEGIN {
      print "# Commit Report\n"
    }
    /^>>/ {
      line = substr($0, 3)
      n = split(line, parts, "|")
      commit_id   = parts[1]
      email       = parts[2]
      ts          = parts[3]
      subject     = parts[4]
      body        = (n >= 5 ? parts[5] : "")
      author_name = (n >= 6 ? parts[6] : email)

      clean_subject = subject
      gsub(/^:[^:]+: /, "", clean_subject)
      match(clean_subject, /^(feature|feat|fix|bugfix|hotfix|chore|docs|style|refactor|perf|test|ci|build|revert|BREAKING CHANGE)(\([^)]+\))?:/, m)
      type = (m[1] != "" ? m[1] : "misc")

      gsub(/\|/, "\\|", subject)
      gsub(/\|/, "\\|", body)
      gsub(/\r/, "", body)
      gsub(/ +- /, "\n- ", body)
      gsub(/ +-/, "\n- ", body)
      gsub(/\n+/, "<br>", body)

      if (length(body) > 0) {
        subject_body = subject "<br><br>" body
      } else {
        subject_body = subject
      }
      gsub(/\|/, "\\|", subject_body)

      if (!(email in author_seen)) {
        author_seen[email] = 1
        order_count++
        author_order[order_count]    = email
        author_name_map[email]       = author_name
        author_email_map[email]      = email
      }

      author_count[email]++
      formatted_time = strftime("%Y-%m-%d %H:%M:%S", ts)
      author_details[email] = author_details[email] "| " commit_id " | " type " | " subject_body " | " formatted_time " |\n"
    }
    END {
      for (i = 1; i <= order_count; i++) {
        email = author_order[i]
        name  = author_name_map[email]
        print "### " name
        print "- Email: " email
        print "- Number of Commits: " author_count[email]
        print ""
        print "| Commit Id | Type | Subject & Body | Date & Time |"
        print "| --- | --- | --- | --- |"
        printf "%s\n", author_details[email]
        print ""
      }
    }
  '
}

# Worklog: CSV-oriented report for task logs
generate_worklog() {
  ensure_git_repo

  local git_log_output
  if [[ $# -eq 1 ]]; then
    local range="$1"
    git_log_output=$(git --no-pager log --no-merges "$range" --pretty='>>%h|%ce|%ct|%s|%b|%aN')
  elif [[ $# -eq 2 ]]; then
    local start_date="$1" end_date="$2"
    local commits first last range_spec

    commits="$(resolve_date_range_to_commits "$start_date" "$end_date")" || return $?
    first="$(awk '{print $1}' <<<"$commits")"
    last="$(awk '{print $2}' <<<"$commits")"
    range_spec="$(build_inclusive_range_spec "$first" "$last")"

    git_log_output=$(git --no-pager log --no-merges "$range_spec" --pretty='>>%h|%ce|%ct|%s|%b|%aN')
  else
    echo "Usage:"
    echo "  gitx worklog <start_commit..end_commit>"
    echo "  gitx worklog <start_date> <end_date>   (YYYY-MM-DD)"
    return 1
  fi

  if [[ -z "$git_log_output" ]]; then
    echo "No commits found."
    return 0
  fi

  echo "Author,Email,CommitId,Type,DateTime,Subject,Body"

  printf '%s\n' "$git_log_output" | awk -F'|' '
    function esc_csv(s,  r) {
      gsub(/"/, "\"\"", s)
      return "\"" s "\""
    }
    /^>>/ {
      line = substr($0, 3)
      n = split(line, parts, "|")
      commit_id   = parts[1]
      email       = parts[2]
      ts          = parts[3]
      subject     = parts[4]
      body        = (n >= 5 ? parts[5] : "")
      author_name = (n >= 6 ? parts[6] : email)

      clean_subject = subject
      gsub(/^:[^:]+: /, "", clean_subject)
      match(clean_subject, /^(feature|feat|fix|bugfix|hotfix|chore|docs|style|refactor|perf|test|ci|build|revert|BREAKING CHANGE)(\([^)]+\))?:/, m)
      type = (m[1] != "" ? m[1] : "misc")

      gsub(/\r/, "", body)
      gsub(/\n+/, " ", body)

      dt = strftime("%Y-%m-%d %H:%M:%S", ts)

      print esc_csv(author_name) "," esc_csv(email) "," esc_csv(commit_id) "," esc_csv(type) "," esc_csv(dt) "," esc_csv(subject) "," esc_csv(body)
    }
  '
}

self_update() {
  local script_url="https://raw.githubusercontent.com/infocyph/Toolset/main/Git/gitx"
  local temp_file="/tmp/gitx_latest"
  local local_file

  local_file="$(command -v gitx 2>/dev/null || true)"
  if [[ -z "$local_file" ]]; then
    local_file="/usr/local/bin/gitx"
  fi

  echo -e "${YELLOW}Checking for updates to gitx...${NC}"

  if ! curl -fsSL "$script_url" -o "$temp_file"; then
    echo -e "${RED}Failed to download the latest gitx script from GitHub.${NC}"
    return 1
  fi

  local remote_hash local_hash
  remote_hash="$(sha256sum "$temp_file" | awk '{print $1}')"
  local_hash="$(sha256sum "$local_file" 2>/dev/null | awk '{print $1}')"

  if [[ -n "$local_hash" && "$remote_hash" == "$local_hash" ]]; then
    echo -e "${GREEN}gitx is already up-to-date.${NC}"
    rm -f "$temp_file"
    return 0
  fi

  if [[ -e "$local_file" && ! -w "$local_file" ]]; then
    echo -e "${RED}Cannot write to $local_file. Run with sudo or install gitx in a writable location.${NC}"
    rm -f "$temp_file"
    return 1
  fi

  if [[ -f "$local_file" ]]; then
    mv "$local_file" "${local_file}.bak-$(date +'%Y%m%d%H%M%S')" 2>/dev/null || true
  fi

  if ! mv "$temp_file" "$local_file"; then
    echo -e "${RED}Failed to overwrite $local_file with the new gitx script.${NC}"
    return 1
  fi

  chmod +x "$local_file"

  echo -e "${GREEN}gitx has been updated successfully to the latest version.${NC}"
}

# Simple doctor command: health check
doctor_repo() {
  ensure_git_repo
  local root current_branch main_branch
  root=$(git rev-parse --show-toplevel)
  current_branch=$(git rev-parse --abbrev-ref HEAD)
  main_branch=$(detect_main_branch)

  echo "üîé gitx doctor"
  echo "Repository: $root"
  echo "Current Branch: $current_branch (main: $main_branch)"

  if git rev-parse --abbrev-ref @{upstream} &>/dev/null; then
    local behind ahead
    read -r behind ahead <<<"$(git rev-list --left-right --count @{upstream}...HEAD 2>/dev/null)"
    echo "Upstream: ahead $ahead, behind $behind"
  else
    echo "Upstream: no tracking branch set."
  fi

  local status_count untracked_count stash_count
  status_count=$(git status --porcelain | wc -l | tr -d ' ')
  untracked_count=$(git status --porcelain | awk '$1=="??"' | wc -l | tr -d ' ')
  stash_count=$(git stash list | wc -l | tr -d ' ')

  echo "Working tree: $status_count changes ($untracked_count untracked)"
  echo "Stashes: $stash_count"

  local merged_branches
  merged_branches=$(git branch --merged "$main_branch" | grep -vE "(^\*|master|main|develop|alpha)" || true)
  if [[ -n "$merged_branches" ]]; then
    echo ""
    echo "Branches merged into $main_branch but still present:"
    echo "$merged_branches"
  fi

  echo ""
  echo ".git directory size: $(du -sh .git 2>/dev/null | awk '{print $1}')"

  echo ""
  echo "Top 5 largest blobs (by size):"
  git rev-list --objects --all |
    git cat-file --batch-check='%(objecttype) %(objectname) %(objectsize) %(rest)' |
    awk '$1=="blob" {print $3, $4}' |
    sort -k1 -nr |
    head -5 |
    awk '{printf "%s bytes  %s\n", $1, $2}'
}

# Hooks initializer
hooks_manager() {
  ensure_git_repo
  local sub="${1:-}"

  if [[ "$sub" != "init" ]]; then
    echo "Usage: gitx hooks init"
    return 1
  fi

  local root hooks_dir
  root=$(git rev-parse --show-toplevel)
  hooks_dir="$root/.git/hooks"
  mkdir -p "$hooks_dir"

  cat >"$hooks_dir/prepare-commit-msg.gitx" <<'EOF'
#!/bin/sh
# gitx prepare-commit-msg hook example
# Appends Conventional Commit template as comments.

MSG_FILE="$1"
COMMIT_SOURCE="$2"

# Skip merges, rebases, etc.
case "$COMMIT_SOURCE" in
  merge|squash|commit|message) ;;
  *) exit 0 ;;
esac

if [ ! -f "$MSG_FILE" ]; then
  exit 0
fi

if grep -q "Conventional Commit format" "$MSG_FILE"; then
  exit 0
fi

cat <<'TEMPLATE' >>"$MSG_FILE"

# Conventional Commit format: <type>(scope?): <subject>
# Types: feat, fix, chore, docs, refactor, test, perf, build, ci, style, revert
# Example: feat(auth): add login with OTP
# Optional: use gitmoji: :sparkles: feat: add new feature

TEMPLATE
EOF

  cat >"$hooks_dir/pre-commit.gitx" <<'EOF'
#!/bin/sh
# gitx pre-commit hook example
# Fails commit if conflict markers are present.

if git diff --cached | grep -q '<<<<<<< HEAD'; then
  echo "Error: Conflict markers detected in staged changes."
  echo "Please resolve conflicts before committing."
  exit 1
fi

exit 0
EOF

  cat >"$hooks_dir/pre-push.gitx" <<'EOF'
#!/bin/sh
# gitx pre-push hook example
# Runs tests if a common test runner is found.

if [ -f "vendor/bin/pest" ]; then
  echo "Running Pest tests..."
  vendor/bin/pest || exit 1
elif [ -f "vendor/bin/phpunit" ]; then
  echo "Running PHPUnit tests..."
  vendor/bin/phpunit || exit 1
fi

exit 0
EOF

  chmod +x "$hooks_dir/"*.gitx

  echo "Hook templates installed:"
  echo "  - $hooks_dir/prepare-commit-msg.gitx"
  echo "  - $hooks_dir/pre-commit.gitx"
  echo "  - $hooks_dir/pre-push.gitx"

  read -rp "Activate these hooks now (copy without .gitx)? (y/n): " yn
  if [[ "$yn" == "y" ]]; then
    cp "$hooks_dir/prepare-commit-msg.gitx" "$hooks_dir/prepare-commit-msg"
    cp "$hooks_dir/pre-commit.gitx" "$hooks_dir/pre-commit"
    cp "$hooks_dir/pre-push.gitx" "$hooks_dir/pre-push"
    chmod +x "$hooks_dir/prepare-commit-msg" "$hooks_dir/pre-commit" "$hooks_dir/pre-push"
    echo "Hooks activated."
  else
    echo "You can manually enable them by copying *.gitx to hook names in .git/hooks."
  fi
}

trap "echo -e '${RED}Process interrupted. Exiting.${NC}'; exit 6" SIGINT SIGTERM

# Main script logic
cmd="${1:-}"
shift || true

case "$cmd" in
status) show_status ;;
commit) interactive_commit ;;
revert) revert_commit ;;
log-file) file_log "${1:-}" ;;
fetch) fetch_and_prune ;;
large-files) show_large_files ;;
clean) clean_untracked "$@" ;;
cherry-pick) cherry_pick_commit ;;
reset-branch) reset_branch_to_remote ;;
prune) prune_remote_branches ;;
report) fetch_prs_and_commits "$@" ;;
diff) gitx_diff "$@" ;;
stash) stash_operations "$@" ;;
wip) wip_manager "$@" ;;
create) create_branch "$@" ;;
sync) sync_branches ;;
merge) merge_branch "$@" ;;
tag) tag_release "${1:-}" ;;
cleanup) cleanup_branches ;;
orphan-branches) orphan_branches "${1:-}" ;;
compare) compare_branches "$@" ;;
config) edit_git_config ;;
summarize) summarize_repo "${1:-}" ;;
doctor) doctor_repo ;;
hooks) hooks_manager "${1:-}" ;;
commit-report) generate_commit_report "$@" ;;
worklog) generate_worklog "$@" ;;
unstage) unstage_all ;;
amend) amend_commit_message ;;
add-remote) add_remote "$@" ;;
push-remote) push_to_remote "$@" ;;
pull-remote) pull_from_remote "$@" ;;
stage-deleted) stage_deleted_files ;;
stage-deleted-dir) stage_deleted_in_directory "${1:-}" ;;
initial-commit) get_initial_commit ;;
latest-tag) get_latest_tag ;;
changelog) generate_changelog "$@" ;;
count-changes) count_changes_between_commits "$@" ;;
list-changes) list_changed_files_between_branches "$@" ;;
set-lf) set_line_endings_to_lf ;;
self-update) self_update ;;
summary) generate_git_summary "$@" ;;
*) usage ;;
esac
