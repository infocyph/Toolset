#!/bin/bash

# Fallback colors/log_action if not provided by environment
: "${RED:=}"
: "${GREEN:=}"
: "${YELLOW:=}"
: "${NC:=}"

if ! declare -F log_action >/dev/null 2>&1; then
  log_action() { :; }
fi

# Helper function for displaying usage
usage() {
  echo "Usage: gitx <command> [options]"
  echo ""
  echo "üìÇ Repository & Branch Management:"
  echo "  status                                           Show repository status, branch tracking, and remote info"
  echo "  fetch                                            Fetch remote branches and prune stale references"
  echo "  sync                                             Sync alpha and develop with master/main"
  echo "  create <branch_type> <name>                      Create a new branch from master/main"
  echo "      - branch_type: feature, bugfix, hotfix, release, docs, ci, experiment"
  echo "      - name: A short descriptive name for the branch"
  echo "  merge <source_branch> <target_branch>            Merge one branch into another"
  echo "      - source_branch: The branch to merge from"
  echo "      - target_branch: The branch to merge into"
  echo "  reset-branch                                     Reset current branch to remote state"
  echo "      - Interactive mode with soft/hard reset options"
  echo "  prune                                            Prune remote branches and delete local tracking branches"
  echo "  cleanup                                          Delete merged branches"
  echo "      - Prompts to confirm deletion"
  echo "  orphan-branches [days]                           List/delete unmerged branches older than N days (default: 30)"
  echo "  compare <branch1> <branch2>                      Compare two branches"
  echo "      - branch1: The first branch to compare (optional, default: current)"
  echo "      - branch2: The second branch to compare (optional, default: main)"
  echo ""
  echo "üì¶ Commit & Change Management:"
  echo "  commit                                           Interactive commit helper"
  echo "      - Allows selecting files and entering a commit message"
  echo "  amend                                            Amend the last commit message"
  echo "      - Optionally enter a new commit message or edit interactively"
  echo "  cherry-pick                                      Interactive cherry-pick helper"
  echo "  revert                                           Revert specific commits with options"
  echo "      - Interactive mode to select commits"
  echo "  unstage                                          Unstage all files"
  echo "      - Requires confirmation before unstaging"
  echo "  stage-deleted                                    Stage all deleted files"
  echo "  stage-deleted-dir <directory>                    Stage deleted files in a specific directory"
  echo "      - directory: Path to the directory"
  echo "  diff [output_file]                               View or save staged changes"
  echo "      - output_file: Save diff to a file (optional)"
  echo ""
  echo "üîç Tracking & Reporting:"
  echo "  log-file <file_path>                             View commit history and diffs for a specific file"
  echo "      - file_path: Path to the file to inspect"
  echo "  commit-report <start_commit..end_commit>         Generate a commit report for a commit range"
  echo "  commit-report <start_date> <end_date>            Generate a commit report for a date range"
  echo "      - dates: YYYY-MM-DD format"
  echo "  worklog <range>|<start_date> <end_date>          Generate CSV worklog for task logs"
  echo "      - range: e.g., HEAD~50..HEAD"
  echo "      - dates: YYYY-MM-DD format"
  echo "  summary [commit_range] [include-all] [mode]      Summarize commits + surviving code per author"
  echo "      - commit_range: Optional, e.g., HEAD~50"
  echo "      - include-all: Optional, include all text-based files"
  echo "      - mode: heavy (default, full blame) | lite (no blame, fast)"
  echo "  report <start_commit> [end_commit] [file]        Generate PR and commit report"
  echo "      - start_commit: The starting commit hash or tag"
  echo "      - end_commit: The ending commit hash or tag (default: HEAD)"
  echo "      - file: Output file for the report (optional)"
  echo "  count-changes <start_commit> [end_commit]        Count changes (insertions, deletions) between two commits"
  echo "  list-changes <branch1> <branch2>                 List files changed between two branches"
  echo "      - branch1: The first branch"
  echo "      - branch2: The second branch"
  echo "  changelog <start_commit> <end_commit>            Generate a changelog between commits or tags"
  echo "      - start_commit: The starting commit hash or tag"
  echo "      - end_commit: The ending commit hash or tag"
  echo ""
  echo "üîñ Tags & Releases:"
  echo "  tag <version>                                    Tag the current branch with a version (e.g., v1.0.0)"
  echo "      - version: Must follow semantic versioning (vX.Y.Z)"
  echo "  latest-tag                                       Get the latest tag in the repository"
  echo "  initial-commit                                   Get the initial commit hash"
  echo ""
  echo "üóÑÔ∏è Stashing & Cleanup:"
  echo "  stash [subcommand]                               Manage stash operations"
  echo "      - stash                      (interactive menu)"
  echo "      - stash save [msg]           Save with message (default WIP-style)"
  echo "      - stash list                 List stashes"
  echo "      - stash apply <n>            Apply stash@{n}"
  echo "      - stash pop <n>              Pop stash@{n}"
  echo "      - stash drop <n>             Drop stash@{n}"
  echo "      - stash rename <n> <name>    Rename stash@{n}"
  echo "      - stash clear                Delete all stashes"
  echo "  wip <save|list|pop|apply|clear>                  Opinionated WIP stash helper"
  echo "  clean [--force]                                 Clean untracked files and directories"
  echo "      - Interactive mode by default"
  echo "      - --force: Non-interactive full clean (git clean -fd)"
  echo "  large-files                                      Show the largest files in the repository"
  echo "      - Prompts for the number of files to display"
  echo ""
  echo "‚öôÔ∏è Configuration & Utilities:"
  echo "  add-remote <name> <url>                          Add a new remote repository"
  echo "  push-remote <remote> <branch>                    Push to a specific remote branch"
  echo "  pull-remote <remote> <branch>                    Pull from a specific remote branch"
  echo "  config                                           Edit Git configuration (add/edit/remove keys)"
  echo "  set-lf                                           Set Git to use LF line endings"
  echo "  doctor                                           Run repository health checks"
  echo "  hooks init                                       Install Git hook templates"
  echo "  self-update                                      Update gitx to the latest version"
  echo "  summarize [short]                                Repository summary (branches, tags, contributors, etc.)"
  echo ""
  echo "üîπ Example Usages:"
  echo "  gitx commit                                      # Interactive commit helper"
  echo "  gitx report v1.0.0 v2.0.0                        # Generate PR and commit report"
  echo "  gitx reset-branch                                # Reset current branch to match remote"
  echo "  gitx compare develop main                        # Compare two branches"
  echo "  gitx summary HEAD~50 include-all heavy           # Full blame, accurate surviving code"
  echo "  gitx worklog 2025-01-01 2025-01-31               # CSV worklog for a month"
  echo ""
  exit 1
}

require_sudo() {
  if [[ "$EUID" -ne 0 ]]; then
    echo -e "${RED}Please run this script with sudo or as root.${NC}"
    log_action "ERROR" "Script not run with sudo (EUID=$EUID)."
    exit 1
  fi
}

# Ensure Git repository
ensure_git_repo() {
  if ! git rev-parse --is-inside-work-tree &>/dev/null; then
    echo "Error: Not inside a Git repository."
    exit 1
  fi
}

# Unstage all files
unstage_all() {
  ensure_git_repo
  echo "WARNING: This will unstage all files!"
  read -rp "Are you sure? (y/n): " confirm
  [[ "$confirm" != "y" ]] && {
    echo "Operation cancelled."
    return
  }
  git reset --staged .
  echo "All files have been unstaged."
}

# Amend the last commit message
amend_commit_message() {
  ensure_git_repo
  read -rp "Enter the new commit message (leave blank to edit interactively): " new_message
  if [[ -z "$new_message" ]]; then
    git commit --amend
  else
    git commit --amend -m "$new_message"
  fi
  echo "Commit message amended."
}

# Add a new remote repository (CLI-first)
add_remote() {
  ensure_git_repo
  local remote_name="${1:-}"
  local remote_url="${2:-}"

  if [[ -z "$remote_name" ]]; then
    read -rp "Enter the remote name (e.g., origin): " remote_name
  fi
  if [[ -z "$remote_url" ]]; then
    read -rp "Enter the remote URL: " remote_url
  fi

  if [[ -z "$remote_name" || -z "$remote_url" ]]; then
    echo "Error: Remote name and URL are required."
    return 1
  fi

  git remote add "$remote_name" "$remote_url" && echo "Remote '$remote_name' added."
}

# Push to a specific remote branch (CLI-first)
push_to_remote() {
  ensure_git_repo
  local remote_name="${1:-}"
  local branch_name="${2:-}"

  if [[ -z "$remote_name" ]]; then
    read -rp "Enter the remote name (default: origin): " remote_name
    remote_name=${remote_name:-origin}
  fi

  if [[ -z "$branch_name" ]]; then
    read -rp "Enter the branch name to push: " branch_name
  fi

  if ! git rev-parse --verify "$branch_name" >/dev/null 2>&1; then
    echo "Error: Branch '$branch_name' does not exist."
    return 1
  fi

  git push "$remote_name" "$branch_name"
  echo "Pushed branch '$branch_name' to remote '$remote_name'."
}

# Pull from a specific remote branch (CLI-first)
pull_from_remote() {
  ensure_git_repo
  local remote_name="${1:-}"
  local branch_name="${2:-}"

  if [[ -z "$remote_name" ]]; then
    read -rp "Enter the remote name (default: origin): " remote_name
    remote_name=${remote_name:-origin}
  fi

  if [[ -z "$branch_name" ]]; then
    read -rp "Enter the branch name to pull: " branch_name
  fi

  if ! git remote | grep -qw "$remote_name"; then
    echo "Error: Remote '$remote_name' does not exist."
    return 1
  fi

  git pull "$remote_name" "$branch_name"
  echo "Pulled branch '$branch_name' from remote '$remote_name'."
}

# Stage all deleted files (safe for spaces)
stage_deleted_files() {
  ensure_git_repo

  if ! git ls-files --deleted -z | grep -q .; then
    echo "No deleted files to stage."
    return 0
  fi

  git ls-files --deleted -z | xargs -0 git add
  echo "Deleted files have been staged."
}

# Stage deleted files in a specific directory (CLI-first, safe)
stage_deleted_in_directory() {
  ensure_git_repo
  local dir_path="${1:-}"

  if [[ -z "$dir_path" ]]; then
    read -rp "Enter the directory path: " dir_path
  fi

  if [[ ! -d "$dir_path" ]]; then
    echo "Error: Directory '$dir_path' does not exist."
    return 1
  fi

  if ! git ls-files --deleted -z -- "$dir_path" | grep -q .; then
    echo "No deleted files to stage in '$dir_path'."
    return 0
  fi

  git ls-files --deleted -z -- "$dir_path" | xargs -0 git add
  echo "Deleted files in '$dir_path' have been staged."
}

# Get the initial commit hash
get_initial_commit() {
  ensure_git_repo
  local initial_commit
  initial_commit=$(git rev-list --max-parents=0 HEAD 2>/dev/null)

  if [[ -z "$initial_commit" ]]; then
    echo "Error: No commits found in this repository."
    return 1
  fi

  echo "Initial Commit: $initial_commit"
}

# Get the latest tag in the repository
get_latest_tag() {
  ensure_git_repo
  local latest_tag
  latest_tag=$(git describe --tags --abbrev=0 2>/dev/null)

  if [[ -z "$latest_tag" ]]; then
    echo "No tags found in this repository."
    return 1
  fi

  echo "Latest Tag: $latest_tag"
}

# Detect master/main branch
detect_main_branch() {
  if git symbolic-ref refs/remotes/origin/HEAD &>/dev/null; then
    git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'
  elif git branch -r | grep -q "origin/main"; then
    echo "main"
  elif git branch -r | grep -q "origin/trunk"; then
    echo "trunk"
  else
    echo "master"
  fi
}

# Generate a changelog between two commits or tags (CLI-first)
generate_changelog() {
  ensure_git_repo
  local start_ref="${1:-}"
  local end_ref="${2:-}"

  if [[ -z "$start_ref" ]]; then
    read -rp "Enter the start commit or tag: " start_ref
  fi
  if [[ -z "$end_ref" ]]; then
    read -rp "Enter the end commit or tag (default: HEAD): " end_ref
    end_ref=${end_ref:-HEAD}
  fi

  local safe_start safe_end changelog_file
  safe_start=${start_ref//\//_}
  safe_end=${end_ref//\//_}
  changelog_file="changelog_${safe_start}_to_${safe_end}.txt"

  git log "$start_ref..$end_ref" --pretty=format:"%h - %s (%an, %ad)" --date=short >"$changelog_file"
  echo "Changelog saved to $changelog_file."
}

# Count changes between two commits (CLI-first)
count_changes_between_commits() {
  ensure_git_repo
  local start_commit="${1:-}"
  local end_commit="${2:-HEAD}"

  if [[ -z "$start_commit" ]]; then
    read -rp "Enter the start commit: " start_commit
  fi
  if [[ -z "$end_commit" ]]; then
    end_commit="HEAD"
  fi

  local changes_count
  changes_count=$(git diff --shortstat "$start_commit" "$end_commit")
  echo "Changes between $start_commit and $end_commit: $changes_count"
}

# List files changed between two branches (CLI-first)
list_changed_files_between_branches() {
  ensure_git_repo
  local branch1="${1:-}"
  local branch2="${2:-}"

  if [[ -z "$branch1" ]]; then
    read -rp "Enter the first branch: " branch1
  fi
  if [[ -z "$branch2" ]]; then
    read -rp "Enter the second branch: " branch2
  fi

  echo "Files changed between $branch1 and $branch2:"
  git diff --name-only "$branch1" "$branch2"
}

# Set Git to use LF line endings
set_line_endings_to_lf() {
  ensure_git_repo
  git config --global core.autocrlf false
  echo "Configured Git to use LF line endings."
}

# Create a new branch from master/main
create_branch() {
  local branch_type=$1
  local name=$2
  ensure_git_repo

  if [[ -z "$branch_type" || -z "$name" ]]; then
    echo "Error: Branch type and name are required."
    return 1
  fi

  local branch_name="${branch_type}/${name}"

  if git show-ref --verify --quiet "refs/heads/$branch_name"; then
    echo "Error: Branch '$branch_name' already exists."
    return 1
  fi

  local main_branch
  main_branch="$(detect_main_branch)"

  if [[ $(git rev-parse --abbrev-ref HEAD) != "$main_branch" ]]; then
    echo "Switching to main branch ($main_branch) and pulling latest changes..."
    git checkout "$main_branch" && git pull origin "$main_branch"
  fi

  git checkout -b "$branch_name"
  git push origin "$branch_name"
  echo "Branch created: $branch_name"
}

# Sync alpha and develop with master/main
sync_branches() {
  ensure_git_repo
  local main_branch
  main_branch=$(detect_main_branch)

  echo "Syncing branches with $main_branch..."

  local branches=("alpha" "develop")
  read -rp "Do you want to sync additional branches? (y/n): " sync_more
  if [[ "$sync_more" == "y" ]]; then
    read -rp "Enter branches to sync (comma-separated): " additional_branches
    IFS=',' read -r -a user_branches <<<"$additional_branches"
    branches+=("${user_branches[@]}")
  fi

  git checkout "$main_branch" && git pull origin "$main_branch"

  for branch in "${branches[@]}"; do
    if git show-ref --verify --quiet "refs/heads/$branch"; then
      echo "Merging $main_branch into $branch..."
      git checkout "$branch" && git merge --no-ff "$main_branch" && git push origin "$branch"
      echo "Synced $branch with $main_branch."
    else
      echo "Branch '$branch' does not exist. Skipping..."
    fi
  done
}

# Merge branches
merge_branch() {
  local source=$1
  local target=$2
  ensure_git_repo

  if [[ -z "$source" || -z "$target" ]]; then
    echo "Error: Source and target branches are required."
    return 1
  fi

  if ! git show-ref --verify --quiet "refs/heads/$source" || ! git show-ref --verify --quiet "refs/heads/$target"; then
    echo "Error: One or both branches do not exist."
    return 1
  fi

  echo "About to merge '$source' into '$target'."
  read -rp "Are you sure? (y/n): " confirm
  [[ "$confirm" != "y" ]] && {
    echo "Merge cancelled."
    return
  }

  git checkout "$target" && git pull origin "$target"

  echo "Merging $source into $target..."
  if ! git merge --no-ff "$source"; then
    echo "Merge conflicts detected. Resolve them and commit manually."
    echo "Run 'git merge --abort' to cancel the merge."
    return 1
  fi

  git push origin "$target"
  echo "Successfully merged $source into $target."
}

# Tag a release
tag_release() {
  local version=$1
  ensure_git_repo

  if [[ -z "$version" ]]; then
    echo "Error: Version is required for tagging."
    return 1
  fi

  if ! [[ "$version" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    echo "Error: Version format must be 'vX.Y.Z' (e.g., v1.0.0)."
    return 1
  fi

  if git rev-parse "refs/tags/$version" >/dev/null 2>&1; then
    echo "Error: Tag '$version' already exists."
    return 1
  fi

  echo "Creating tag '$version'..."
  git tag -a "$version" -m "Release $version" && git push origin "$version"
  echo "Tag '$version' created successfully."
}

# Cleanup merged branches
cleanup_branches() {
  ensure_git_repo
  echo "Merged branches (excluding main branches):"
  local merged_branches
  merged_branches=$(git branch --merged | grep -vE "(^\*|master|main|develop|alpha)")

  if [[ -z "$merged_branches" ]]; then
    echo "No merged branches found."
    return 0
  fi

  echo "$merged_branches"
  read -rp "Do you want to delete all merged branches? (y/n): " delete_all

  if [[ "$delete_all" == "y" ]]; then
    echo "$merged_branches" | xargs git branch -d
    echo "Deleted all merged branches."
  else
    echo "$merged_branches" | while read -r branch; do
      read -rp "Delete branch '$branch'? (y/n): " confirm
      [[ "$confirm" == "y" ]] && git branch -d "$branch"
    done
  fi
}

# Orphan branches (not merged into main, older than N days)
orphan_branches() {
  ensure_git_repo
  local days="${1:-30}"
  local base_branch
  base_branch=$(detect_main_branch)
  local now epoch_now
  epoch_now=$(date +%s)

  echo "Looking for branches NOT merged into '$base_branch' and older than ${days} days..."
  local found=0
  git for-each-ref --format='%(refname:short)|%(committerdate:unix)' refs/heads/ |
    while IFS='|' read -r branch epoch; do
      case "$branch" in
      master | main | develop | alpha | trunk) continue ;;
      esac
      # Skip branches already merged into base
      if git merge-base --is-ancestor "$branch" "$base_branch" 2>/dev/null; then
        continue
      fi
      local age_days=$(((epoch_now - epoch) / 86400))
      if ((age_days >= days)); then
        echo "$branch (last commit: $age_days days ago)"
        found=1
      fi
    done

  if [[ "$found" -eq 0 ]]; then
    echo "No orphan branches found for threshold ${days} days."
    return 0
  fi

  echo ""
  read -rp "Do you want to delete any of these branches? (y/n): " yn
  [[ "$yn" != "y" ]] && return 0

  read -rp "Enter branch names to delete (space-separated) or 'all': " to_del
  if [[ "$to_del" == "all" ]]; then
    git for-each-ref --format='%(refname:short)|%(committerdate:unix)' refs/heads/ |
      while IFS='|' read -r branch epoch; do
        case "$branch" in
        master | main | develop | alpha | trunk) continue ;;
        esac
        if git merge-base --is-ancestor "$branch" "$base_branch" 2>/dev/null; then
          continue
        fi
        local age_days=$(((epoch_now - epoch) / 86400))
        if ((age_days >= days)); then
          echo "Deleting $branch..."
          git branch -D "$branch"
        fi
      done
  else
    for b in $to_del; do
      echo "Deleting $b..."
      git branch -D "$b"
    done
  fi
}

# Fetch PRs, Non-PR Merges, and Standalone Commits
fetch_prs_and_commits() {
  local start_commit="$1"
  local end_commit="${2:-HEAD}"
  local output_file="${3:-pr_report_${start_commit}_to_${end_commit}.txt}"

  ensure_git_repo

  if [[ -z "$start_commit" ]]; then
    echo "‚ùå Error: Start commit is required."
    read -rp "Enter the start commit hash: " start_commit
  fi

  local commit_range="${start_commit}..${end_commit}"
  echo "üöÄ Generating PR and commit report for range: $commit_range"
  echo "üìÅ Saving output to: $output_file"

  {
    echo "PRs, Non-PR Merges, and Standalone Commits Report"
    echo ""

    echo "1Ô∏è‚É£ PRs:"
    echo ""
    git log --merges --pretty=format:"%h|%s|%b|%an|%ae|%ad" "$commit_range" | grep "Merge pull request" | while IFS= read -r merge_commit; do
      local merge_hash pr_details
      merge_hash=$(echo "$merge_commit" | cut -d'|' -f1)
      pr_details=$(echo "$merge_commit" | cut -d'|' -f2-)
      echo "üîπ Merge Commit: $merge_hash | $pr_details"
      echo "   PR Contains the following commits:"
      git log "${merge_hash}^1..${merge_hash}" --no-merges --pretty=format:"   - %h | %s | %an (%ad)"
      echo ""
    done

    echo "2Ô∏è‚É£ Non-PR Merges:"
    echo ""
    git log --merges --pretty=format:"%h|%s|%b|%an|%ae|%ad" "$commit_range" | grep -v "Merge pull request" | while IFS= read -r merge_commit; do
      local merge_hash merge_details
      merge_hash=$(echo "$merge_commit" | cut -d'|' -f1)
      merge_details=$(echo "$merge_commit" | cut -d'|' -f2-)
      echo "üîπ Merge Commit: $merge_hash | $merge_details"
      echo "   Contains the following commits:"
      git log "${merge_hash}^1..${merge_hash}" --no-merges --pretty=format:"   - %h | %s | %an (%ad)"
      echo ""
    done

    echo "3Ô∏è‚É£ Standalone Commits:"
    echo ""

    local all_commits merge_commits standalone_commits
    all_commits=$(git log --no-merges --pretty=format:"%h" "$commit_range")
    merge_commits=$(git log --merges --pretty=format:"%h" "$commit_range" | while IFS= read -r merge_commit; do
      git log "${merge_commit}^1..${merge_commit}" --no-merges --pretty=format:"%h"
    done)

    standalone_commits=$(comm -23 <(echo "$all_commits" | sort) <(echo "$merge_commits" | sort))

    for commit in $standalone_commits; do
      git log -n 1 --pretty=format:"üî∏ %h | %s | %an (%ad)" "$commit"
    done

    echo ""
  } | tee "$output_file"

  echo "‚úÖ Report generated in $output_file"
}

# Unified stash operations (CLI + interactive)
stash_operations() {
  ensure_git_repo
  local sub="${1:-}"
  shift || true

  if [[ -n "$sub" ]]; then
    case "$sub" in
    save)
      local msg="$*"
      local timestamp branch_name stash_name
      timestamp=$(date +"%Y-%m-%d_%H-%M-%S")
      branch_name=$(git rev-parse --abbrev-ref HEAD)
      if [[ -z "$msg" ]]; then
        stash_name="Stash on $branch_name @ $timestamp"
      else
        stash_name="$msg"
      fi
      git stash push -m "$stash_name"
      echo "‚úÖ Changes stashed as: $stash_name"
      ;;
    list)
      git stash list
      ;;
    apply)
      local n="${1:-0}"
      git stash apply "stash@{$n}"
      ;;
    pop)
      local n="${1:-0}"
      git stash pop "stash@{$n}"
      ;;
    drop)
      local n="${1:-0}"
      git stash drop "stash@{$n}"
      ;;
    rename)
      local n="${1:-}"
      local new_name="${2:-}"
      if [[ -z "$n" || -z "$new_name" ]]; then
        echo "Usage: gitx stash rename <n> <new_name>"
        return 1
      fi
      git stash store -m "$new_name" "stash@{$n}"
      ;;
    clear)
      git stash clear
      echo "‚úÖ All stashes deleted."
      ;;
    *)
      echo "Unknown stash subcommand: $sub"
      echo "Use: save|list|apply|pop|drop|rename|clear or run 'gitx stash' for interactive mode."
      return 1
      ;;
    esac
    return 0
  fi

  # Interactive menu
  echo "üöÄ Stash Manager:"
  echo "1. Save changes to stash"
  echo "2. List stashes"
  echo "3. Apply a stash"
  echo "4. Pop (apply & delete) a stash"
  echo "5. Drop a stash"
  echo "6. Rename a stash"
  echo "7. Delete all stashes"
  read -rp "Enter your choice: " choice

  case $choice in
  1)
    local timestamp branch_name stash_name
    timestamp=$(date +"%Y-%m-%d_%H-%M-%S")
    branch_name=$(git rev-parse --abbrev-ref HEAD)
    stash_name="Stash on $branch_name @ $timestamp"
    git stash push -m "$stash_name"
    echo "‚úÖ Changes stashed as: $stash_name"
    ;;
  2) git stash list ;;
  3)
    git stash list
    read -rp "Enter stash number to apply: " stash_number
    git stash apply "stash@{$stash_number}"
    ;;
  4)
    git stash list
    read -rp "Enter stash number to pop: " stash_number
    git stash pop "stash@{$stash_number}"
    ;;
  5)
    git stash list
    read -rp "Enter stash number to drop: " stash_number
    git stash drop "stash@{$stash_number}"
    ;;
  6)
    git stash list
    read -rp "Enter stash number to rename: " stash_number
    read -rp "Enter new stash name: " new_name
    git stash store -m "$new_name" "stash@{$stash_number}"
    ;;
  7)
    read -rp "Are you sure you want to delete all stashes? (y/n): " confirm
    [[ "$confirm" == "y" ]] && git stash clear && echo "‚úÖ All stashes deleted."
    ;;
  *) echo "‚ùå Invalid choice." ;;
  esac
}

# WIP helper (sugar around stash)
wip_manager() {
  ensure_git_repo
  local action="${1:-}"
  shift || true

  case "$action" in
  save)
    local msg="$*"
    local ts branch
    ts=$(date +"%Y-%m-%d_%H-%M-%S")
    branch=$(git rev-parse --abbrev-ref HEAD)
    local name="WIP: ${branch} @ ${ts}"
    [[ -n "$msg" ]] && name+=" - $msg"
    git stash push -m "$name"
    echo "‚úÖ WIP stashed as: $name"
    ;;
  list)
    git stash list | grep "WIP:" || echo "No WIP stashes."
    ;;
  pop)
    git stash pop
    ;;
  apply)
    git stash apply
    ;;
  clear)
    git stash clear
    echo "‚úÖ All stashes (including WIP) cleared."
    ;;
  *)
    echo "Usage: gitx wip <save|list|pop|apply|clear> [message]"
    ;;
  esac
}

# Compare branches (CLI-first)
compare_branches() {
  ensure_git_repo
  local branch1="${1:-}"
  local branch2="${2:-}"

  if [[ -z "$branch1" ]]; then
    read -rp "Enter the first branch to compare (default: current branch): " branch1
    branch1=${branch1:-$(git rev-parse --abbrev-ref HEAD)}
  fi

  if [[ -z "$branch2" ]]; then
    read -rp "Enter the second branch to compare (default: main): " branch2
    branch2=${branch2:-$(detect_main_branch)}
  fi

  if ! git show-ref --verify --quiet "refs/heads/$branch1" || ! git show-ref --verify --quiet "refs/heads/$branch2"; then
    echo "Error: One or both branches do not exist."
    return 1
  fi

  echo "Commits unique to each branch:"
  git log --oneline "$branch1".."$branch2"
  echo "Files changed between branches:"
  git diff --name-only "$branch1".."$branch2"
}

# Git configuration editor
edit_git_config() {
  echo "Current Git Configuration:"
  git config --list
  echo "Options:"
  echo "1. Add/Edit a key"
  echo "2. Remove a key"
  read -rp "Enter your choice: " choice

  case $choice in
  1)
    read -rp "Enter the key you want to add/edit: " key
    if [[ -n "$key" ]]; then
      read -rp "Enter the new value for $key: " value
      git config --global "$key" "$value"
      echo "Updated $key to $value globally."
    else
      echo "No changes made."
    fi
    ;;
  2)
    read -rp "Enter the key you want to remove: " key
    if [[ -n "$key" ]]; then
      git config --global --unset "$key"
      echo "Removed key: $key"
    else
      echo "No changes made."
    fi
    ;;
  *)
    echo "Invalid choice."
    ;;
  esac
}

summarize_repo() {
  ensure_git_repo
  local mode="${1:-full}"

  echo "Repository Summary:"
  echo "===================="
  echo "Current Branch: $(git rev-parse --abbrev-ref HEAD)"
  echo "Latest Commit: $(git log -1 --pretty=format:'%h - %s (%an, %ad)' --date=short)"
  echo "Total Commits: $(git rev-list --count HEAD)"
  echo "Number of Tags: $(git tag | wc -l)"
  echo "Number of Stashes: $(git stash list | wc -l)"
  echo "Repository Size: $(du -sh .git 2>/dev/null | awk '{print $1}')"
  echo "Remotes:"
  git remote -v | awk '{print "  - " $1 " -> " $2}' | sort | uniq

  if [[ "$mode" != "short" ]]; then
    echo "Branches:"
    git branch -a
    echo ""
    echo "Contributors:"
    git shortlog -sne | awk '{printf "%s %s (%s commits)\n", $2, $3, $1}'
    echo ""
  fi
}

track_staged_changes() {
  local diff_file="${1:-diffs.txt}"

  ensure_git_repo
  echo "Choose an action:"
  echo "1. Save staged changes to a file"
  echo "2. View staged changes inline"
  read -rp "Enter your choice: " choice

  case $choice in
  1)
    if [[ -f "$diff_file" ]]; then
      read -rp "File $diff_file already exists. Overwrite? (y/n): " overwrite
      if [[ "$overwrite" != "y" ]]; then
        echo "Aborting save operation."
        return
      fi
    fi
    git --no-pager diff --cached >"$diff_file"
    if [[ -s "$diff_file" ]]; then
      echo "Staged changes saved to $diff_file"
    else
      echo "No changes are currently staged."
    fi
    ;;
  2)
    git --no-pager diff --cached
    ;;
  *)
    echo "Invalid choice."
    ;;
  esac
}

cherry_pick_commit() {
  ensure_git_repo
  echo "Recent Commit History:"
  git log --oneline | nl -w2 -s". " | tee /tmp/git_log.txt

  read -rp "Enter the numbers of the commits to cherry-pick (comma-separated): " commit_numbers
  local commit_hashes
  commit_hashes=$(echo "$commit_numbers" | tr ',' '\n' | while read -r num; do
    sed -n "${num}p" /tmp/git_log.txt | awk '{print $2}'
  done)

  if [[ -z "$commit_hashes" ]]; then
    echo "No valid commits selected. Exiting."
    return
  fi

  for commit in $commit_hashes; do
    git cherry-pick "$commit" || {
      echo "Conflict detected during cherry-pick of $commit."
      read -rp "Do you want to resolve conflicts manually or abort? (resolve/abort): " action
      if [[ "$action" == "abort" ]]; then
        git cherry-pick --abort
        echo "Cherry-pick aborted."
        return
      fi
    }
    echo "Cherry-picked commit: $commit"
  done
}

clean_untracked() {
  ensure_git_repo
  local mode="${1:-}"

  if [[ "$mode" == "--force" || "$mode" == "force" ]]; then
    echo "Running non-interactive clean: git clean -fd"
    git clean -fd
    echo "Untracked files and directories cleaned."
    return 0
  fi

  echo "Choose an action:"
  echo "1. Preview untracked files and directories (dry-run)"
  echo "2. Clean untracked files and directories"
  read -rp "Enter your choice: " choice

  case $choice in
  1)
    echo "Preview of untracked files and directories:"
    git clean -fdn
    ;;
  2)
    echo "This action will permanently delete untracked files and directories."
    read -rp "Are you sure you want to proceed? (y/n): " confirm
    if [[ "$confirm" == "y" ]]; then
      git clean -fd
      echo "Untracked files and directories cleaned."
    else
      echo "Operation canceled."
    fi
    ;;
  *)
    echo "Invalid choice."
    ;;
  esac
}

show_large_files() {
  ensure_git_repo

  read -rp "How many large files do you want to display? (default 10): " count
  count=${count:-10}

  echo "Choose an action:"
  echo "1. Display results inline"
  echo "2. Save results to a file"
  read -rp "Enter your choice: " choice

  local cmd="
    git rev-list --objects --all |
    git cat-file --batch-check='%(objecttype) %(objectname) %(objectsize) %(rest)' |
    awk '\$1 == \"blob\" {print \$3, \$4}' |
    sort -k1 -nr |
    head -${count}
  "

  case $choice in
  1)
    echo "Top $count largest files in the repository:"
    eval "$cmd" | awk '{printf "%s bytes  %s\n", $1, $2}'
    ;;
  2)
    read -rp "Enter the output file name (default: large_files.txt): " output_file
    output_file=${output_file:-large_files.txt}
    eval "$cmd" | awk '{printf "%s bytes  %s\n", $1, $2}' >"$output_file"
    echo "Results saved to $output_file"
    ;;
  *)
    echo "Invalid choice."
    ;;
  esac
}

fetch_and_prune() {
  ensure_git_repo
  echo "Fetching remote branches and pruning stale references..."
  git fetch --prune
  echo "Done."
}

# File log (CLI-first)
file_log() {
  ensure_git_repo
  local file_path="${1:-}"

  if [[ -z "$file_path" ]]; then
    read -rp "Enter the file path to view its history: " file_path
  fi

  if [[ ! -f "$file_path" ]]; then
    echo "‚ùå Error: File '$file_path' does not exist."
    return 1
  fi

  echo "üìå Choose an action:"
  echo "1. View commit history of the file"
  echo "2. View diffs for commits affecting the file"
  read -rp "Enter your choice: " choice

  case $choice in
  1)
    echo "üìå Commit history for $file_path:"
    git log --follow --pretty=format:"%h - %s (%an, %ad)" --date=short -- "$file_path"
    ;;
  2)
    echo "üìå Diffs for commits affecting $file_path:"
    git log --follow -p -- "$file_path"
    ;;
  *) echo "‚ùå Invalid choice." ;;
  esac
}

revert_commit() {
  ensure_git_repo
  echo "üìå Recent Commit History:"
  git log --oneline | nl -w2 -s". " | tee /tmp/git_log.txt

  read -rp "Enter the numbers of the commits to revert (comma-separated): " commit_numbers

  local commit_hashes
  commit_hashes=$(echo "$commit_numbers" | tr ',' '\n' | while read -r num; do
    sed -n "${num}p" /tmp/git_log.txt | awk '{print $2}'
  done)

  if [[ -z "$commit_hashes" ]]; then
    echo "‚ùå No valid commits selected."
    return 1
  fi

  echo "üìå Choose an action:"
  echo "1. Create revert commits for each selected commit"
  echo "2. Revert and amend the last commit"
  read -rp "Enter your choice: " choice

  case $choice in
  1)
    for commit in $commit_hashes; do
      git revert "$commit" || {
        echo "‚ö†Ô∏è Conflict detected while reverting $commit. Resolve manually."
        exit 1
      }
      echo "‚úÖ Reverted commit: $commit"
    done
    ;;
  2)
    for commit in $commit_hashes; do
      git revert --no-commit "$commit"
    done
    git commit --amend -m "Amended revert: $(git log -1 --pretty=%B)"
    echo "‚úÖ Reverted commits and amended the last commit."
    ;;
  *) echo "‚ùå Invalid choice." ;;
  esac
}

reset_branch_to_remote() {
  ensure_git_repo
  local branch
  branch=$(git rev-parse --abbrev-ref HEAD)

  if ! git ls-remote --exit-code origin "$branch" &>/dev/null; then
    echo "‚ùå Error: Remote branch '$branch' does not exist."
    return 1
  fi

  echo "üö® WARNING: This will reset '$branch' to match 'origin/$branch'."
  echo "1. Soft reset (keep local changes)"
  echo "2. Hard reset (discard all local changes)"
  echo "3. Dry-run (preview only)"
  read -rp "Enter your choice: " reset_type

  case $reset_type in
  1)
    git fetch origin && git reset --soft "origin/$branch" && echo "‚úÖ Soft reset completed."
    ;;
  2)
    read -rp "Are you sure? This will discard ALL local changes. (y/n): " confirm
    [[ "$confirm" == "y" ]] && git fetch origin && git reset --hard "origin/$branch" && echo "‚úÖ Hard reset completed."
    ;;
  3)
    git fetch origin && git diff --stat "origin/$branch"
    ;;
  *) echo "‚ùå Invalid choice." ;;
  esac
}

prune_remote_branches() {
  ensure_git_repo
  echo "üöÄ Fetching and pruning stale remote branches..."
  git fetch --prune

  echo "üóëÔ∏è Checking for deleted remote branches..."
  local deleted_branches
  deleted_branches=$(git branch -vv | awk '/: gone]/{print $1}')

  if [[ -z "$deleted_branches" ]]; then
    echo "‚úÖ No local branches need pruning."
    return 0
  fi

  echo "$deleted_branches"
  read -rp "Do you want to delete all these branches? (y/n): " delete_all

  if [[ "$delete_all" == "y" ]]; then
    echo "$deleted_branches" | xargs git branch -D
    echo "‚úÖ Deleted all local branches tracking removed remote branches."
  else
    echo "$deleted_branches" | while read -r branch; do
      read -rp "Delete branch '$branch'? (y/n): " confirm
      [[ "$confirm" == "y" ]] && git branch -D "$branch"
    done
  fi
}

interactive_commit() {
  ensure_git_repo

  if [[ -z $(git status --porcelain) ]]; then
    echo "‚úÖ No changes to commit."
    return 0
  fi

  echo "üìå Select files to stage (use numbers):"
  git status -s | nl -w2 -s". " | tee /tmp/git_status.txt

  read -rp "Enter file numbers to stage (comma-separated, 'a' for all): " file_numbers

  if [[ "$file_numbers" == "a" ]]; then
    git add .
  else
    local selected_files
    selected_files=$(echo "$file_numbers" | tr ',' '\n' | while read -r num; do
      sed -n "${num}p" /tmp/git_status.txt | awk '{print $2}'
    done)
    # shellcheck disable=SC2086
    git add $selected_files
  fi

  echo "üìå Staged files:"
  git diff --cached --name-only

  read -rp "Enter your commit message: " commit_message
  git commit -m "$commit_message"
  echo "‚úÖ Committed changes with message: $commit_message"
}

show_status() {
  ensure_git_repo
  echo "üöÄ Repository Status:"
  git status -sb --untracked-files=all
  echo ""
  echo "üìå Branch Tracking Info:"
  git rev-list --left-right --count @{upstream}...HEAD 2>/dev/null || echo "No upstream branch set."
  echo ""
  echo "üåç Remote Status:"
  git remote -v | awk '{print "  - " $1 " -> " $2}' | sort | uniq
}

# Author summary (surviving code %) with heavy/lite modes
generate_git_summary() {
  ensure_git_repo

  local arg1="${1:-}"
  local arg2="${2:-}"
  local arg3="${3:-}"

  local range_arg=""
  local include_all=false
  local mode="heavy"

  for a in "$arg1" "$arg2" "$arg3"; do
    case "$a" in
    "") ;;
    include-all) include_all=true ;;
    heavy | HEAVY) mode="heavy" ;;
    lite | LITE | fast | no-blame) mode="lite" ;;
    *)
      if [[ -z "$range_arg" ]]; then
        range_arg="$a"
      fi
      ;;
    esac
  done

  local log_range=""
  if [[ -n "$range_arg" ]]; then
    log_range="${range_arg}..HEAD"
  fi

  local heavy_flag=1
  [[ "$mode" == "lite" ]] && heavy_flag=0

  local temp_file
  temp_file="$(mktemp)"

  git --no-pager log --no-merges ${log_range} \
    --pretty='>>%h|%ce|%ct|%s|%aN' --shortstat |
    awk -F'|' '
    BEGIN { email=""; name=""; }
    /^>>/ {
      email=$2; name=$5;
      print email "|" name "|commit" >> "'"$temp_file"'"
      next
    }
    /files changed/ {
      files=ins=del=0
      for (i=1; i<=NF; i++) {
        if ($i ~ /^[0-9]+$/ && $(i+1) ~ /^files?/) files=$i
        if ($i ~ /^[0-9]+$/ && $(i+1) ~ /^insertion/) ins=$i
        if ($i ~ /^[0-9]+$/ && $(i+1) ~ /^deletion/) del=$i
      }
      print email "|" name "|" files "|" ins "|" del >> "'"$temp_file"'"
    }
  '

  local blame_file
  blame_file="$(mktemp)"

  if ((heavy_flag)); then
    # Heavy mode: blame over entire repo (accurate surviving code)
    local files_to_blame
    files_to_blame="$(git ls-files)"

    files_to_blame="$(printf '%s\n' "$files_to_blame" | while read -r f; do
      [[ -z "$f" ]] && continue
      local mime
      mime=$(file --mime-type -b "$f" 2>/dev/null || true)
      if [[ "$include_all" == true && "$mime" =~ ^text/ ]]; then
        echo "$f"
      else
        case "$f" in
        *.sh | *.py | *.js | *.ts | *.go | *.java | *.c | *.cpp | *.php | *.rb | *.html | *.css | *.scss | *.sql | *.xml | *.json | *.yaml | *.yml | *.md | *.toml | *.ini | *.cfg | *.conf | *.properties | Makefile | makefile | Dockerfile | .env | .gitignore)
          echo "$f"
          ;;
        esac
      fi
    done)"

    if [[ -n "$files_to_blame" ]]; then
      local jobs
      if command -v nproc >/dev/null 2>&1; then
        jobs="$(nproc)"
      else
        jobs=4
      fi

      printf '%s\n' "$files_to_blame" | xargs -P"$jobs" -I{} git blame --line-porcelain "{}" 2>/dev/null |
        grep -E "^author-mail" >"$blame_file"
    fi
  fi

  echo "| Author Name | Author Email | Commits | Files Changed | Insertions | Deletions | Surviving Code % |"
  echo "|------------|--------------|---------|--------------|-----------|----------|-------------------|"

  awk -F'|' -v blame_file="$blame_file" -v heavy_mode="$heavy_flag" '
    BEGIN {
      total_surviving = 0
      if (heavy_mode == 1) {
        while ((getline line < blame_file) > 0) {
          split(line, arr, " ")
          author_email = arr[2]
          gsub(/[<>]/, "", author_email)
          surviving_lines[author_email]++
          total_surviving++
        }
        close(blame_file)
      }
    }
    {
      if ($3 == "commit") {
        commits[$1]++
        authors[$1] = $2
      } else {
        files_changed[$1] += $3
        insertions[$1]   += $4
        deletions[$1]    += $5
      }
    }
    END {
      total_commits = 0
      total_files = 0
      total_ins = 0
      total_del = 0

      for (email in commits) {
        ins = insertions[email] + 0
        surv = 0
        surv_str = "N/A"
        if (heavy_mode == 1 && total_surviving > 0 && ins > 0 && surviving_lines[email] > 0) {
          surv = int((surviving_lines[email] / total_surviving) * 100)
          surv_str = surv "%"
        }
        print "| " authors[email] " | " email " | " commits[email] " | " files_changed[email] " | " insertions[email] " | " deletions[email] " | " surv_str " |"

        total_commits += commits[email]
        total_files   += files_changed[email]
        total_ins     += insertions[email]
        total_del     += deletions[email]
      }

      if (total_commits > 0) {
        if (heavy_mode == 1 && total_surviving > 0) {
          total_surv_str = "100%"
        } else {
          total_surv_str = "N/A"
        }
        print "| TOTAL | - | " total_commits " | " total_files " | " total_ins " | " total_del " | " total_surv_str " |"
      }
    }
  ' "$temp_file"

  rm -f "$temp_file" "$blame_file"
}

# Commit report (range or date-based)
generate_commit_report() {
  ensure_git_repo

  local git_log_output
  if [[ $# -eq 1 ]]; then
    local range="$1"
    git_log_output=$(git --no-pager log --no-merges "$range" --pretty='>>%h|%ce|%ct|%s|%b|%aN')
  elif [[ $# -eq 2 ]]; then
    local start_date="$1" end_date="$2"
    if ! [[ "$start_date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] || ! [[ "$end_date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
      echo "Error: Dates must be in YYYY-MM-DD format."
      return 1
    fi
    git_log_output=$(git --no-pager log --no-merges \
      --after="${start_date} 00:00" --before="${end_date} 23:59" \
      --pretty='>>%h|%ce|%ct|%s|%b|%aN')
  else
    echo "Usage:"
    echo "  gitx commit-report <start_commit..end_commit>"
    echo "  gitx commit-report <start_date> <end_date>   (YYYY-MM-DD)"
    return 1
  fi

  if [[ -z "$git_log_output" ]]; then
    echo "No commits found."
    return 0
  fi

  printf '%s\n' "$git_log_output" | awk -F'|' '
    BEGIN {
      print "# Commit Report\n"
    }
    /^>>/ {
      line = substr($0, 3)
      n = split(line, parts, "|")
      commit_id   = parts[1]
      email       = parts[2]
      ts          = parts[3]
      subject     = parts[4]
      body        = (n >= 5 ? parts[5] : "")
      author_name = (n >= 6 ? parts[6] : email)

      clean_subject = subject
      gsub(/^:[^:]+: /, "", clean_subject)
      match(clean_subject, /^(feature|feat|fix|bugfix|hotfix|chore|docs|style|refactor|perf|test|ci|build|revert|BREAKING CHANGE)(\([^)]+\))?:/, m)
      type = (m[1] != "" ? m[1] : "misc")

      gsub(/\|/, "\\|", subject)
      gsub(/\|/, "\\|", body)
      gsub(/\r/, "", body)
      gsub(/ +- /, "\n- ", body)
      gsub(/ +-/, "\n- ", body)
      gsub(/\n+/, "<br>", body)

      if (length(body) > 0) {
        subject_body = subject "<br><br>" body
      } else {
        subject_body = subject
      }
      gsub(/\|/, "\\|", subject_body)

      if (!(email in author_seen)) {
        author_seen[email] = 1
        order_count++
        author_order[order_count]    = email
        author_name_map[email]       = author_name
        author_email_map[email]      = email
      }

      author_count[email]++
      formatted_time = strftime("%Y-%m-%d %H:%M:%S", ts)
      author_details[email] = author_details[email] "| " commit_id " | " type " | " subject_body " | " formatted_time " |\n"
    }
    END {
      for (i = 1; i <= order_count; i++) {
        email = author_order[i]
        name  = author_name_map[email]
        print "### " name
        print "- Email: " email
        print "- Number of Commits: " author_count[email]
        print ""
        print "| Commit Id | Type | Subject & Body | Date & Time |"
        print "| --- | --- | --- | --- |"
        printf "%s\n", author_details[email]
        print ""
      }
    }
  '
}

# Worklog: CSV-oriented report for task logs
generate_worklog() {
  ensure_git_repo

  local git_log_output
  if [[ $# -eq 1 ]]; then
    local range="$1"
    git_log_output=$(git --no-pager log --no-merges "$range" --pretty='>>%h|%ce|%ct|%s|%b|%aN')
  elif [[ $# -eq 2 ]]; then
    local start_date="$1" end_date="$2"
    if ! [[ "$start_date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] || ! [[ "$end_date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
      echo "Error: Dates must be in YYYY-MM-DD format."
      return 1
    fi
    git_log_output=$(git --no-pager log --no-merges \
      --after="${start_date} 00:00" --before="${end_date} 23:59" \
      --pretty='>>%h|%ce|%ct|%s|%b|%aN')
  else
    echo "Usage:"
    echo "  gitx worklog <start_commit..end_commit>"
    echo "  gitx worklog <start_date> <end_date>   (YYYY-MM-DD)"
    return 1
  fi

  if [[ -z "$git_log_output" ]]; then
    echo "No commits found."
    return 0
  fi

  echo "Author,Email,CommitId,Type,DateTime,Subject,Body"

  printf '%s\n' "$git_log_output" | awk -F'|' '
    function esc_csv(s,  r) {
      gsub(/"/, "\"\"", s)
      return "\"" s "\""
    }
    /^>>/ {
      line = substr($0, 3)
      n = split(line, parts, "|")
      commit_id   = parts[1]
      email       = parts[2]
      ts          = parts[3]
      subject     = parts[4]
      body        = (n >= 5 ? parts[5] : "")
      author_name = (n >= 6 ? parts[6] : email)

      clean_subject = subject
      gsub(/^:[^:]+: /, "", clean_subject)
      match(clean_subject, /^(feature|feat|fix|bugfix|hotfix|chore|docs|style|refactor|perf|test|ci|build|revert|BREAKING CHANGE)(\([^)]+\))?:/, m)
      type = (m[1] != "" ? m[1] : "misc")

      gsub(/\r/, "", body)
      gsub(/\n+/, " ", body)

      dt = strftime("%Y-%m-%d %H:%M:%S", ts)

      print esc_csv(author_name) "," esc_csv(email) "," esc_csv(commit_id) "," esc_csv(type) "," esc_csv(dt) "," esc_csv(subject) "," esc_csv(body)
    }
  '
}

self_update() {
  local script_url="https://raw.githubusercontent.com/infocyph/Toolset/main/Git/gitx"
  local temp_file="/tmp/gitx_latest"
  local local_file

  local_file="$(command -v gitx 2>/dev/null || true)"
  if [[ -z "$local_file" ]]; then
    local_file="/usr/local/bin/gitx"
  fi

  echo -e "${YELLOW}Checking for updates to gitx...${NC}"

  if ! curl -fsSL "$script_url" -o "$temp_file"; then
    echo -e "${RED}Failed to download the latest gitx script from GitHub.${NC}"
    return 1
  fi

  local remote_hash local_hash
  remote_hash="$(sha256sum "$temp_file" | awk '{print $1}')"
  local_hash="$(sha256sum "$local_file" 2>/dev/null | awk '{print $1}')"

  if [[ -n "$local_hash" && "$remote_hash" == "$local_hash" ]]; then
    echo -e "${GREEN}gitx is already up-to-date.${NC}"
    rm -f "$temp_file"
    return 0
  fi

  if [[ -e "$local_file" && ! -w "$local_file" ]]; then
    echo -e "${RED}Cannot write to $local_file. Run with sudo or install gitx in a writable location.${NC}"
    rm -f "$temp_file"
    return 1
  fi

  if [[ -f "$local_file" ]]; then
    mv "$local_file" "${local_file}.bak-$(date +'%Y%m%d%H%M%S')" 2>/dev/null || true
  fi

  if ! mv "$temp_file" "$local_file"; then
    echo -e "${RED}Failed to overwrite $local_file with the new gitx script.${NC}"
    return 1
  fi

  chmod +x "$local_file"

  echo -e "${GREEN}gitx has been updated successfully to the latest version.${NC}"
}

# Simple doctor command: health check
doctor_repo() {
  ensure_git_repo
  local root current_branch main_branch
  root=$(git rev-parse --show-toplevel)
  current_branch=$(git rev-parse --abbrev-ref HEAD)
  main_branch=$(detect_main_branch)

  echo "üîé gitx doctor"
  echo "Repository: $root"
  echo "Current Branch: $current_branch (main: $main_branch)"

  if git rev-parse --abbrev-ref @{upstream} &>/dev/null; then
    local behind ahead
    read -r behind ahead <<<"$(git rev-list --left-right --count @{upstream}...HEAD 2>/dev/null)"
    echo "Upstream: ahead $ahead, behind $behind"
  else
    echo "Upstream: no tracking branch set."
  fi

  local status_count untracked_count stash_count
  status_count=$(git status --porcelain | wc -l | tr -d ' ')
  untracked_count=$(git status --porcelain | awk '$1=="??"' | wc -l | tr -d ' ')
  stash_count=$(git stash list | wc -l | tr -d ' ')

  echo "Working tree: $status_count changes ($untracked_count untracked)"
  echo "Stashes: $stash_count"

  local merged_branches
  merged_branches=$(git branch --merged "$main_branch" | grep -vE "(^\*|master|main|develop|alpha)" || true)
  if [[ -n "$merged_branches" ]]; then
    echo ""
    echo "Branches merged into $main_branch but still present:"
    echo "$merged_branches"
  fi

  echo ""
  echo ".git directory size: $(du -sh .git 2>/dev/null | awk '{print $1}')"

  echo ""
  echo "Top 5 largest blobs (by size):"
  git rev-list --objects --all |
    git cat-file --batch-check='%(objecttype) %(objectname) %(objectsize) %(rest)' |
    awk '$1=="blob" {print $3, $4}' |
    sort -k1 -nr |
    head -5 |
    awk '{printf "%s bytes  %s\n", $1, $2}'
}

# Hooks initializer
hooks_manager() {
  ensure_git_repo
  local sub="${1:-}"

  if [[ "$sub" != "init" ]]; then
    echo "Usage: gitx hooks init"
    return 1
  fi

  local root hooks_dir
  root=$(git rev-parse --show-toplevel)
  hooks_dir="$root/.git/hooks"
  mkdir -p "$hooks_dir"

  cat >"$hooks_dir/prepare-commit-msg.gitx" <<'EOF'
#!/bin/sh
# gitx prepare-commit-msg hook example
# Appends Conventional Commit template as comments.

MSG_FILE="$1"
COMMIT_SOURCE="$2"

# Skip merges, rebases, etc.
case "$COMMIT_SOURCE" in
  merge|squash|commit|message) ;;
  *) exit 0 ;;
esac

if [ ! -f "$MSG_FILE" ]; then
  exit 0
fi

if grep -q "Conventional Commit format" "$MSG_FILE"; then
  exit 0
fi

cat <<'TEMPLATE' >>"$MSG_FILE"

# Conventional Commit format: <type>(scope?): <subject>
# Types: feat, fix, chore, docs, refactor, test, perf, build, ci, style, revert
# Example: feat(auth): add login with OTP
# Optional: use gitmoji: :sparkles: feat: add new feature

TEMPLATE
EOF

  cat >"$hooks_dir/pre-commit.gitx" <<'EOF'
#!/bin/sh
# gitx pre-commit hook example
# Fails commit if conflict markers are present.

if git diff --cached | grep -q '<<<<<<< HEAD'; then
  echo "Error: Conflict markers detected in staged changes."
  echo "Please resolve conflicts before committing."
  exit 1
fi

exit 0
EOF

  cat >"$hooks_dir/pre-push.gitx" <<'EOF'
#!/bin/sh
# gitx pre-push hook example
# Runs tests if a common test runner is found.

if [ -f "vendor/bin/pest" ]; then
  echo "Running Pest tests..."
  vendor/bin/pest || exit 1
elif [ -f "vendor/bin/phpunit" ]; then
  echo "Running PHPUnit tests..."
  vendor/bin/phpunit || exit 1
fi

exit 0
EOF

  chmod +x "$hooks_dir/"*.gitx

  echo "Hook templates installed:"
  echo "  - $hooks_dir/prepare-commit-msg.gitx"
  echo "  - $hooks_dir/pre-commit.gitx"
  echo "  - $hooks_dir/pre-push.gitx"

  read -rp "Activate these hooks now (copy without .gitx)? (y/n): " yn
  if [[ "$yn" == "y" ]]; then
    cp "$hooks_dir/prepare-commit-msg.gitx" "$hooks_dir/prepare-commit-msg"
    cp "$hooks_dir/pre-commit.gitx" "$hooks_dir/pre-commit"
    cp "$hooks_dir/pre-push.gitx" "$hooks_dir/pre-push"
    chmod +x "$hooks_dir/prepare-commit-msg" "$hooks_dir/pre-commit" "$hooks_dir/pre-push"
    echo "Hooks activated."
  else
    echo "You can manually enable them by copying *.gitx to hook names in .git/hooks."
  fi
}

trap "echo -e '${RED}Process interrupted. Exiting.${NC}'; exit 6" SIGINT SIGTERM

# Main script logic
case $1 in
status) show_status ;;
commit) interactive_commit ;;
revert) revert_commit ;;
log-file) file_log "$2" ;;
fetch) fetch_and_prune ;;
large-files) show_large_files ;;
clean) clean_untracked "$2" ;;
cherry-pick) cherry_pick_commit ;;
reset-branch) reset_branch_to_remote ;;
prune) prune_remote_branches ;;
report) fetch_prs_and_commits "$2" "$3" "$4" ;;
diff) track_staged_changes "$2" ;;
stash) stash_operations "$2" "$3" ;;
wip) wip_manager "$2" "$3" ;;
create) create_branch "$2" "$3" ;;
sync) sync_branches ;;
merge) merge_branch "$2" "$3" ;;
tag) tag_release "$2" ;;
cleanup) cleanup_branches ;;
orphan-branches) orphan_branches "$2" ;;
compare) compare_branches "$2" "$3" ;;
config) edit_git_config ;;
summarize) summarize_repo "$2" ;;
doctor) doctor_repo ;;
hooks) hooks_manager "$2" ;;
commit-report) generate_commit_report "$2" "$3" ;;
worklog) generate_worklog "$2" "$3" ;;
unstage) unstage_all ;;
amend) amend_commit_message ;;
add-remote) add_remote "$2" "$3" ;;
push-remote) push_to_remote "$2" "$3" ;;
pull-remote) pull_from_remote "$2" "$3" ;;
stage-deleted) stage_deleted_files ;;
stage-deleted-dir) stage_deleted_in_directory "$2" ;;
initial-commit) get_initial_commit ;;
latest-tag) get_latest_tag ;;
changelog) generate_changelog "$2" "$3" ;;
count-changes) count_changes_between_commits "$2" "$3" ;;
list-changes) list_changed_files_between_branches "$2" "$3" ;;
set-lf) set_line_endings_to_lf ;;
self-update) self_update ;;
summary) generate_git_summary "$2" "$3" "$4" ;;
*) usage ;;
esac
